#include <xamarin/xamarin.h>
#include "registrar.h"
extern "C" {
static id native_to_managed_trampoline_1 (id self, SEL _cmd, MonoMethod **managed_method_ptr, bool* call_super, uint32_t token_ref)
{
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static id native_to_managed_trampoline_2 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCoder * p0, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static CIImage * native_to_managed_trampoline_3 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CIImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_4 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CIImage * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGPoint native_to_managed_trampoline_5 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGPoint res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGPoint *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_6 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGPoint p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static float native_to_managed_trampoline_7 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_8 (id self, SEL _cmd, MonoMethod **managed_method_ptr, float p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_9 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGAffineTransform native_to_managed_trampoline_10 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGAffineTransform res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGAffineTransform *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_11 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGAffineTransform p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSAttributedString * native_to_managed_trampoline_12 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSAttributedString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_13 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAttributedString * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSData * native_to_managed_trampoline_14 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSData * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_15 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSData * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CIBarcodeDescriptor * native_to_managed_trampoline_16 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CIBarcodeDescriptor * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_17 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CIBarcodeDescriptor * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CIColor * native_to_managed_trampoline_18 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CIColor * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_19 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CIColor * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CIVector * native_to_managed_trampoline_20 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CIVector * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_21 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CIVector * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static id native_to_managed_trampoline_22 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_23 (id self, SEL _cmd, MonoMethod **managed_method_ptr, id p0, uint32_t token_ref)
{
	MonoType *type0;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	type0 = xamarin_get_parameter_type (managed_method, 0);
	arg_ptrs [0] = xamarin_get_inative_object_dynamic (p0, false, mono_type_get_object (mono_domain_get (), type0), &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_24 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_25 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_26 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_27 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSInteger p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_28 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_29 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSArray * p0, uint32_t token_ref)
{
	MonoArray *marr0 = NULL;
	NSArray *arr0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arr0 = p0;
	marr0 = xamarin_nsarray_to_managed_nsobject_array (arr0, xamarin_get_parameter_type (managed_method, 0), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = marr0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_30 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_31 (id self, SEL _cmd, MonoMethod **managed_method_ptr, BOOL p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSString * native_to_managed_trampoline_32 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_33 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = xamarin_nsstring_to_string (NULL, p0);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_34 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_35 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_36 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, NSInteger p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static id native_to_managed_trampoline_37 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MLModelDescription * p0, NSDictionary <NSString *, NSObject *>* p1, NSError ** p2, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static void native_to_managed_trampoline_38 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_39 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_40 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_41 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_42 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNotification * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_43 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_44 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTimer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_45 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_46 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSViewController * native_to_managed_trampoline_47 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_48 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_49 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_50 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_51 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_52 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_53 (id self, SEL _cmd, MonoMethod **managed_method_ptr, EAAccessory * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_54 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, ICCameraFile * p1, NSURL * p2, NSData * p3, NSError * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_55 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_56 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_57 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKDeviceBrowserView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_58 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKDeviceBrowserView * p0, ICDevice * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_59 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_60 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_61 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, NSEvent * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_62 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_63 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKSaveOptions * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_64 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_65 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSData * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_66 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, ICScannerBandData * p1, NSDictionary * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_67 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_68 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_69 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_70 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKProductsRequest * p0, SKProductsResponse * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_71 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSError * p1, uint32_t token_ref)
{
	void * a0 = p0;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_72 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, PDFActionRemoteGoTo * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_73 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSString * native_to_managed_trampoline_74 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_75 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, CGFloat p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_76 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_77 (id self, SEL _cmd, MonoMethod **managed_method_ptr, Class p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_class (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_78 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFSelection * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_79 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = xamarin_nsstring_to_string (NULL, p0);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_80 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, NSUInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	unsigned long long nativeEnum3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKClusterAnnotation * native_to_managed_trampoline_81 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKClusterAnnotation * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_inativeobject_array_static (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, 0x88A20 /* MapKit.IMKAnnotation */ , 0x88C20 /* MapKit.MKAnnotationWrapper */ , &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_82 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_83 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_84 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_85 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_86 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_87 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKUserLocation * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKAnnotationView * native_to_managed_trampoline_88 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKAnnotationView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, 0x88A20 /* MapKit.IMKAnnotation */, 0x88C20 /* MapKit.MKAnnotationWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static MKOverlayRenderer * native_to_managed_trampoline_89 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKOverlayRenderer * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, 0x8C420 /* MapKit.IMKOverlay */, 0x8C620 /* MapKit.MKOverlayWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_90 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, unsigned int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_91 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_92 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSInteger p1, CLRegion * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_93 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_94 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_95 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_96 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_97 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_98 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLLocation * p1, CLLocation * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_99 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_100 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_101 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKPhysicsContact * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_102 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SCNPhysicsWorld * p0, SCNPhysicsContact * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_103 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_104 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_105 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, GKPlayer * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_106 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_107 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_108 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_109 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_110 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_111 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_112 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKGameCenterViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_113 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKAchievementViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_114 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_115 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_116 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKFriendRequestComposeViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_117 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKLeaderboardViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_118 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_119 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_120 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKMatch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_121 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_122 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_123 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_124 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_125 (id self, SEL _cmd, MonoMethod **managed_method_ptr, DOMEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_126 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrame * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_127 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_128 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, JSContext * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_129 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_130 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSImage * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_131 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_132 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURL * p1, double p2, NSDate * p3, WebFrame * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_133 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSWindow * native_to_managed_trampoline_134 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebDownload * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_135 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLAuthenticationChallenge * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_136 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSError * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_137 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_138 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_139 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_140 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSInteger p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_141 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLResponse * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSURLRequest * native_to_managed_trampoline_142 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLRequest * p2, NSURLResponse * p3, WebDataSource * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSURLRequest * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_143 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_144 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static WebView * native_to_managed_trampoline_145 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	WebView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_146 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGPoint p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_147 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_148 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_149 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_150 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id<NSDraggingInfo> p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSResponder * native_to_managed_trampoline_151 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSResponder * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_152 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_153 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_154 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSResponder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_155 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_156 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrameView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_157 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_158 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_159 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_160 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_161 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, WebFrame * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_162 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, 0x127820 /* WebKit.IWebOpenPanelResultListener */, 0x127A20 /* WebKit.WebOpenPanelResultListenerWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_163 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_164 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, SEL p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_165 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_166 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, id<NSDraggingInfo> p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_167 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_168 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_169 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_170 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, NSString * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = xamarin_nsstring_to_string (NULL, p3);
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype4, 4, true);
			goto exception_handling;
		}
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSMenu * native_to_managed_trampoline_171 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_172 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_173 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_174 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_175 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		arg_ptrs [2] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x157E820 /* AppKit.ContinueUserActivityRestorationHandler ObjCRuntime.Trampolines/NIDContinueUserActivityRestorationHandler::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_176 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_177 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_178 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_179 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_180 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_181 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_182 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_183 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDictionary * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_184 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, NSDictionary * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_185 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_186 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_187 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSArray * p0, NSArray * p1, uint32_t token_ref)
{
	MonoArray *marr0 = NULL;
	NSArray *arr0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arr0 = p0;
	marr0 = xamarin_nsarray_to_managed_string_array (arr0, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = marr0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_188 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_189 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_190 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, CKShareMetadata * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSError * native_to_managed_trampoline_191 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSError * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_192 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_193 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_194 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSOpenPanel * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_195 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableRowView * native_to_managed_trampoline_196 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableRowView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_197 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableRowView * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_198 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSCell * native_to_managed_trampoline_199 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_200 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, NSString * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = xamarin_nsstring_to_string (NULL, p3);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_201 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_202 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSIndexSet * native_to_managed_trampoline_203 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSIndexSet * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSIndexSet * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_204 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, CGRect* p2, NSTableColumn * p3, NSInteger p4, CGPoint p5, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = &p4;
	arg_ptrs [5] = &p5;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_205 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_206 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_207 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_208 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_209 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_210 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_211 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_212 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_213 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSEvent * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_214 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSObject * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_215 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_216 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_217 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_218 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, SEL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? xamarin_get_selector (p2, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_219 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_220 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, NSArray * p2, NSRange p3, NSInteger* p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_string_array (arr2, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;
	arg_ptrs [3] = &p3;
	arg_ptrs [4] = p4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_221 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSArray * p2, NSRange p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_222 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_223 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_224 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSText * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_225 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDocument * p0, BOOL p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_226 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_227 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_228 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSGestureRecognizer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_229 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_230 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSTouch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_231 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSClickGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_232 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMagnificationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_233 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPanGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_234 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPressGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_235 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRotationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_236 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_237 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_238 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSImage * native_to_managed_trampoline_239 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_240 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, CGRect* p1, NSUInteger* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1;
	arg_ptrs [2] = p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_241 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_242 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_243 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, 0x15CE20 /* AppKit.INSPasteboardWriting */, 0x15D020 /* AppKit.NSPasteboardWritingWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSWindow * native_to_managed_trampoline_244 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSImage * native_to_managed_trampoline_245 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, 0x15CE20 /* AppKit.INSPasteboardWriting */, 0x15D020 /* AppKit.NSPasteboardWritingWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_246 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSound * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_247 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextStorage * p0, NSUInteger p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_248 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_249 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_250 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_251 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSEvent * p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_252 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_253 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_254 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, double p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_255 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSWindow * p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_256 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_257 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, CGSize p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_258 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_259 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_260 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_261 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_262 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_263 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_264 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_265 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_266 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_267 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDatePickerCell * p0, NSDate ** p1, double p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *mobj1 = NULL;
	NSObject *nsobj1 = NULL;
	MonoType *paramtype1 = NULL;
	void * handle1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = *(NSObject **) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr (nsobj1, false, paramtype1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the byref parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = (int *) &mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj1 != NULL)
	handle1 = xamarin_get_nsobject_handle (mobj1);
	if (p1 != NULL)
		*p1 = (id) handle1;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_268 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_269 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_270 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_271 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_272 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_273 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSViewController * native_to_managed_trampoline_274 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_275 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSViewController * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_276 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSInteger p1, NSObject * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_277 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_278 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_279 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_280 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, NSString * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_281 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_282 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_283 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_284 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_285 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_286 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_287 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, NSError ** p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_288 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_289 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSearchField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static id native_to_managed_trampoline_290 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_291 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_292 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_293 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_294 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_295 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_296 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSText * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_297 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_298 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, unsigned long long p2, NSDictionary * p3, NSArray * p4, NSOrthography * p5, NSInteger p6, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoArray *marr4 = NULL;
	NSArray *arr4 = NULL;
	NSObject *nsobj5 = NULL;
	MonoObject *mobj5 = NULL;
	int32_t created5 = false;
	MonoType *paramtype5 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [7];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	arr4 = p4;
	marr4 = xamarin_nsarray_to_managed_nsobject_array (arr4, xamarin_get_parameter_type (managed_method, 4), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [4] = marr4;
	nsobj5 = (NSObject *) p5;
	if (nsobj5) {
		paramtype5 = xamarin_get_parameter_type (managed_method, 5);
		mobj5 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj5, false, paramtype5, &created5, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype5, 5, true);
			goto exception_handling;
		}
	}
	arg_ptrs [5] = mobj5;
	arg_ptrs [6] = &p6;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_299 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, SEL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_300 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSEvent * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_301 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_302 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, NSInteger* p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_303 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_304 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_305 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_306 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_307 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSMenu * p1, NSEvent * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_308 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = xamarin_nsstring_to_string (NULL, p2);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_309 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_string_array (arr2, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_310 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSDictionary * p1, NSDictionary * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_311 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_312 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSInteger p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_313 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_string_array (arr1, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_314 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_315 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_nsobject_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_316 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSDictionary * p2, unsigned long long p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_317 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = xamarin_string_to_nsstring ((MonoString *) retval, false);
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_318 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, NSPasteboard * p3, NSString * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = xamarin_nsstring_to_string (NULL, p4);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_319 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = xamarin_managed_string_array_to_nsarray ((MonoArray *) retval, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSToolbarItem * native_to_managed_trampoline_320 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSToolbarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTouchBarItem * native_to_managed_trampoline_321 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTouchBar * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTouchBarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_322 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_323 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_324 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSDictionary * p2, NSNumber * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_325 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_326 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_327 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_328 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_329 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBCentral * p1, CBCharacteristic * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_330 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_331 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, unsigned short p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_332 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBATTRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_333 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_334 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_335 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_336 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_337 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_338 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_339 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBCharacteristic * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_340 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_341 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_342 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr1 = NULL;
	NSArray *arr1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arr1 = p1;
	marr1 = xamarin_nsarray_to_managed_nsobject_array (arr1, xamarin_get_parameter_type (managed_method, 1), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [1] = marr1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_343 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSNumber * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_344 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBDescriptor * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_345 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_346 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_nsobject_array (arr2, xamarin_get_parameter_type (managed_method, 2), NULL, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_347 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVSpeechSynthesizer * p0, AVSpeechUtterance * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_348 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVSpeechSynthesizer * p0, NSRange p1, AVSpeechUtterance * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_349 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_350 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSUInteger p1, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_351 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void ** p0, NSUInteger* p1, uint32_t token_ref)
{
	void ** a0 = 0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	*p0 = a0;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_352 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_353 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_354 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, void * p1, void * p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	void * a1 = p1;
	void * a2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &a1;
	arg_ptrs [2] = &a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_355 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRunLoop * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_356 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_357 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSInputStream * p1, NSOutputStream * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_358 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_359 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_360 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_361 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_362 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_363 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static Class native_to_managed_trampoline_364 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSString * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoArray *marr2 = NULL;
	NSArray *arr2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arr2 = p2;
	marr2 = xamarin_nsarray_to_managed_string_array (arr2, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = marr2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_365 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_366 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_367 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_368 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStream * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_369 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, NULL, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_370 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, NSObject * p1, NSDictionary * p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	void * a3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_371 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCache * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_372 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSMetadataItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_373 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSString * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_374 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_nsstring_to_string (NULL, p1);
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_375 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSNetService * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_376 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_377 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_378 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_379 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_380 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x160BB20 /* System.Action`1<Foundation.NSUrlSessionResponseDisposition> ObjCRuntime.Trampolines/NIDActionArity1V39::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_381 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSData * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_382 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_383 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSCachedURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1602B20 /* System.Action`1<Foundation.NSCachedUrlResponse> ObjCRuntime.Trampolines/NIDActionArity1V36::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_384 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSHTTPURLResponse * p2, NSURLRequest * p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		arg_ptrs [4] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x160B220 /* System.Action`1<Foundation.NSUrlRequest> ObjCRuntime.Trampolines/NIDActionArity1V40::Create(System.IntPtr) */ , 4, p4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_385 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSURLAuthenticationChallenge * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1642D20 /* System.Action`2<Foundation.NSUrlSessionAuthChallengeDisposition,Foundation.NSUrlCredential> ObjCRuntime.Trampolines/NIDActionArity2V44::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_386 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_387 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_388 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_generic_method_from_token (mthis, token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGSize native_to_managed_trampoline_389 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGSize p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_390 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CGRect p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &p0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_391 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_392 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_393 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, WebFrame * p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype1, 1, true);
			goto exception_handling;
		}
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype3, 3, true);
			goto exception_handling;
		}
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = xamarin_get_inative_object_static (p4, false, 0x127C20 /* WebKit.IWebPolicyDecisionListener */, 0x127E20 /* WebKit.WebPolicyDecisionListenerWrapper */, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_394 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSplitView * p0, CGRect p1, CGRect p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_395 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAttributedString * p0, CGRect p1, NSView * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype2, 2, true);
			goto exception_handling;
		}
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_396 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_397 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_398 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSInteger native_to_managed_trampoline_399 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_400 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTextField * native_to_managed_trampoline_401 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextField * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_402 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTextFieldCell * native_to_managed_trampoline_403 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextFieldCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_404 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextFieldCell * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSComboBox * native_to_managed_trampoline_405 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSComboBox * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_406 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSStepper * native_to_managed_trampoline_407 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSStepper * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_408 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStepper * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_409 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSButton * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE_OR_DETACHED;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, &exception_gchandle);
		if (exception_gchandle != 0) {
			exception_gchandle = xamarin_get_exception_for_parameter (8029, exception_gchandle, "Unable to marshal the parameter", _cmd, managed_method, paramtype0, 0, true);
			goto exception_handling;
		}
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}




#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SFSpeechRecognitionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SFSpeechRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PKPushRegistryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x21A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHLivePhotoViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x25620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHProjectTypeDescriptionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2F220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetListViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x37720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetProviding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x38720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetSearchViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x3B820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x51820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x53520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__ImageCaptureCore_ICDeviceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x5A420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__ImageCaptureCore_ICDeviceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x5C120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__ImageCaptureCore_ICScannerDeviceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x60520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EAAccessoryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6DE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CNContactPickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x71720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKCameraDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x82A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKDeviceBrowserViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x85820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKFilterCustomUIProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x87E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8B420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8DB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageEditPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSaveOptionsDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ED20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKScannerDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xA3B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSlideshowDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xA6A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation VSAccountManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x266520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UNUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x279C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPaymentTransactionObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x27EA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__StoreKit_SKPaymentQueueDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x285620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x28CA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKProductsRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x289F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SBApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E0020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E4620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E5520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E5E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHPhotoLibraryChangeObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x344520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFDocumentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x37C020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x384B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NWTCPConnectionAuthenticationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x3D6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCAdvertiserAssistantDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x41F520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCBrowserViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x421620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceAdvertiserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x423020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x424A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x425C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MDLLightProbeIrradianceDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x44C420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4A4620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x4A4920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPSCNNConvolutionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4AE820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4C1720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x4C1A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x57D220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__Metal_MTLCaptureScope {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x599E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTLDrawable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x5AD720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKAnnotation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x600620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKLocalSearchCompleterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x60BD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKMapViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x61F920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKOverlay {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x623820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__JavaScriptCore_JSExport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x63B120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKNamedEffect {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6B9D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAgentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6CDB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CWEventDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x71A020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CSSearchableIndexDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x776D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CLLocationManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x78CF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation CoreImage_CICmykHalftone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7D5120);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7D5220);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D5320);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x7D5420);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D5520);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D5620);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D5720);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D5820);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D5920);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D5A20);
	}

	-(float) grayComponentReplacement
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D5B20);
	}

	-(void) setGrayComponentReplacement:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D5C20);
	}

	-(float) underColorRemoval
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D5D20);
	}

	-(void) setUnderColorRemoval:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D5E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7D5F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D4920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D4C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICMYKHalftone {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x79EC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICmykHalftone class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation CoreImage_CIAccordionFoldTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(float) bottomHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7AF420);
	}

	-(void) setBottomHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7AF520);
	}

	-(float) numberOfFolds
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7AF620);
	}

	-(void) setNumberOfFolds:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7AF720);
	}

	-(float) foldShadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7AF820);
	}

	-(void) setFoldShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7AF920);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7AFA20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7AFB20);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7AFC20);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7AFD20);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7AFE20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7AFF20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B0020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7AEE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7AF120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICompositingFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F4820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAdditionCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B1520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B1820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B3020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B2E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineClamp {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B1D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7B1E20);
	}

	-(CGAffineTransform) transform
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x7B1F20);
	}

	-(void) setTransform:(CGAffineTransform)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_11 (self, _cmd, &managed_method, p0, 0x7B2020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B2120);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B1920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B1C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B3520);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7B3620);
	}

	-(CGAffineTransform) transform
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, 0x7B3720);
	}

	-(void) setTransform:(CGAffineTransform)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_11 (self, _cmd, &managed_method, p0, 0x7B3820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B3920);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B3120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B3420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTransform {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B4420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B4720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIReductionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8BB420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaAverage {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B4C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B4F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B5220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B5520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B6420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B6620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B6920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B6A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B6D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B6E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B7120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMax {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B7220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B7520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMaxRed {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B7820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B7B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIImageGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x84C120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAttributedTextImageGenerator {
}

	-(NSAttributedString *) text
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x7B8220);
	}

	-(void) setText:(NSAttributedString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x7B8320);
	}

	-(float) scaleFactor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7B8420);
	}

	-(void) setScaleFactor:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7B8520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7B8620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B7E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7B8120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D9A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAztecCodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7BA620);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7BA720);
	}

	-(float) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7BA820);
	}

	-(void) setCorrectionLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7BA920);
	}

	-(float) layers
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7BAA20);
	}

	-(void) setLayers:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7BAB20);
	}

	-(float) compactStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7BAC20);
	}

	-(void) setCompactStyle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7BAD20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7BAE20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7B9D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7BA020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarcodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIBarcodeDescriptor *) barcodeDescriptor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_16 (self, _cmd, &managed_method, 0x7BD220);
	}

	-(void) setBarcodeDescriptor:(CIBarcodeDescriptor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, 0x7BD320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7BD420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7BC920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7BCC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITransitionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F2B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8F2C20);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F2D20);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8F2E20);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F2F20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F3020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F3120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8F2920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarsSwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7BDB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7BDE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBicubicScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C0120);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7C0220);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C0320);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C0420);
	}

	-(float) aspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C0520);
	}

	-(void) setAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C0620);
	}

	-(float) parameterB
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C0720);
	}

	-(void) setParameterB:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C0820);
	}

	-(float) parameterC
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C0920);
	}

	-(void) setParameterC:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C0A20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C0B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7BF920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7BFC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C2420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithMask {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C6920);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7C6A20);
	}

	-(CIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C6B20);
	}

	-(void) setBackgroundImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7C6C20);
	}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C6D20);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7C6E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C6F20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C6220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C6520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithAlphaMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C5A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C5D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithBlueMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C5E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithRedMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C7E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C8120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C8620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7C8720);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C8820);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C8920);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7C8A20);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7C8B20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C8C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C8220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C8520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x865120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBokehBlur {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7C9F20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7CA020);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CA120);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CA220);
	}

	-(float) ringAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CA320);
	}

	-(void) setRingAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CA420);
	}

	-(float) ringSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CA520);
	}

	-(void) setRingSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CA620);
	}

	-(float) softness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CA720);
	}

	-(void) setSoftness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CA820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7CA920);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7C9B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7C9E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBoxBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7CC420);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7CC520);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CC620);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CC720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7CC820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CC020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7CC320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDistortionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80D120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CD320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7CD620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortionLinear {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CD920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7CDC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICameraCalibrationLensCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CE120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7CE420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICheckerboardGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7CF120);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x7CF220);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x7CF320);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x7CF420);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x7CF520);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x7CF620);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CF720);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CF820);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7CF920);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7CFA20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7CFB20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CEB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7CEE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircleSplashDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D1220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D1520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C5520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7D1A20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7D1B20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7D1C20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x7D1D20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D1E20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D1F20);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D2020);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D2120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7D2220);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D1620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D1920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularWrap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D3520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D3820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D4120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D4420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICode128BarcodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7D8320);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7D8420);
	}

	-(float) quietSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D8520);
	}

	-(void) setQuietSpace:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D8620);
	}

	-(float) barcodeHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7D8720);
	}

	-(void) setBarcodeHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7D8820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7D8920);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D7E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7D8120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D9E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7DA120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DA220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7DA520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DAE20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7DAF20);
	}

	-(CIVector *) minComponents
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7DB020);
	}

	-(void) setMinComponents:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7DB120);
	}

	-(CIVector *) maxComponents
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7DB220);
	}

	-(void) setMaxComponents:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7DB320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DB420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DA620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7DA920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorControls {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DC720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7DC820);
	}

	-(float) saturation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7DC920);
	}

	-(void) setSaturation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7DCA20);
	}

	-(float) brightness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7DCB20);
	}

	-(void) setBrightness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7DCC20);
	}

	-(float) contrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7DCD20);
	}

	-(void) setContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7DCE20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DCF20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DC320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7DC620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCrossPolynomial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DE720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7DE820);
	}

	-(CIVector *) redCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7DE920);
	}

	-(void) setRedCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7DEA20);
	}

	-(CIVector *) greenCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7DEB20);
	}

	-(void) setGreenCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7DEC20);
	}

	-(CIVector *) blueCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7DED20);
	}

	-(void) setBlueCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7DEE20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7DEF20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DE220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7DE520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCube {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E0720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E0820);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7E0920);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7E0A20);
	}

	-(NSData *) cubeData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7E0B20);
	}

	-(void) setCubeData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7E0C20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E0D20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E0220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E0520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubesMixedWithMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E2020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E2120);
	}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E2220);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E2320);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7E2420);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7E2520);
	}

	-(NSData *) cube0Data
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7E2620);
	}

	-(void) setCube0Data:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7E2720);
	}

	-(NSData *) cube1Data
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7E2820);
	}

	-(void) setCube1Data:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7E2920);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_22 (self, _cmd, &managed_method, 0x7E2A20);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x7E2B20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E2C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E1C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E1F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubeWithColorSpace {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E4B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E4C20);
	}

	-(float) cubeDimension
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7E4D20);
	}

	-(void) setCubeDimension:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7E4E20);
	}

	-(NSData *) cubeData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7E4F20);
	}

	-(void) setCubeData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7E5020);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_22 (self, _cmd, &managed_method, 0x7E5120);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x7E5220);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E5320);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E4720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E4A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCurves {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E6A20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E6B20);
	}

	-(NSData *) curvesData
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x7E6C20);
	}

	-(void) setCurvesData:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x7E6D20);
	}

	-(CIVector *) curvesDomain
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7E6E20);
	}

	-(void) setCurvesDomain:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7E6F20);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_22 (self, _cmd, &managed_method, 0x7E7020);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x7E7120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E7220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E6620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E6920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E8520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E8820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorInvert {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E8D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7E8E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7E8F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E8920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E8C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EA020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EA120);
	}

	-(CIImage *) gradientImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EA220);
	}

	-(void) setGradientImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EA320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EA420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E9C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7E9F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMatrix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EB320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EB420);
	}

	-(CIVector *) RVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EB520);
	}

	-(void) setRVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EB620);
	}

	-(CIVector *) GVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EB720);
	}

	-(void) setGVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EB820);
	}

	-(CIVector *) BVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EB920);
	}

	-(void) setBVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EBA20);
	}

	-(CIVector *) AVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EBB20);
	}

	-(void) setAVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EBC20);
	}

	-(CIVector *) biasVector
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EBD20);
	}

	-(void) setBiasVector:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EBE20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EBF20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7EAF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7EB220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMonochrome {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EDE20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EDF20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x7EE020);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x7EE120);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7EE220);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7EE320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EE420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7EDA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7EDD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPolynomial {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7EF720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7EF820);
	}

	-(CIVector *) redCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EF920);
	}

	-(void) setRedCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EFA20);
	}

	-(CIVector *) greenCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EFB20);
	}

	-(void) setGreenCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EFC20);
	}

	-(CIVector *) blueCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EFD20);
	}

	-(void) setBlueCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7EFE20);
	}

	-(CIVector *) alphaCoefficients
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x7EFF20);
	}

	-(void) setAlphaCoefficients:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x7F0020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7F0120);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7EF320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7EF620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPosterize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7F1C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7F1D20);
	}

	-(float) levels
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7F1E20);
	}

	-(void) setLevels:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7F1F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7F2020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F1820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F1B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColumnAverage {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F2B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F2E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIComicEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7F3320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7F3420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7F3520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F2F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F3220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConstantColorGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F4E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F5120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionCore {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F8520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution3X3 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F6F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F7220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution5X5 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F7320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F7620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution7X7 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F7720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F7A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Horizontal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F7B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F7E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Vertical {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F7F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F8220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICopyMachineTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F9B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7F9E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICoreMLModelFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FBF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7FC220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FDD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7FE020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrystallize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7FEB20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x7FEC20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x7FED20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x7FEE20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x7FEF20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x7FF020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x7FF120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FE520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x7FE820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDarkenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x800020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x800320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthBlurEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x801020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x801320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthDisparityConverter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x803420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthOfField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x803E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x803F20);
	}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x804020);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x804120);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x804220);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x804320);
	}

	-(float) saturation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x804420);
	}

	-(void) setSaturation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x804520);
	}

	-(float) unsharpMaskRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x804620);
	}

	-(void) setUnsharpMaskRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x804720);
	}

	-(float) unsharpMaskIntensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x804820);
	}

	-(void) setUnsharpMaskIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x804920);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x804A20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x804B20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x804C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x803620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x803920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthToDisparity {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x806F20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x807020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x807120);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x806B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x806E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDifferenceBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x807820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x807B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDiscBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x808020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x808120);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x808220);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x808320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x808420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x807C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x807F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisintegrateWithMaskTransition {
}

	-(CIImage *) maskImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x809720);
	}

	-(void) setMaskImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x809820);
	}

	-(float) shadowRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x809920);
	}

	-(void) setShadowRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x809A20);
	}

	-(float) shadowDensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x809B20);
	}

	-(void) setShadowDensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x809C20);
	}

	-(CGPoint) shadowOffset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x809D20);
	}

	-(void) setShadowOffset:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x809E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x809F20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x808F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x809220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisparityToDepth {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80B620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x80B720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80B820);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80B220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80B520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisplacementDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80BF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80C220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDissolveTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80C920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80CC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDither {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80DD20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x80DE20);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x80DF20);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x80E020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80E120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80D920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80DC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDivideBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80EC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80EF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDocumentEnhancer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80F420);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x80F520);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x80F620);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x80F720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x80F820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x80F020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x80F320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDotScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x810720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x810820);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x810920);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x810A20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x810B20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x810C20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x810D20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x810E20);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x810F20);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x811020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x811120);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x810320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x810620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDroste {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x812820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x812B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgePreserveUpsampleFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x813E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x813F20);
	}

	-(CIImage *) smallImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x814020);
	}

	-(void) setSmallImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x814120);
	}

	-(float) spatialSigma
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x814220);
	}

	-(void) setSpatialSigma:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x814320);
	}

	-(float) lumaSigma
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x814420);
	}

	-(void) setLumaSigma:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x814520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x814620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x813A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x813D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdges {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x815D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x815E20);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x815F20);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x816020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x816120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x815920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x815C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgeWork {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x817020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x817120);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x817220);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x817320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x817420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x816C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x816F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITileFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8EDA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEightfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x818320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x818420);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x818520);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x818620);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x818720);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x818820);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x818920);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x818A20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x818B20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x817F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x818220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExclusionBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x819E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x81A120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExposureAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x81A620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x81A720);
	}

	-(float) EV
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x81A820);
	}

	-(void) setEV:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x81A920);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x81AA20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x81A220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x81A520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFaceBalance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x81B720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFalseColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x81D020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x81D120);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x81D220);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x81D320);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x81D420);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x81D520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x81D620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x81CC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x81CF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFlashTransition {
}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x828220);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x828320);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x828420);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x828520);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x828620);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x828720);
	}

	-(float) maxStriationRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x828820);
	}

	-(void) setMaxStriationRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x828920);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x828A20);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x828B20);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x828C20);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x828D20);
	}

	-(float) fadeThreshold
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x828E20);
	}

	-(void) setFadeThreshold:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x828F20);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x829020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x829120);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x829220);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x829320);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x829420);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x829520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x829620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x827620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x827920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x82D520);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x82D620);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x82D720);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x82D820);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x82D920);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x82DA20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x82DB20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x82DC20);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x82DD20);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x82DE20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x82DF20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x82D120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x82D420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldRotatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x82FA20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x82FB20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x82FC20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x82FD20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x82FE20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x82FF20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x830020);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x830120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x830220);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x82F620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x82F920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldTranslatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x831920);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x831A20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x831B20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x831C20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x831D20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x831E20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x831F20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x832020);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x832120);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x832220);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x832320);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x831520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x831820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaborGradients {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x833E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x833F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x834020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x833A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x833D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGammaAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x834B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x834C20);
	}

	-(float) power
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x834D20);
	}

	-(void) setPower:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x834E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x834F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x834720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x834A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x835E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x835F20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x836020);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x836120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x836220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x835A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x835D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x837320);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x837420);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x837520);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x837620);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x837720);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x837820);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x837920);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x837A20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x837B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x836D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x837020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x838E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x839120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassLozenge {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x839A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x839D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlideReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83AC20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x83AD20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x83AE20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x83AF20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83B020);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83B120);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83B220);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83B320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83B420);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x83A820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x83AB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83CB20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x83CC20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83CD20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83CE20);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83CF20);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83D020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83D120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x83C720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x83CA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGuidedFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x83E020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x83E320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHardLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x83EC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x83EF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHatchedScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83F420);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x83F520);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x83F620);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x83F720);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83F820);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83F920);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83FA20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83FB20);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x83FC20);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x83FD20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x83FE20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x83F020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x83F320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHeightFieldFromMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x841920);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x841A20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x841B20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x841C20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x841D20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x841520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x841820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHexagonalPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x842E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x842F20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x843020);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x843120);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x843220);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x843320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x843420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x842820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x842B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHighlightShadowAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x844720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x844820);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x844920);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x844A20);
	}

	-(float) shadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x844B20);
	}

	-(void) setShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x844C20);
	}

	-(float) highlightAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x844D20);
	}

	-(void) setHighlightAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x844E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x844F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x844320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x844620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHistogramDisplayFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x846220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x846520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHoleDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x846E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x847120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x847620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x847720);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x847820);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x847920);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x847A20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x847220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x847520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x848520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x848820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueSaturationValueGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(float) value
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x848D20);
	}

	-(void) setValue:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x848E20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x848F20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x849020);
	}

	-(float) softness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x849120);
	}

	-(void) setSoftness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x849220);
	}

	-(float) dither
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x849320);
	}

	-(void) setDither:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x849420);
	}

	-(id) colorSpace
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_22 (self, _cmd, &managed_method, 0x849520);
	}

	-(void) setColorSpace:(id)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, 0x849620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x849720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x848920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x848C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end


@implementation CoreImage_CIKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x852C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x852D20);
	}

	-(NSInteger) count
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_26 (self, _cmd, &managed_method, 0x852E20);
	}

	-(void) setCount:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0x852F20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x853020);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x853120);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x853220);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x853320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x853420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x852420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x852720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x855420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionCombined {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x856D20);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x856E20);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x856F20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x857020);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x857120);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x857220);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x857320);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x857420);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x857520);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x857620);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x857720);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x857820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x857920);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x856820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x856B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionHorizontal {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x858F20);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x859020);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x859120);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x859220);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x859320);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x859420);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x859520);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x859620);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x859720);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x859820);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x859920);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x859A20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x859B20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x858A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x858D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKeystoneCorrectionVertical {
}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x85B120);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x85B220);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85B320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x85B420);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x85B520);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x85B620);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x85B720);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x85B820);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x85B920);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x85BA20);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x85BB20);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x85BC20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85BD20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x85AC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x85AF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIKeystoneCorrection class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIKMeans {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x85CE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x85D120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILabDeltaE {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85DE20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x85DF20);
	}

	-(CIImage *) image2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85E020);
	}

	-(void) setImage2:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x85E120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85E220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x85DA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x85DD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILanczosScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85F120);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x85F220);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x85F320);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x85F420);
	}

	-(float) aspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x85F520);
	}

	-(void) setAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x85F620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x85F720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x85ED20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x85F020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILenticularHaloGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x860C20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x860D20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x860E20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x860F20);
	}

	-(float) haloRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861020);
	}

	-(void) setHaloRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861120);
	}

	-(float) haloWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861220);
	}

	-(void) setHaloWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861320);
	}

	-(float) haloOverlap
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861420);
	}

	-(void) setHaloOverlap:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861520);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861620);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861720);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861820);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861920);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x861A20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x861B20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x861C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x860620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x860920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x863F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x864220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightTunnel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x864320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x864620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x865520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x865820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x865920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x865C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x866620);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x866720);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x866820);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x866920);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x866A20);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x866B20);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x866C20);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x866D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x866E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x865D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x866020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearToSRGBToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x868520);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x868620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x868720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x868120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x868420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineOverlay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x869220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x869320);
	}

	-(float) NRNoiseLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x869420);
	}

	-(void) setNRNoiseLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x869520);
	}

	-(float) NRSharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x869620);
	}

	-(void) setNRSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x869720);
	}

	-(float) edgeIntensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x869820);
	}

	-(void) setEdgeIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x869920);
	}

	-(float) threshold
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x869A20);
	}

	-(void) setThreshold:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x869B20);
	}

	-(float) contrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x869C20);
	}

	-(void) setContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x869D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x869E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x868E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x869120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineScreen {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86BD20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x86BE20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x86BF20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x86C020);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x86C120);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x86C220);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x86C320);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x86C420);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x86C520);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x86C620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86C720);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x86B920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x86BC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILuminosityBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x86DE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x86E120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskedVariableBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86E620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x86E720);
	}

	-(CIImage *) mask
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86E820);
	}

	-(void) setMask:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x86E920);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x86EA20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x86EB20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86EC20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x86E220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x86E520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskToAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x86FF20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x870020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x870120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x86FB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x86FE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x870C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x870D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x870E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x870820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x870B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x871520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x871820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMedianFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x871D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x871E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x871F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x871920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x871C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMeshGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x872A20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x872B20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x872C20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x872D20);
	}

	-(NSArray *) mesh
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_28 (self, _cmd, &managed_method, 0x872E20);
	}

	-(void) setMesh:(NSArray *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, 0x872F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x873020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x872620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x872920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x874320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x874420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x874520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x873F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x874220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x874C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x874F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x875420);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x875520);
	}

	-(CIImage *) backgroundImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x875620);
	}

	-(void) setBackgroundImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x875720);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x875820);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x875920);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x875A20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x875020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x875320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIModTransition {
}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x876F20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x877020);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x877120);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x877220);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x877320);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x877420);
	}

	-(float) compression
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x877520);
	}

	-(void) setCompression:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x877620);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x877720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x877820);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x877920);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x877A20);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x877B20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x877C20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x877D20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x876920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x876C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphology {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x879820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyGradient {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87A020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x87A120);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x87A220);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x87A320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87A420);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x879C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x879F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMaximum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87B320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x87B420);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x87B520);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x87B620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87B720);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x87AF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x87B220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMinimum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87C620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x87C720);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x87C820);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x87C920);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87CA20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x87C220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x87C520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangle {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x87D720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangleMaximum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87E520);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x87E620);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x87E720);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x87E820);
	}

	-(float) height
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x87E920);
	}

	-(void) setHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x87EA20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87EB20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x87E120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x87E420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyRectangleMinimum {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x87FE20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x87FF20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x880020);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x880120);
	}

	-(float) height
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x880220);
	}

	-(void) setHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x880320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x880420);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x87FA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x87FD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphologyRectangle class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMotionBlur {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x881720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x881820);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x881920);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x881A20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x881B20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x881C20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x881D20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x881320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x881620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x882C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x882F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x883020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x883320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartStretched {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x883420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x883720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartTiled {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x884020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x884320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINoiseReduction {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x885220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x885320);
	}

	-(float) noiseLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x885420);
	}

	-(void) setNoiseLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x885520);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x885620);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x885720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x885820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x884E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x885120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOpTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x886B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x886C20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x886D20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x886E20);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x886F20);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x887020);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x887120);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x887220);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x887320);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x887420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x887520);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x886720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x886A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOverlayBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x888C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x888F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlTransition {
}

	-(CIImage *) backsideImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x889620);
	}

	-(void) setBacksideImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x889720);
	}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x889820);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x889920);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x889A20);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x889B20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x889C20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x889D20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x889E20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x889F20);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88A020);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x88A120);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88A220);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x88A320);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88A420);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88A520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88A620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x889020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x889320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlWithShadowTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) backsideImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88CD20);
	}

	-(void) setBacksideImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x88CE20);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x88CF20);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x88D020);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88D120);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88D220);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88D320);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88D420);
	}

	-(float) shadowSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88D520);
	}

	-(void) setShadowSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88D620);
	}

	-(float) shadowAmount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88D720);
	}

	-(void) setShadowAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88D820);
	}

	-(CGRect) shadowExtent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x88D920);
	}

	-(void) setShadowExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x88DA20);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88DB20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x88DC20);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88DD20);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x88DE20);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x88DF20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x88E020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x88E120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x88C320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x88C620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPaletteCentroid {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x890A20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x890B20);
	}

	-(CIImage *) paletteImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x890C20);
	}

	-(void) setPaletteImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x890D20);
	}

	-(BOOL) perceptual
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x890E20);
	}

	-(void) setPerceptual:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x890F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x891020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x890620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x890920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPalettize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x892320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x892420);
	}

	-(CIImage *) paletteImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x892520);
	}

	-(void) setPaletteImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x892620);
	}

	-(BOOL) perceptual
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x892720);
	}

	-(void) setPerceptual:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x892820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x892920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x891F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x892220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIParallelogramTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x893C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x893D20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x893E20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x893F20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x894020);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x894120);
	}

	-(float) acuteAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x894220);
	}

	-(void) setAcuteAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x894320);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x894420);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x894520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x894620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x893820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x893B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPdf417BarcodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x896E20);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x896F20);
	}

	-(float) minWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897020);
	}

	-(void) setMinWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897120);
	}

	-(float) maxWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897220);
	}

	-(void) setMaxWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897320);
	}

	-(float) minHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897420);
	}

	-(void) setMinHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897520);
	}

	-(float) maxHeight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897620);
	}

	-(void) setMaxHeight:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897720);
	}

	-(float) dataColumns
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897820);
	}

	-(void) setDataColumns:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897920);
	}

	-(float) rows
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897A20);
	}

	-(void) setRows:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897B20);
	}

	-(float) preferredAspectRatio
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897C20);
	}

	-(void) setPreferredAspectRatio:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897D20);
	}

	-(float) compactionMode
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x897E20);
	}

	-(void) setCompactionMode:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x897F20);
	}

	-(float) compactStyle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x898020);
	}

	-(void) setCompactStyle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x898120);
	}

	-(float) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x898220);
	}

	-(void) setCorrectionLevel:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x898320);
	}

	-(float) alwaysSpecifyCompaction
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x898420);
	}

	-(void) setAlwaysSpecifyCompaction:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x898520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x898620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x895D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x896020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A4720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8A4820);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A4920);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A4A20);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A4B20);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A4C20);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A4D20);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A4E20);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A4F20);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A5020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A5120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A3920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A3C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveCorrection {
}

	-(BOOL) crop
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x89C920);
	}

	-(void) setCrop:(BOOL)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, 0x89CA20);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x89CB20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x89CC20);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x89CD20);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x89CE20);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x89CF20);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x89D020);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x89D120);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x89D220);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x89D320);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x89D420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x89D520);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x89C520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x89C820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveRotate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x89EB20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x89EC20);
	}

	-(float) focalLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x89ED20);
	}

	-(void) setFocalLength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x89EE20);
	}

	-(float) pitch
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x89EF20);
	}

	-(void) setPitch:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x89F020);
	}

	-(float) yaw
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x89F120);
	}

	-(void) setYaw:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x89F220);
	}

	-(float) roll
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x89F320);
	}

	-(void) setRoll:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x89F420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x89F520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x89E620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x89E920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTile {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A1820);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8A1920);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A1A20);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A1B20);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A1C20);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A1D20);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A1E20);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A1F20);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A2020);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A2120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A2220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A0C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A0F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransformWithExtent {
}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x8A6420);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x8A6520);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A6620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8A6720);
	}

	-(CGPoint) topLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A6820);
	}

	-(void) setTopLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A6920);
	}

	-(CGPoint) topRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A6A20);
	}

	-(void) setTopRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A6B20);
	}

	-(CGPoint) bottomRight
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A6C20);
	}

	-(void) setBottomRight:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A6D20);
	}

	-(CGPoint) bottomLeft
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8A6E20);
	}

	-(void) setBottomLeft:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8A6F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A7020);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A5E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A8520);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8A8620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8A8720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A8320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectChrome {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A8820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A8B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectFade {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A8C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A8F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectInstant {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A9020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A9320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectMono {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A9420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A9720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectNoir {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A9820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A9B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectProcess {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8A9C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8A9F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTonal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8AA620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8AA920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTransfer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8AAA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8AAD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinchDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8AAE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8AB120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8AB420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8AB720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8ABE20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8ABF20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8AC020);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8AC120);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8AC220);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8AC320);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8AC420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8AB820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8ABB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPointillize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8AE220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8AE320);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8AE420);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8AE520);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8AE620);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8AE720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8AE820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8ADC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8ADF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIQRCodeGenerator {
}

	-(NSData *) message
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x8B1720);
	}

	-(void) setMessage:(NSData *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x8B1820);
	}

	-(NSString *) correctionLevel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x8B1920);
	}

	-(void) setCorrectionLevel:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x8B1A20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8B1B20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8B1220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8B1520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRadialGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8B2C20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8B2D20);
	}

	-(float) radius0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8B2E20);
	}

	-(void) setRadius0:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8B2F20);
	}

	-(float) radius1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8B3020);
	}

	-(void) setRadius1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8B3120);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8B3220);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8B3320);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8B3420);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8B3520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8B3620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8B2620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8B2920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRandomGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8B5120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8B4D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8B5020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRippleTransition {
}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8BE820);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8BE920);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8BEA20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8BEB20);
	}

	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x8BEC20);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x8BED20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8BEE20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8BEF20);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8BF020);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8BF120);
	}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8BF220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8BF320);
	}

	-(CIImage *) targetImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8BF420);
	}

	-(void) setTargetImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8BF520);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8BF620);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8BF720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8BF820);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8BE020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8BE320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRoundedRectangleGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) extent
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_24 (self, _cmd, &managed_method, 0x8C1B20);
	}

	-(void) setExtent:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x8C1C20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8C1D20);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8C1E20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8C1F20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8C2020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C2120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C1520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C1820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRowAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C3020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C3320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaliencyMapFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C3C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8C3D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C3E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C3820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C3B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISampleNearest {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C4520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C4820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaturationBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C4B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C4E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C4F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C5220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISepiaTone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C6320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8C6420);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8C6520);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8C6620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C6720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C5F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C6220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIShadedMaterial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C7620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8C7720);
	}

	-(CIImage *) shadingImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C7820);
	}

	-(void) setShadingImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8C7920);
	}

	-(float) scale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8C7A20);
	}

	-(void) setScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8C7B20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C7C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C7220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C7520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISharpenLuminance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C8F20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8C9020);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8C9120);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8C9220);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8C9320);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8C9420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8C9520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C8B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8C8E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8CA820);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8CA920);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8CAA20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8CAB20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8CAC20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8CAD20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8CAE20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8CAF20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8CB020);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8CA420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8CA720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldRotatedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8CC720);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8CC820);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8CC920);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8CCA20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8CCB20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8CCC20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8CCD20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8CCE20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8CCF20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8CC320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8CC620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISmoothLinearGradient {
}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8CEA20);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8CEB20);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8CEC20);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8CED20);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8CEE20);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8CEF20);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8CF020);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8CF120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8CF220);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8CE220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8CE520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISoftLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D0520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D0820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceAtopCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D0920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D0C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceInCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D0D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D1020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOutCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D1120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D1420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOverCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D1520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D1820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D1D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8D1E20);
	}

	-(CIColor *) centerColor1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D1F20);
	}

	-(void) setCenterColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D2020);
	}

	-(CIColor *) replacementColor1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D2120);
	}

	-(void) setReplacementColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D2220);
	}

	-(float) closeness1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D2320);
	}

	-(void) setCloseness1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D2420);
	}

	-(float) contrast1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D2520);
	}

	-(void) setContrast1:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D2620);
	}

	-(CIColor *) centerColor2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D2720);
	}

	-(void) setCenterColor2:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D2820);
	}

	-(CIColor *) replacementColor2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D2920);
	}

	-(void) setReplacementColor2:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D2A20);
	}

	-(float) closeness2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D2B20);
	}

	-(void) setCloseness2:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D2C20);
	}

	-(float) contrast2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D2D20);
	}

	-(void) setContrast2:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D2E20);
	}

	-(CIColor *) centerColor3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D2F20);
	}

	-(void) setCenterColor3:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D3020);
	}

	-(CIColor *) replacementColor3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D3120);
	}

	-(void) setReplacementColor3:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D3220);
	}

	-(float) closeness3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D3320);
	}

	-(void) setCloseness3:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D3420);
	}

	-(float) contrast3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D3520);
	}

	-(void) setContrast3:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D3620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D3720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D1920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D1C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotLight {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D7220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8D7320);
	}

	-(CIVector *) lightPosition
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x8D7420);
	}

	-(void) setLightPosition:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x8D7520);
	}

	-(CIVector *) lightPointsAt
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x8D7620);
	}

	-(void) setLightPointsAt:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x8D7720);
	}

	-(float) brightness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D7820);
	}

	-(void) setBrightness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D7920);
	}

	-(float) concentration
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8D7A20);
	}

	-(void) setConcentration:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8D7B20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8D7C20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8D7D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D7E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D6E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D7120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISRGBToneCurveToLinear {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D9D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8D9E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8D9F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8D9920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8D9C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStarShineGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8DAC20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8DAD20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8DAE20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8DAF20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DB020);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DB120);
	}

	-(float) crossScale
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DB220);
	}

	-(void) setCrossScale:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DB320);
	}

	-(float) crossAngle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DB420);
	}

	-(void) setCrossAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DB520);
	}

	-(float) crossOpacity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DB620);
	}

	-(void) setCrossOpacity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DB720);
	}

	-(float) crossWidth
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DB820);
	}

	-(void) setCrossWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DB920);
	}

	-(float) epsilon
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DBA20);
	}

	-(void) setEpsilon:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DBB20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8DBC20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8DA620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8DA920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStraightenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8DE320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8DE420);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8DE520);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8DE620);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8DE720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8DDF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8DE220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStretchCrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8DF220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8DF520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStripesGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8E0420);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8E0520);
	}

	-(CIColor *) color0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8E0620);
	}

	-(void) setColor0:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8E0720);
	}

	-(CIColor *) color1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8E0820);
	}

	-(void) setColor1:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8E0920);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E0A20);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E0B20);
	}

	-(float) sharpness
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E0C20);
	}

	-(void) setSharpness:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E0D20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8E0E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8DFE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8E0120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISubtractBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8E2520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8E2820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISunbeamsGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8E3120);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8E3220);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x8E3320);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x8E3420);
	}

	-(float) sunRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E3520);
	}

	-(void) setSunRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E3620);
	}

	-(float) maxStriationRadius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E3720);
	}

	-(void) setMaxStriationRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E3820);
	}

	-(float) striationStrength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E3920);
	}

	-(void) setStriationStrength:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E3A20);
	}

	-(float) striationContrast
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E3B20);
	}

	-(void) setStriationContrast:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E3C20);
	}

	-(float) time
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8E3D20);
	}

	-(void) setTime:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8E3E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8E3F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8E2920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8E2C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8E5E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8E6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITemperatureAndTint {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8E8C20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8E8D20);
	}

	-(CIVector *) neutral
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x8E8E20);
	}

	-(void) setNeutral:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x8E8F20);
	}

	-(CIVector *) targetNeutral
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_20 (self, _cmd, &managed_method, 0x8E9020);
	}

	-(void) setTargetNeutral:(CIVector *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, 0x8E9120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8E9220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8E8820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8E8B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITextImageGenerator {
}

	-(NSString *) text
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x8EB020);
	}

	-(void) setText:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x8EB120);
	}

	-(NSString *) fontName
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_32 (self, _cmd, &managed_method, 0x8EB220);
	}

	-(void) setFontName:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, 0x8EB320);
	}

	-(float) fontSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8EB420);
	}

	-(void) setFontSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8EB520);
	}

	-(float) scaleFactor
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8EB620);
	}

	-(void) setScaleFactor:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8EB720);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8EB820);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8EAC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8EAF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIThermal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8ECF20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8ED020);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8ED120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8ECB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8ECE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8EF220);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8EF320);
	}

	-(CGPoint) point0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EF420);
	}

	-(void) setPoint0:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8EF520);
	}

	-(CGPoint) point1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EF620);
	}

	-(void) setPoint1:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8EF720);
	}

	-(CGPoint) point2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EF820);
	}

	-(void) setPoint2:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8EF920);
	}

	-(CGPoint) point3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EFA20);
	}

	-(void) setPoint3:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8EFB20);
	}

	-(CGPoint) point4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8EFC20);
	}

	-(void) setPoint4:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8EFD20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8EFE20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8EE420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8EE720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITorusLensDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8F1920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8F1C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F4620);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8F4720);
	}

	-(CGPoint) point
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8F4820);
	}

	-(void) setPoint:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8F4920);
	}

	-(float) size
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F4A20);
	}

	-(void) setSize:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F4B20);
	}

	-(float) rotation
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F4C20);
	}

	-(void) setRotation:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F4D20);
	}

	-(float) decay
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F4E20);
	}

	-(void) setDecay:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F4F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F5020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8F4020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8F4320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F6B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8F6C20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8F6D20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8F6E20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F6F20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F7020);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F7120);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F7220);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F7320);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8F6720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8F6A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwelvefoldReflectedTile {
}

	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F8A20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8F8B20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8F8C20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8F8D20);
	}

	-(float) angle
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F8E20);
	}

	-(void) setAngle:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F8F20);
	}

	-(float) width
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8F9020);
	}

	-(void) setWidth:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8F9120);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8F9220);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8F8620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8F8920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwirlDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8FA520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8FA820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIUnsharpMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FB320);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8FB420);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FB520);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FB620);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FB720);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FB820);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FB920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8FAF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8FB220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVibrance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FCC20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8FCD20);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FCE20);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FCF20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FD020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8FC820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8FCB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignette {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FDF20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8FE020);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FE120);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FE220);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FE320);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FE420);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FE520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8FDB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8FDE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignetteEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FEC20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x8FED20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x8FEE20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x8FEF20);
	}

	-(float) radius
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FF020);
	}

	-(void) setRadius:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FF120);
	}

	-(float) intensity
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FF220);
	}

	-(void) setIntensity:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FF320);
	}

	-(float) falloff
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x8FF420);
	}

	-(void) setFalloff:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x8FF520);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x8FF620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8FE620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x8FE920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVortexDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x901B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x901E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIWhitePointAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x902B20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x902C20);
	}

	-(CIColor *) color
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_18 (self, _cmd, &managed_method, 0x902D20);
	}

	-(void) setColor:(CIColor *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, 0x902E20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x902F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x902720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x902A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIXRay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x903E20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x903F20);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x904020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x903A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x903D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIZoomBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CIImage *) inputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x904D20);
	}

	-(void) setInputImage:(CIImage *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, 0x904E20);
	}

	-(CGPoint) center
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_5 (self, _cmd, &managed_method, 0x904F20);
	}

	-(void) setCenter:(CGPoint)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, 0x905020);
	}

	-(float) amount
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_7 (self, _cmd, &managed_method, 0x905120);
	}

	-(void) setAmount:(float)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, 0x905220);
	}

	-(CIImage *) outputImage
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, 0x905320);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x904720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x904A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CALayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x982120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAMediaTiming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CKRecordValue {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xA0FD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xABE020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xACC820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE3520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAnimatable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE8820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAF0120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNActionable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB2E420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAvoidOccluderConstraintDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB39120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNBoundingVolume {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB3A620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNCameraControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB49420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNNodeRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB6EE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB78F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNProgramDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB88720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneExportDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB91C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB95E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNShadable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB98A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNTechniqueSupport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB9CE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAchievementViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBF1F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBF4D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBF5C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengesViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBF7020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKFriendRequestComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBFA020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKGameCenterControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBFA720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKInviteEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBFD920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLeaderboardViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC02D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLocalPlayerListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC06720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC0A720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC0F520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSavedGameListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC12B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC17D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC19520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC1A520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC20320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebPolicyDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC39120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC5F820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventTarget {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC60420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_DomNodeFilter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC99620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDocumentRepresentation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCAAB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCABC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebFrameLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCAD020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebOpenPanelResultListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCB1720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebPolicyDecisionListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCB2120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebResourceLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCB8220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCBC720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKNavigationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCCF720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKScriptMessageHandler {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCD3D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCD5B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


@interface __monomac_internal_ActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0;
	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0;
	-(BOOL) validateMenuItem:(NSMenuItem *)p0;
	-(BOOL) worksWhenModal;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __monomac_internal_ActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0xCDF720);
	}

	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0xCDF820);
	}

	-(BOOL) validateMenuItem:(NSMenuItem *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0xCDFF20);
	}

	-(BOOL) worksWhenModal
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0xCE0020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCDFA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAlertDidEndDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSAlertDidEndDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, p1, p2, 0xD2D620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD30720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD84220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE5D020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegateFlowLayout {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE5F020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAccessibilityCustomRotorItemSearchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xECB320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlertDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEEFD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlignmentFeedbackToken {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEF0E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEF6320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAppearanceCustomization {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEF8620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF03F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCandidateListTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0DF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCloudSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF11120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF1ED20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewElement {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF21120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxCellDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF33220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF33E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10A8020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF34A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSControlTextEditingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF36B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDatePickerCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF42820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDockTilePlugIn {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF47C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4C120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4F720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDrawerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF67120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFilePromiseProviderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF6AB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSGestureRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF7AA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSHapticFeedbackPerformer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF85220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSImageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF88820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSLayoutManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF97820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMatrixDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF9B120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMenuDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFB4C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOpenSavePanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFC6420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFCD220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFD0A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPageControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFD6F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardItemDataProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFDD220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardReading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFDDA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardWriting {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFDE820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFDF720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFE0E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPopoverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFFA120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPrintPanelAccessorizing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1002F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSRuleEditorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x100C220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1025D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1026920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberFlowLayoutDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1027F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSearchFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1032220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSeguePerforming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1037E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x103D920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__AppKit_NSSharingServicePickerToolbarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x103EC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1040220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSoundDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1058620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x105A020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechSynthesizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x105AA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSplitViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1060820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpringLoadingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1064320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStackViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1067D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1083120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1085E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1088C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTabViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1091D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextAttachmentContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x109DC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10A4720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderBarContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10AB020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10ADC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextInputClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10B1920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextStorageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10B8520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10D2C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10D9420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10DAC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSToolbarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10E0120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTouchBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10E4720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSViewControllerPresentationAnimator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10FA220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1101C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowRestoration {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1105020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__CoreML_MLCustomModel {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1151420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithModelDescription:(MLModelDescription *)p0 parameterDictionary:(NSDictionary <NSString *, NSObject *>*)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_37 (self, _cmd, &managed_method, p0, p1, p2, &call_super, 0x1151720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, MLModelDescription *, NSDictionary <NSString *, NSObject *>*, NSError **)) objc_msgSendSuper) (&super, @selector (initWithModelDescription:parameterDictionary:error:), p0, p1, p2);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBCentralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1218E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1220120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1223C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1227620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPictureInPictureControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1229520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__AVKit_AVPlayerViewPictureInPictureDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122CC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVRoutePickerViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122EB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation AVFoundation_AVCaptureDataOutputSynchronizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation AVFoundation_AVCaptureDataOutputSynchronizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1243820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureAudioDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x124C020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioPlayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A0C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AVFoundation_InternalAVAudioPlayerDelegate : NSObject<AVAudioPlayerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1;
	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioPlayerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x1261820);
	}

	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, p1, 0x1261920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1261720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioRecorderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A4620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface AVFoundation_InternalAVAudioRecorderDelegate : NSObject<AVAudioRecorderDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1;
	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioRecorderDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_40 (self, _cmd, &managed_method, p0, p1, 0x1261B20);
	}

	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x1261C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1261A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAssetResourceLoaderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1278A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAsynchronousKeyValueLoading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1286920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudio3DMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1289920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioStereoMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AA320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12C4C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputRecordingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12C5820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCapturePhotoCaptureDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12C8E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureVideoDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12D5D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVContentKeySessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12DE120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x132A520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemLegibleOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1326520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataCollectorPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1327A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1328D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPullDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1329E20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVSpeechSynthesizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x133CE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVVideoCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1347220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__AuthenticationServices_ASAuthorizationControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1356420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__AuthenticationServices_ASWebAuthenticationSessionRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x135FD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFileManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13C0A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface Foundation_InternalNSNotificationHandler : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) post:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_InternalNSNotificationHandler {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) post:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x13FA020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation Foundation_NSUrlProtocolClient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Foundation_NSDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1467820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1467720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSActionDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1467B20);
	}
@end

@interface __MonoMac_NSSynchronizationContextDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1467D20);
	}
@end

@interface __Xamarin_NSTimerActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinFireSelector:(NSTimer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __Xamarin_NSTimerActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinFireSelector:(NSTimer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, 0x1467F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Foundation_NSAsyncDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
	-(id) init;
@end

@implementation Foundation_NSAsyncDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1468220);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1468120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Foundation_NSDispatcher class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAsyncActionDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1468420);
	}
@end

@interface __MonoMac_NSAsyncSynchronizationContextDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1468620);
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCacheDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1496420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCoding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x149B520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x149B820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x149FC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14A0820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSExtensionRequestHandling {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14B4720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFilePresenter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14BBE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedArchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14C6220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedUnarchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14C7020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1503220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMachPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14D3120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMetadataQueryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14E6120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMutableCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14E8C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14EE420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14EF820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x150EE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLAuthenticationChallengeSender {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x151C820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1520620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x151F520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1521420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUrlDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1523C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1531D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1537B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1530C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1532820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1533A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__Foundation_NSUrlSessionWebSocketDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x153BF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserActivityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x153F120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1545520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate : NSObject<NCWidgetListViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1;
	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2;
	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1;
	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_45 (self, _cmd, &managed_method, p0, p1, 0x155B420);
	}

	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, p2, 0x155B520);
	}

	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_47 (self, _cmd, &managed_method, p0, p1, 0x155B620);
	}

	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, 0x155B720);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x155B820);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x155B920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155B320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate : NSObject<NCWidgetSearchViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2;
	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_50 (self, _cmd, &managed_method, p0, p1, 0x155BB20);
	}

	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_51 (self, _cmd, &managed_method, p0, p1, p2, 0x155BC20);
	}

	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_52 (self, _cmd, &managed_method, p0, 0x155BD20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155BA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ExternalAccessory_EAAccessory__EAAccessoryDelegate : NSObject<EAAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) accessoryDidDisconnect:(EAAccessory *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAAccessory__EAAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) accessoryDidDisconnect:(EAAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_53 (self, _cmd, &managed_method, p0, 0x155C320);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155C220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate : NSObject<IKCameraDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didDownloadFile:(ICCameraFile *)p1 location:(NSURL *)p2 fileData:(NSData *)p3 error:(NSError *)p4;
	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didDownloadFile:(ICCameraFile *)p1 location:(NSURL *)p2 fileData:(NSData *)p3 error:(NSError *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x155D320);
	}

	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_55 (self, _cmd, &managed_method, p0, p1, 0x155D420);
	}

	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, 0x155D520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155D220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate : NSObject<IKDeviceBrowserViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1;
	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 selectionDidChange:(ICDevice *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, 0x155D720);
	}

	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 selectionDidChange:(ICDevice *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, 0x155D820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155D620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKImageBrowserView__IKImageBrowserDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2;
	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKImageBrowserView__IKImageBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, 0x155E020);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_60 (self, _cmd, &managed_method, p0, p1, 0x155E120);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, p2, 0x155E220);
	}

	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_62 (self, _cmd, &managed_method, p0, 0x155E320);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155DF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKSaveOptions__IKSaveOptionsDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKSaveOptions__IKSaveOptionsDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_63 (self, _cmd, &managed_method, p0, p1, 0x155E520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155E420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate : NSObject<IKScannerDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToBandData:(ICScannerBandData *)p1 scanInfo:(NSDictionary *)p2 error:(NSError *)p3;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_64 (self, _cmd, &managed_method, p0, p1, 0x155E720);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x155E820);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToBandData:(ICScannerBandData *)p1 scanInfo:(NSDictionary *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_66 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x155E920);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, p2, 0x155EA20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x155E620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKRequest__SKRequestDelegate : NSObject<SKRequestDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1;
	-(void) requestDidFinish:(SKRequest *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKRequest__SKRequestDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_68 (self, _cmd, &managed_method, p0, p1, 0x166FA20);
	}

	-(void) requestDidFinish:(SKRequest *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, 0x166FB20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x166F920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKProductsRequest__SKProductsRequestDelegate : StoreKit_SKRequest__SKRequestDelegate<SKProductsRequestDelegate, SKRequestDelegate> {
}
	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1;
	-(id) init;
@end

@implementation StoreKit_SKProductsRequest__SKProductsRequestDelegate {
}

	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_70 (self, _cmd, &managed_method, p0, p1, 0x166F820);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x166F720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [StoreKit_SKRequest__SKRequestDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ScriptingBridge_SBApplication__SBApplicationDelegate : NSObject<SBApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ScriptingBridge_SBApplication__SBApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, 0x1672820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1672720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfView__PdfViewDelegate : NSObject<PDFViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1;
	-(void) PDFViewPerformFind:(PDFView *)p0;
	-(void) PDFViewPerformGoToPage:(PDFView *)p0;
	-(void) PDFViewPerformPrint:(PDFView *)p0;
	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0;
	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1;
	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfView__PdfViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, p1, 0x1678620);
	}

	-(void) PDFViewPerformFind:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, 0x1678720);
	}

	-(void) PDFViewPerformGoToPage:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, 0x1678820);
	}

	-(void) PDFViewPerformPrint:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, 0x1678920);
	}

	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, 0x1678A20);
	}

	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_75 (self, _cmd, &managed_method, p0, p1, 0x1678B20);
	}

	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x1678C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1678520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfDocument__PdfDocumentDelegate : NSObject<PDFDocumentDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) classForAnnotationClass:(Class)p0;
	-(void) documentDidBeginDocumentFind:(NSNotification *)p0;
	-(void) didMatchString:(PDFSelection *)p0;
	-(void) documentDidUnlock:(NSNotification *)p0;
	-(void) documentDidEndDocumentFind:(NSNotification *)p0;
	-(Class) classForAnnotationType:(NSString *)p0;
	-(void) documentDidFindMatch:(NSNotification *)p0;
	-(void) documentDidEndPageFind:(NSNotification *)p0;
	-(void) documentDidBeginPageFind:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfDocument__PdfDocumentDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) classForAnnotationClass:(Class)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, 0x167A620);
	}

	-(void) documentDidBeginDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167A720);
	}

	-(void) didMatchString:(PDFSelection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, 0x167A820);
	}

	-(void) documentDidUnlock:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167A920);
	}

	-(void) documentDidEndDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167AA20);
	}

	-(Class) classForAnnotationType:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, 0x167AB20);
	}

	-(void) documentDidFindMatch:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167AC20);
	}

	-(void) documentDidEndPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167AD20);
	}

	-(void) documentDidBeginPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x167AE20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x167A520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MapKit_MKMapView__MKMapViewDelegate : NSObject<MKMapViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3;
	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1;
	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1;
	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1;
	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1;
	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1;
	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0;
	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1;
	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1;
	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0;
	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0;
	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MapKit_MKMapView__MKMapViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1688820);
	}

	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x1688920);
	}

	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, 0x1688A20);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, 0x1688B20);
	}

	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1688C20);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, 0x1688D20);
	}

	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, 0x1688E20);
	}

	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x1688F20);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, 0x1689020);
	}

	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1689120);
	}

	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, p1, 0x1689220);
	}

	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, 0x1689320);
	}

	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, 0x1689420);
	}

	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1689520);
	}

	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x1689620);
	}

	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x1689720);
	}

	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x1689820);
	}

	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1689920);
	}

	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1689A20);
	}

	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x1689B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1688720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreLocation_CLLocationManager__CLLocationManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1;
	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreLocation_CLLocationManager__CLLocationManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x1690D20);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x1690E20);
	}

	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, p1, p2, 0x1690F20);
	}

	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, 0x1691020);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x1691120);
	}

	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, 0x1691220);
	}

	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, 0x1691320);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, p1, 0x1691420);
	}

	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, p1, p2, 0x1691520);
	}

	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, 0x1691620);
	}

	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, 0x1691720);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_97 (self, _cmd, &managed_method, p0, 0x1691820);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, p1, p2, 0x1691920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1690C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreAnimation_CAAnimation__CAAnimationDelegate : NSObject<CAAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidStart:(CAAnimation *)p0;
	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreAnimation_CAAnimation__CAAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidStart:(CAAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_99 (self, _cmd, &managed_method, p0, 0x1696420);
	}

	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, p1, 0x1696520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1696320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate : NSObject<SKPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) didBeginContact:(SKPhysicsContact *)p0;
	-(void) didEndContact:(SKPhysicsContact *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) didBeginContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, 0x169ED20);
	}

	-(void) didEndContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, 0x169EE20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x169EC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate : NSObject<SCNPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x16A0E20);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x16A0F20);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x16A1020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16A0D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatch__GKMatchDelegate : NSObject<GKMatchDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2;
	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1;
	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2;
	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatch__GKMatchDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, p1, p2, 0x16AF020);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, p2, 0x16AF120);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_105 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16AF220);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, p1, p2, 0x16AF320);
	}

	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, p1, 0x16AF420);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, p1, 0x16AF520);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, p1, 0x16AF620);
	}

	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, p1, p2, 0x16AF720);
	}

	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, p2, 0x16AF820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16AEF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate : NSObject<GKGameCenterControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, 0x16B4620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B4520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKAchievementViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate {
}

	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, 0x16B3A20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B3920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate : NSObject<GKChallengeEventHandlerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0;
	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x16B3C20);
	}

	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x16B3D20);
	}

	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x16B3E20);
	}

	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, 0x16B3F20);
	}

	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0x16B4020);
	}

	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0x16B4120);
	}

	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, 0x16B4220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B3B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate : NSObject<GKFriendRequestComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, 0x16B4420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B4320);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKLeaderboardViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate {
}

	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, 0x16B5620);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B5520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate : NSObject<GKMatchmakerViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1;
	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_118 (self, _cmd, &managed_method, p0, p1, 0x16B6E20);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, p1, 0x16B6F20);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x16B7020);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, p1, 0x16B7120);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, 0x16B7220);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_123 (self, _cmd, &managed_method, p0, p1, 0x16B7320);
	}

	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_124 (self, _cmd, &managed_method, p0, 0x16B7420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16B6D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, 0x16BB820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy2 : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy2 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, 0x16BBA20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface WebKit_WebView__WebFrameLoadDelegate : NSObject<WebFrameLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4;
	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebFrameLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BBC20);
	}

	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BBD20);
	}

	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, p1, p2, 0x16BBE20);
	}

	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BBF20);
	}

	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_128 (self, _cmd, &managed_method, p0, p1, p2, 0x16BC020);
	}

	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, p2, 0x16BC120);
	}

	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, p2, 0x16BC220);
	}

	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BC320);
	}

	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x16BC420);
	}

	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BC520);
	}

	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, p2, 0x16BC620);
	}

	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BC720);
	}

	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x16BC820);
	}

	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16BC920);
	}

	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_133 (self, _cmd, &managed_method, p0, p1, 0x16BCA20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16BBB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebDownloadDelegate : NSObject<WebDownloadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebDownloadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_134 (self, _cmd, &managed_method, p0, 0x16BCC20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16BCB20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebResourceLoadDelegate : NSObject<WebResourceLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2;
	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3;
	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebResourceLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BCE20);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BCF20);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, p2, 0x16BD020);
	}

	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x16BD120);
	}

	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, 0x16BD220);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BD320);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BD420);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BD520);
	}

	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_142 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16BD620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16BCD20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0;
	-(void) webViewClose:(WebView *)p0;
	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1;
	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1;
	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1;
	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1;
	-(void) webViewFocus:(WebView *)p0;
	-(CGRect) webViewContentRect:(WebView *)p0;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1;
	-(NSResponder *) webViewFirstResponder:(WebView *)p0;
	-(float) webViewFooterHeight:(WebView *)p0;
	-(CGRect) webViewFrame:(WebView *)p0;
	-(float) webViewHeaderHeight:(WebView *)p0;
	-(NSString *) webViewStatusText:(WebView *)p0;
	-(BOOL) webViewIsResizable:(WebView *)p0;
	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0;
	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1;
	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2;
	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1;
	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3;
	-(void) webViewRunModal:(WebView *)p0;
	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1;
	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1;
	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1;
	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1;
	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2;
	-(void) webViewShow:(WebView *)p0;
	-(void) webViewUnfocus:(WebView *)p0;
	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2;
	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2;
	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, 0x16BD820);
	}

	-(void) webViewClose:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x16BD920);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, 0x16BDA20);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, 0x16BDB20);
	}

	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x16BDC20);
	}

	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, p1, 0x16BDD20);
	}

	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, p1, 0x16BDE20);
	}

	-(void) webViewFocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x16BDF20);
	}

	-(CGRect) webViewContentRect:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, 0x16BE020);
	}

	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, p1, p2, 0x16BE120);
	}

	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, 0x16BE220);
	}

	-(NSResponder *) webViewFirstResponder:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, 0x16BE320);
	}

	-(float) webViewFooterHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, 0x16BE420);
	}

	-(CGRect) webViewFrame:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, 0x16BE520);
	}

	-(float) webViewHeaderHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, 0x16BE620);
	}

	-(NSString *) webViewStatusText:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_153 (self, _cmd, &managed_method, p0, 0x16BE720);
	}

	-(BOOL) webViewIsResizable:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, 0x16BE820);
	}

	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, 0x16BE920);
	}

	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, p1, 0x16BEA20);
	}

	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_155 (self, _cmd, &managed_method, p0, p1, p2, 0x16BEB20);
	}

	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, p1, 0x16BEC20);
	}

	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, p2, 0x16BED20);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, 0x16BEE20);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, p2, 0x16BEF20);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, 0x16BF020);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, p2, 0x16BF120);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_160 (self, _cmd, &managed_method, p0, p1, p2, 0x16BF220);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_161 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16BF320);
	}

	-(void) webViewRunModal:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x16BF420);
	}

	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_162 (self, _cmd, &managed_method, p0, p1, 0x16BF520);
	}

	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, p1, 0x16BF620);
	}

	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, p1, 0x16BF720);
	}

	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, 0x16BF820);
	}

	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, 0x16BF920);
	}

	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, 0x16BFA20);
	}

	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, 0x16BFB20);
	}

	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, p1, p2, 0x16BFC20);
	}

	-(void) webViewShow:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x16BFD20);
	}

	-(void) webViewUnfocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, 0x16BFE20);
	}

	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, p1, p2, 0x16BFF20);
	}

	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_166 (self, _cmd, &managed_method, p0, p1, p2, 0x16C0020);
	}

	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_167 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16C0120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16BD720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebPolicyDelegate : NSObject<WebPolicyDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebPolicyDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16C0320);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_169 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16C0420);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16C0520);
	}

	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, p2, 0x16C0620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16C0220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSApplication__NSApplicationDelegate : NSObject<NSApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSMenu *) applicationDockMenu:(NSApplication *)p0;
	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0;
	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1;
	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0;
	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0;
	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0;
	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2;
	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) applicationDidBecomeActive:(NSNotification *)p0;
	-(void) applicationDidFinishLaunching:(NSNotification *)p0;
	-(void) applicationDidHide:(NSNotification *)p0;
	-(void) applicationDidResignActive:(NSNotification *)p0;
	-(void) applicationDidUnhide:(NSNotification *)p0;
	-(void) applicationDidUpdate:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2;
	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1;
	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1;
	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1;
	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1;
	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1;
	-(void) orderFrontStandardAboutPanel:(NSObject *)p0;
	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0;
	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1;
	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3;
	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0;
	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1;
	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1;
	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1;
	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1;
	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1;
	-(void) applicationWillBecomeActive:(NSNotification *)p0;
	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1;
	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) applicationWillFinishLaunching:(NSNotification *)p0;
	-(void) applicationWillHide:(NSNotification *)p0;
	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1;
	-(void) applicationWillResignActive:(NSNotification *)p0;
	-(void) applicationWillTerminate:(NSNotification *)p0;
	-(void) applicationWillUnhide:(NSNotification *)p0;
	-(void) applicationWillUpdate:(NSNotification *)p0;
	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSApplication__NSApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSMenu *) applicationDockMenu:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, 0x16C1E20);
	}

	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x16C1F20);
	}

	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, 0x16C2020);
	}

	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x16C2120);
	}

	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, 0x16C2220);
	}

	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x16C2320);
	}

	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, p2, 0x16C2420);
	}

	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x16C2520);
	}

	-(void) applicationDidBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2620);
	}

	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2720);
	}

	-(void) applicationDidHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2820);
	}

	-(void) applicationDidResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2920);
	}

	-(void) applicationDidUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2A20);
	}

	-(void) applicationDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C2B20);
	}

	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, p2, 0x16C2C20);
	}

	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, 0x16C2D20);
	}

	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x16C2E20);
	}

	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x16C2F20);
	}

	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, p1, 0x16C3020);
	}

	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_181 (self, _cmd, &managed_method, p0, p1, 0x16C3120);
	}

	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x16C3220);
	}

	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_182 (self, _cmd, &managed_method, p0, p1, 0x16C3320);
	}

	-(void) orderFrontStandardAboutPanel:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x16C3420);
	}

	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, 0x16C3520);
	}

	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x16C3620);
	}

	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_184 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16C3720);
	}

	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, 0x16C3820);
	}

	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x16C3920);
	}

	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, 0x16C3A20);
	}

	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, p1, 0x16C3B20);
	}

	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C3C20);
	}

	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, p1, 0x16C3D20);
	}

	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_190 (self, _cmd, &managed_method, p0, p1, 0x16C3E20);
	}

	-(void) applicationWillBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C3F20);
	}

	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x16C4020);
	}

	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x16C4120);
	}

	-(void) applicationWillFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4220);
	}

	-(void) applicationWillHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4320);
	}

	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, p1, 0x16C4420);
	}

	-(void) applicationWillResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4520);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4620);
	}

	-(void) applicationWillUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4720);
	}

	-(void) applicationWillUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16C4820);
	}

	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_192 (self, _cmd, &managed_method, p0, p1, 0x16C4920);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, 0x16C4A20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16C1D20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSMatrix__NSMatrixDelegate : NSObject<NSMatrixDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSMatrix__NSMatrixDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16CAE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPathCell__NSPathCellDelegate : NSObject<NSPathCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1;
	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPathCell__NSPathCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, 0x16CB020);
	}

	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, p1, 0x16CB120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16CAF20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTableView__NSTableViewDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewColumnDidMove:(NSNotification *)p0;
	-(void) tableViewColumnDidResize:(NSNotification *)p0;
	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1;
	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1;
	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(void) tableViewSelectionIsChanging:(NSNotification *)p0;
	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0;
	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2;
	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTableView__NSTableViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewColumnDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16CB320);
	}

	-(void) tableViewColumnDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16CB420);
	}

	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, 0x16CB520);
	}

	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, p2, 0x16CB620);
	}

	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, 0x16CB720);
	}

	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, 0x16CB820);
	}

	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, p2, 0x16CB920);
	}

	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_199 (self, _cmd, &managed_method, p0, p1, p2, 0x16CBA20);
	}

	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_200 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16CBB20);
	}

	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x16CBC20);
	}

	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0x16CBD20);
	}

	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, 0x16CBE20);
	}

	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x16CBF20);
	}

	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x16CC020);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, p2, 0x16CC120);
	}

	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x16CC220);
	}

	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, 0x16CC320);
	}

	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, p2, 0x16CC420);
	}

	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16CC520);
	}

	-(void) tableViewSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16CC620);
	}

	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_208 (self, _cmd, &managed_method, p0, 0x16CC720);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, p2, 0x16CC820);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, p1, p2, 0x16CC920);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x16CCA20);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_211 (self, _cmd, &managed_method, p0, p1, 0x16CCB20);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, p2, 0x16CCC20);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_212 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16CCD20);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, p2, 0x16CCE20);
	}

	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_214 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16CCF20);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, 0x16CD020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16CB220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSAlert__NSAlertDelegate : NSObject<NSAlertDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) alertShowHelp:(NSAlert *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAlert__NSAlertDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) alertShowHelp:(NSAlert *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_215 (self, _cmd, &managed_method, p0, 0x16CDB20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16CDA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextField__NSTextFieldDelegate : NSObject<NSTextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2;
	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3;
	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1;
	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2;
	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1;
	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextField__NSTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E2A20);
	}

	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, p1, p2, 0x16E2B20);
	}

	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_217 (self, _cmd, &managed_method, p0, p1, p2, 0x16E2C20);
	}

	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_218 (self, _cmd, &managed_method, p0, p1, p2, 0x16E2D20);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E2E20);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E2F20);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_219 (self, _cmd, &managed_method, p0, p1, p2, 0x16E3020);
	}

	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_220 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x16E3120);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_221 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16E3220);
	}

	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_222 (self, _cmd, &managed_method, p0, p1, 0x16E3320);
	}

	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_223 (self, _cmd, &managed_method, p0, p1, p2, 0x16E3420);
	}

	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, p1, 0x16E3520);
	}

	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, p1, 0x16E3620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16E2920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSComboBox__NSComboBoxDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSComboBoxDelegate, NSTextFieldDelegate> {
}
	-(void) comboBoxSelectionDidChange:(NSNotification *)p0;
	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0;
	-(void) comboBoxWillDismiss:(NSNotification *)p0;
	-(void) comboBoxWillPopUp:(NSNotification *)p0;
	-(id) init;
@end

@implementation AppKit_NSComboBox__NSComboBoxDelegate {
}

	-(void) comboBoxSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16D2920);
	}

	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16D2A20);
	}

	-(void) comboBoxWillDismiss:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16D2B20);
	}

	-(void) comboBoxWillPopUp:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16D2C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16D2820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSDocumentDuplicateCallback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __NSDocumentDuplicateCallback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, p1, p2, 0x16D4020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation __NSGestureRecognizerToken {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16D8F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerParameterlessToken {
}

	-(void) target
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x16D9120);
	}
@end

@implementation __NSGestureRecognizerParametrizedToken {
}

	-(void) target:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_226 (self, _cmd, &managed_method, p0, 0x16D9320);
	}
@end

@interface AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate : NSObject<NSGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0;
	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, p1, 0x16D9520);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, 0x16D9620);
	}

	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_229 (self, _cmd, &managed_method, p0, 0x16D9720);
	}

	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, p1, 0x16D9820);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_230 (self, _cmd, &managed_method, p0, p1, 0x16D9920);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, 0x16D9A20);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, 0x16D9B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16D9420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSClickGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSClickGestureRecognizer *)p0;
@end

@implementation __NSClickGestureRecognizer {
}

	-(void) target:(NSClickGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_231 (self, _cmd, &managed_method, p0, 0x16D9D20);
	}
@end

@interface __NSMagnificationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSMagnificationGestureRecognizer *)p0;
@end

@implementation __NSMagnificationGestureRecognizer {
}

	-(void) target:(NSMagnificationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_232 (self, _cmd, &managed_method, p0, 0x16D9F20);
	}
@end

@interface __NSPanGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPanGestureRecognizer *)p0;
@end

@implementation __NSPanGestureRecognizer {
}

	-(void) target:(NSPanGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_233 (self, _cmd, &managed_method, p0, 0x16DA120);
	}
@end

@interface __NSPressGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPressGestureRecognizer *)p0;
@end

@implementation __NSPressGestureRecognizer {
}

	-(void) target:(NSPressGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, 0x16DA320);
	}
@end

@interface __NSRotationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSRotationGestureRecognizer *)p0;
@end

@implementation __NSRotationGestureRecognizer {
}

	-(void) target:(NSRotationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_235 (self, _cmd, &managed_method, p0, 0x16DA520);
	}
@end

@interface AppKit_NSImage__NSImageDelegate : NSObject<NSImageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1;
	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1;
	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSImage__NSImageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_236 (self, _cmd, &managed_method, p0, p1, p2, 0x16DAA20);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_237 (self, _cmd, &managed_method, p0, p1, p2, 0x16DAB20);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, p1, 0x16DAC20);
	}

	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_239 (self, _cmd, &managed_method, p0, p1, 0x16DAD20);
	}

	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, p1, 0x16DAE20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16DA920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingService__NSSharingServiceDelegate : NSObject<NSSharingServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2;
	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2;
	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1;
	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1;
	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2;
	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2;
	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingService__NSSharingServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, p1, p2, 0x16E0220);
	}

	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_241 (self, _cmd, &managed_method, p0, p1, p2, 0x16E0320);
	}

	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_242 (self, _cmd, &managed_method, p0, p1, 0x16E0420);
	}

	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, 0x16E0520);
	}

	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, p1, p2, 0x16E0620);
	}

	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_245 (self, _cmd, &managed_method, p0, p1, p2, 0x16E0720);
	}

	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_242 (self, _cmd, &managed_method, p0, p1, 0x16E0820);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16E0120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSound__NSSoundDelegate : NSObject<NSSoundDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSound__NSSoundDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_246 (self, _cmd, &managed_method, p0, p1, 0x16E0A20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16E0920);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextStorage__NSTextStorageDelegate : NSObject<NSTextStorageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(void) textStorageDidProcessEditing:(NSNotification *)p0;
	-(void) textStorageWillProcessEditing:(NSNotification *)p0;
	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextStorage__NSTextStorageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16E3820);
	}

	-(void) textStorageDidProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E3920);
	}

	-(void) textStorageWillProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E3A20);
	}

	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16E3B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16E3720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSWindow__NSWindowDelegate : NSObject<NSWindowDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0;
	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0;
	-(void) windowDidBecomeKey:(NSNotification *)p0;
	-(void) windowDidBecomeMain:(NSNotification *)p0;
	-(void) windowDidChangeBackingProperties:(NSNotification *)p0;
	-(void) windowDidChangeScreen:(NSNotification *)p0;
	-(void) windowDidChangeScreenProfile:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) windowDidDeminiaturize:(NSNotification *)p0;
	-(void) windowDidEndLiveResize:(NSNotification *)p0;
	-(void) windowDidEndSheet:(NSNotification *)p0;
	-(void) windowDidEnterFullScreen:(NSNotification *)p0;
	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExitFullScreen:(NSNotification *)p0;
	-(void) windowDidExitVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExpose:(NSNotification *)p0;
	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0;
	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0;
	-(void) windowDidMiniaturize:(NSNotification *)p0;
	-(void) windowDidMove:(NSNotification *)p0;
	-(void) windowDidResignKey:(NSNotification *)p0;
	-(void) windowDidResignMain:(NSNotification *)p0;
	-(void) windowDidResize:(NSNotification *)p0;
	-(void) windowDidUpdate:(NSNotification *)p0;
	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1;
	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1;
	-(void) windowWillBeginSheet:(NSNotification *)p0;
	-(void) windowWillClose:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) windowWillEnterFullScreen:(NSNotification *)p0;
	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowWillExitFullScreen:(NSNotification *)p0;
	-(void) windowWillExitVersionBrowser:(NSNotification *)p0;
	-(void) windowWillMiniaturize:(NSNotification *)p0;
	-(void) windowWillMove:(NSNotification *)p0;
	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2;
	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1;
	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2;
	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1;
	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0;
	-(void) windowWillStartLiveResize:(NSNotification *)p0;
	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1;
	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1;
	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1;
	-(BOOL) windowShouldClose:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSWindow__NSWindowDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_248 (self, _cmd, &managed_method, p0, 0x16E4120);
	}

	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_248 (self, _cmd, &managed_method, p0, 0x16E4220);
	}

	-(void) windowDidBecomeKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4320);
	}

	-(void) windowDidBecomeMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4420);
	}

	-(void) windowDidChangeBackingProperties:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4520);
	}

	-(void) windowDidChangeScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4620);
	}

	-(void) windowDidChangeScreenProfile:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4720);
	}

	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_249 (self, _cmd, &managed_method, p0, p1, 0x16E4820);
	}

	-(void) windowDidDeminiaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4920);
	}

	-(void) windowDidEndLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4A20);
	}

	-(void) windowDidEndSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4B20);
	}

	-(void) windowDidEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4C20);
	}

	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4D20);
	}

	-(void) windowDidExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4E20);
	}

	-(void) windowDidExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E4F20);
	}

	-(void) windowDidExpose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5020);
	}

	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_250 (self, _cmd, &managed_method, p0, 0x16E5120);
	}

	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_250 (self, _cmd, &managed_method, p0, 0x16E5220);
	}

	-(void) windowDidMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5320);
	}

	-(void) windowDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5420);
	}

	-(void) windowDidResignKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5520);
	}

	-(void) windowDidResignMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5620);
	}

	-(void) windowDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5720);
	}

	-(void) windowDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5820);
	}

	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_251 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x16E5920);
	}

	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, p1, 0x16E5A20);
	}

	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x16E5B20);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_254 (self, _cmd, &managed_method, p0, p1, 0x16E5C20);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_254 (self, _cmd, &managed_method, p0, p1, 0x16E5D20);
	}

	-(void) windowWillBeginSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5E20);
	}

	-(void) windowWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E5F20);
	}

	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_249 (self, _cmd, &managed_method, p0, p1, 0x16E6020);
	}

	-(void) windowWillEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6120);
	}

	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6220);
	}

	-(void) windowWillExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6320);
	}

	-(void) windowWillExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6420);
	}

	-(void) windowWillMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6520);
	}

	-(void) windowWillMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6620);
	}

	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_255 (self, _cmd, &managed_method, p0, p1, p2, 0x16E6720);
	}

	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x16E6820);
	}

	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_257 (self, _cmd, &managed_method, p0, p1, p2, 0x16E6920);
	}

	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_258 (self, _cmd, &managed_method, p0, p1, 0x16E6A20);
	}

	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_259 (self, _cmd, &managed_method, p0, 0x16E6B20);
	}

	-(void) windowWillStartLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16E6C20);
	}

	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x16E6D20);
	}

	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, 0x16E6E20);
	}

	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, 0x16E6F20);
	}

	-(BOOL) windowShouldClose:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_262 (self, _cmd, &managed_method, p0, 0x16E7020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16E4020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSAnimation__NSAnimationDelegate : NSObject<NSAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidEnd:(NSAnimation *)p0;
	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1;
	-(void) animationDidStop:(NSAnimation *)p0;
	-(BOOL) animationShouldStart:(NSAnimation *)p0;
	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAnimation__NSAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidEnd:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_263 (self, _cmd, &managed_method, p0, 0x16FB120);
	}

	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, p1, 0x16FB220);
	}

	-(void) animationDidStop:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_263 (self, _cmd, &managed_method, p0, 0x16FB320);
	}

	-(BOOL) animationShouldStart:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_265 (self, _cmd, &managed_method, p0, 0x16FB420);
	}

	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_266 (self, _cmd, &managed_method, p0, p1, 0x16FB520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16FB020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePicker__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePicker__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_267 (self, _cmd, &managed_method, p0, p1, p2, 0x16FBB20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16FBA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePickerCell__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePickerCell__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_267 (self, _cmd, &managed_method, p0, p1, p2, 0x16FBD20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16FBC20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDrawer__NSDrawerDelegate : NSObject<NSDrawerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawerDidClose:(NSNotification *)p0;
	-(void) drawerDidOpen:(NSNotification *)p0;
	-(BOOL) drawerShouldClose:(NSDrawer *)p0;
	-(BOOL) drawerShouldOpen:(NSDrawer *)p0;
	-(void) drawerWillClose:(NSNotification *)p0;
	-(void) drawerWillOpen:(NSNotification *)p0;
	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDrawer__NSDrawerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawerDidClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16FBF20);
	}

	-(void) drawerDidOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16FC020);
	}

	-(BOOL) drawerShouldClose:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, 0x16FC120);
	}

	-(BOOL) drawerShouldOpen:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, 0x16FC220);
	}

	-(void) drawerWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16FC320);
	}

	-(void) drawerWillOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x16FC420);
	}

	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_269 (self, _cmd, &managed_method, p0, p1, 0x16FC520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16FBE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPageController__NSPageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0;
	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1;
	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2;
	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPageController__NSPageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, 0x1707720);
	}

	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_271 (self, _cmd, &managed_method, p0, p1, 0x1707820);
	}

	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_272 (self, _cmd, &managed_method, p0, p1, 0x1707920);
	}

	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, p1, 0x1707A20);
	}

	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, 0x1707B20);
	}

	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, 0x1707C20);
	}

	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, 0x1707D20);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, 0x1707E20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1707620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSRuleEditor__NSRuleEditorDelegate : NSObject<NSRuleEditorDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2;
	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3;
	-(void) ruleEditorRowsDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSRuleEditor__NSRuleEditorDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x170CB20);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x170CC20);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_277 (self, _cmd, &managed_method, p0, p1, p2, 0x170CD20);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x170CE20);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x170CF20);
	}

	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_278 (self, _cmd, &managed_method, p0, p1, p2, 0x170D020);
	}

	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x170D120);
	}

	-(void) ruleEditorRowsDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x170D220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x170CA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSavePanel__NSOpenSavePanelDelegate : NSObject<NSOpenSavePanelDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3;
	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1;
	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1;
	-(void) panelSelectionDidChange:(NSSavePanel *)p0;
	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1;
	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2;
	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2;
	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSavePanel__NSOpenSavePanelDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_280 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x170D620);
	}

	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_281 (self, _cmd, &managed_method, p0, p1, 0x170D720);
	}

	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_282 (self, _cmd, &managed_method, p0, p1, 0x170D820);
	}

	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_283 (self, _cmd, &managed_method, p0, p1, 0x170D920);
	}

	-(void) panelSelectionDidChange:(NSSavePanel *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_284 (self, _cmd, &managed_method, p0, 0x170DA20);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_285 (self, _cmd, &managed_method, p0, p1, 0x170DB20);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_283 (self, _cmd, &managed_method, p0, p1, 0x170DC20);
	}

	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_286 (self, _cmd, &managed_method, p0, p1, p2, 0x170DD20);
	}

	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_287 (self, _cmd, &managed_method, p0, p1, p2, 0x170DE20);
	}

	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_288 (self, _cmd, &managed_method, p0, p1, 0x170DF20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x170D520);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSearchField__NSSearchFieldDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSSearchFieldDelegate, NSTextFieldDelegate> {
}
	-(void) searchFieldDidEndSearching:(NSSearchField *)p0;
	-(void) searchFieldDidStartSearching:(NSSearchField *)p0;
	-(id) init;
@end

@implementation AppKit_NSSearchField__NSSearchFieldDelegate {
}

	-(void) searchFieldDidEndSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_289 (self, _cmd, &managed_method, p0, 0x170EB20);
	}

	-(void) searchFieldDidStartSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_289 (self, _cmd, &managed_method, p0, 0x170EC20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x170EA20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate : NSObject<NSSharingServicePickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1;
	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1;
	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_290 (self, _cmd, &managed_method, p0, p1, 0x170EE20);
	}

	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_291 (self, _cmd, &managed_method, p0, p1, 0x170EF20);
	}

	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_292 (self, _cmd, &managed_method, p0, p1, p2, 0x170F020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x170ED20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTabView__NSTabViewDelegate : NSObject<NSTabViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0;
	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTabView__NSTabViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_293 (self, _cmd, &managed_method, p0, p1, 0x1713820);
	}

	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_294 (self, _cmd, &managed_method, p0, 0x1713920);
	}

	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_295 (self, _cmd, &managed_method, p0, p1, 0x1713A20);
	}

	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_293 (self, _cmd, &managed_method, p0, p1, 0x1713B20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1713720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSText__NSTextDelegate : NSObject<NSTextDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidBeginEditing:(NSNotification *)p0;
	-(void) textDidChange:(NSNotification *)p0;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(BOOL) textShouldBeginEditing:(NSText *)p0;
	-(BOOL) textShouldEndEditing:(NSText *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSText__NSTextDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1713D20);
	}

	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1713E20);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1713F20);
	}

	-(BOOL) textShouldBeginEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_296 (self, _cmd, &managed_method, p0, 0x1714020);
	}

	-(BOOL) textShouldEndEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_296 (self, _cmd, &managed_method, p0, 0x1714120);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1713C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextView__NSTextViewDelegate : AppKit_NSText__NSTextDelegate<NSTextViewDelegate, NSTextDelegate> {
}
	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textViewDidChangeSelection:(NSNotification *)p0;
	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0;
	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6;
	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1;
	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1;
	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2;
	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0;
	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2;
	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1;
	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1;
	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3;
	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(id) init;
@end

@implementation AppKit_NSTextView__NSTextViewDelegate {
}

	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715020);
	}

	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715120);
	}

	-(void) textViewDidChangeSelection:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1715220);
	}

	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1715320);
	}

	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_298 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, p6, 0x1715420);
	}

	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_299 (self, _cmd, &managed_method, p0, p1, 0x1715520);
	}

	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715620);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0x1715720);
	}

	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715820);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_303 (self, _cmd, &managed_method, p0, p1, p2, 0x1715920);
	}

	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_304 (self, _cmd, &managed_method, p0, 0x1715A20);
	}

	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_305 (self, _cmd, &managed_method, p0, p1, p2, 0x1715B20);
	}

	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, p1, p2, 0x1715C20);
	}

	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_307 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1715D20);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, p2, 0x1715E20);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_309 (self, _cmd, &managed_method, p0, p1, p2, 0x1715F20);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_310 (self, _cmd, &managed_method, p0, p1, p2, 0x1716020);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_311 (self, _cmd, &managed_method, p0, p1, 0x1716120);
	}

	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_312 (self, _cmd, &managed_method, p0, p1, p2, 0x1716220);
	}

	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_313 (self, _cmd, &managed_method, p0, p1, 0x1716320);
	}

	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_314 (self, _cmd, &managed_method, p0, p1, p2, 0x1716420);
	}

	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_315 (self, _cmd, &managed_method, p0, p1, p2, 0x1716520);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_316 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1716620);
	}

	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_317 (self, _cmd, &managed_method, p0, p1, p2, 0x1716720);
	}

	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_318 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1716820);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, 0x1716920);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1714F20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSText__NSTextDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSToolbar__NSToolbarDelegate : NSObject<NSToolbarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0;
	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarDidRemoveItem:(NSNotification *)p0;
	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarWillAddItem:(NSNotification *)p0;
	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSToolbar__NSToolbarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, 0x1717220);
	}

	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, 0x1717320);
	}

	-(void) toolbarDidRemoveItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1717420);
	}

	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, 0x1717520);
	}

	-(void) toolbarWillAddItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x1717620);
	}

	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_320 (self, _cmd, &managed_method, p0, p1, p2, 0x1717720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1717120);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTouchBar__NSTouchBarDelegate : NSObject<NSTouchBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTouchBar__NSTouchBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0x1717D20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1717C20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBCentralManager__CBCentralManagerDelegate : NSObject<CBCentralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3;
	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1;
	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0;
	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBCentralManager__CBCentralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_322 (self, _cmd, &managed_method, p0, p1, 0x172CF20);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_323 (self, _cmd, &managed_method, p0, p1, p2, 0x172D020);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x172D120);
	}

	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_323 (self, _cmd, &managed_method, p0, p1, p2, 0x172D220);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_325 (self, _cmd, &managed_method, p0, p1, 0x172D320);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_325 (self, _cmd, &managed_method, p0, p1, 0x172D420);
	}

	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_326 (self, _cmd, &managed_method, p0, 0x172D520);
	}

	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_327 (self, _cmd, &managed_method, p0, p1, 0x172D620);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x172CE20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate : NSObject<CBPeripheralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1;
	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_328 (self, _cmd, &managed_method, p0, p1, 0x172D820);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, p1, p2, 0x172D920);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, p1, p2, 0x172DA20);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_330 (self, _cmd, &managed_method, p0, p1, p2, 0x172DB20);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_331 (self, _cmd, &managed_method, p0, p1, p2, 0x172DC20);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_331 (self, _cmd, &managed_method, p0, p1, p2, 0x172DD20);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_332 (self, _cmd, &managed_method, p0, p1, 0x172DE20);
	}

	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x172DF20);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_334 (self, _cmd, &managed_method, p0, p1, p2, 0x172E020);
	}

	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x172E120);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, 0x172E220);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_336 (self, _cmd, &managed_method, p0, p1, 0x172E320);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x172D720);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheral__CBPeripheralDelegate : NSObject<CBPeripheralDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1;
	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0;
	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateName:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheral__CBPeripheralDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, p2, 0x172E520);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x172E620);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, p2, 0x172E720);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x172E820);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, p1, 0x172E920);
	}

	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, 0x172EA20);
	}

	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, 0x172EB20);
	}

	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_342 (self, _cmd, &managed_method, p0, p1, 0x172EC20);
	}

	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_343 (self, _cmd, &managed_method, p0, p1, p2, 0x172ED20);
	}

	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, p1, 0x172EE20);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, p2, 0x172EF20);
	}

	-(void) peripheralDidUpdateName:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, 0x172F020);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, p2, 0x172F120);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, p2, 0x172F220);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, p2, 0x172F320);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, p2, 0x172F420);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x172E420);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_AVCaptureFileOutput_recordingProxy : NSObject<AVCaptureFileOutputRecordingDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_AVCaptureFileOutput_recordingProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_345 (self, _cmd, &managed_method, p0, p1, p2, 0x172F620);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_346 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x172F720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate : NSObject<AVSpeechSynthesizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didCancelSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didContinueSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didFinishSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didPauseSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didStartSpeechUtterance:(AVSpeechUtterance *)p1;
	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 willSpeakRangeOfSpeechString:(NSRange)p1 utterance:(AVSpeechUtterance *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didCancelSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, 0x174A720);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didContinueSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, 0x174A820);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didFinishSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, 0x174A920);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didPauseSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, 0x174AA20);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 didStartSpeechUtterance:(AVSpeechUtterance *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, 0x174AB20);
	}

	-(void) speechSynthesizer:(AVSpeechSynthesizer *)p0 willSpeakRangeOfSpeechString:(NSRange)p1 utterance:(AVSpeechUtterance *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_348 (self, _cmd, &managed_method, p0, p1, p2, 0x174AC20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x174A620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_WrappedNSInputStream : NSInputStream {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSUInteger) streamStatus;
	-(void) open;
	-(void) close;
	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1;
	-(BOOL) hasBytesAvailable;
	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1;
	-(NSObject *) propertyForKey:(NSString *)p0;
	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1;
	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2;
	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_WrappedNSInputStream {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSUInteger) streamStatus
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_349 (self, _cmd, &managed_method, 0x1751220);
	}

	-(void) open
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1751320);
	}

	-(void) close
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1751420);
	}

	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_350 (self, _cmd, &managed_method, p0, p1, 0x1751520);
	}

	-(BOOL) hasBytesAvailable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x1751620);
	}

	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_351 (self, _cmd, &managed_method, p0, p1, 0x1751720);
	}

	-(NSObject *) propertyForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, p0, 0x1751820);
	}

	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, p1, 0x1751920);
	}

	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_354 (self, _cmd, &managed_method, p0, p1, p2, 0x1751A20);
	}

	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, p1, 0x1751B20);
	}

	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, p1, 0x1751C20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Foundation_NSNetService__NSNetServiceDelegate : NSObject<NSNetServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceDidResolveAddress:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2;
	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1;
	-(void) netServiceDidPublish:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1;
	-(void) netServiceDidStop:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1;
	-(void) netServiceWillPublish:(NSNetService *)p0;
	-(void) netServiceWillResolve:(NSNetService *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetService__NSNetServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceDidResolveAddress:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, 0x1752720);
	}

	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_357 (self, _cmd, &managed_method, p0, p1, p2, 0x1752820);
	}

	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_358 (self, _cmd, &managed_method, p0, p1, 0x1752920);
	}

	-(void) netServiceDidPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, 0x1752A20);
	}

	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_358 (self, _cmd, &managed_method, p0, p1, 0x1752B20);
	}

	-(void) netServiceDidStop:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, 0x1752C20);
	}

	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, p1, 0x1752D20);
	}

	-(void) netServiceWillPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, 0x1752E20);
	}

	-(void) netServiceWillResolve:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_356 (self, _cmd, &managed_method, p0, 0x1752F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1752620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate : NSObject<NSKeyedArchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1;
	-(void) archiverDidFinish:(NSKeyedArchiver *)p0;
	-(void) archiverWillFinish:(NSKeyedArchiver *)p0;
	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_360 (self, _cmd, &managed_method, p0, p1, 0x1758B20);
	}

	-(void) archiverDidFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x1758C20);
	}

	-(void) archiverWillFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x1758D20);
	}

	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_362 (self, _cmd, &managed_method, p0, p1, p2, 0x1758E20);
	}

	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, p1, 0x1758F20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1758A20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate : NSObject<NSKeyedUnarchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2;
	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1;
	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_364 (self, _cmd, &managed_method, p0, p1, p2, 0x1759120);
	}

	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, p1, 0x1759220);
	}

	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_366 (self, _cmd, &managed_method, p0, 0x1759320);
	}

	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_366 (self, _cmd, &managed_method, p0, 0x1759420);
	}

	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, p1, p2, 0x1759520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1759020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSStream__NSStreamDelegate : NSObject<NSStreamDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSStream__NSStreamDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_368 (self, _cmd, &managed_method, p0, p1, 0x175C720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x175C620);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSThread_ActionThread : NSThread {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) main;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSThread_ActionThread {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) main
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x175CD20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface __NSObject_Disposer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	+(void) drain:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __NSObject_Disposer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	+(void) drain:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_369 (self, _cmd, &managed_method, p0, 0x1760D20);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1760B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __XamarinObjectObserver : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __XamarinObjectObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_370 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1761020);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Foundation_NSCache__NSCacheDelegate : NSObject<NSCacheDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSCache__NSCacheDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_371 (self, _cmd, &managed_method, p0, p1, 0x1761920);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1761820);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSMetadataQuery__NSMetadataQueryDelegate : NSObject<NSMetadataQueryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSMetadataQuery__NSMetadataQueryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_372 (self, _cmd, &managed_method, p0, p1, 0x1763120);
	}

	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_373 (self, _cmd, &managed_method, p0, p1, p2, 0x1763220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1763020);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate : NSObject<NSNetServiceBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1;
	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_374 (self, _cmd, &managed_method, p0, p1, p2, 0x1763C20);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_374 (self, _cmd, &managed_method, p0, p1, p2, 0x1763D20);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_375 (self, _cmd, &managed_method, p0, p1, p2, 0x1763E20);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_376 (self, _cmd, &managed_method, p0, p1, 0x1763F20);
	}

	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_377 (self, _cmd, &managed_method, p0, 0x1764020);
	}

	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_377 (self, _cmd, &managed_method, p0, 0x1764120);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_375 (self, _cmd, &managed_method, p0, p1, p2, 0x1764220);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1763B20);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate : NSObject<NSUserNotificationCenterDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1;
	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_378 (self, _cmd, &managed_method, p0, p1, 0x1768320);
	}

	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_378 (self, _cmd, &managed_method, p0, p1, 0x1768420);
	}

	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_379 (self, _cmd, &managed_method, p0, p1, 0x1768520);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1768220);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate : NSObject<NSURLSessionDataDelegate, NSURLSessionTaskDelegate, NSURLSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_380 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x174D120);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_381 (self, _cmd, &managed_method, p0, p1, p2, 0x174D220);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_382 (self, _cmd, &managed_method, p0, p1, p2, 0x174D320);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_383 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x174D520);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_384 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x174D620);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_385 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x174D720);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) keyDown:(NSEvent *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_386 (self, _cmd, &managed_method, p0, 0x3DF52);
	}

	-(void) mouseDown:(NSEvent *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_386 (self, _cmd, &managed_method, p0, 0x3E152);
	}

	-(void) rightMouseUp:(NSEvent *)p0
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_386 (self, _cmd, &managed_method, p0, 0x3E252);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_387 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.MacOS.VisualElementRenderer`1' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ViewRenderer_2 {
}

	-(void) layout
	{
		MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_388 (self, _cmd, &managed_method, 0x38F52);
	}
	-(id) init
	{
		xamarin_throw_product_exception (4126, "Cannot construct an instance of the type 'Xamarin.Forms.Platform.MacOS.ViewRenderer`2' from Objective-C because the type is generic.");

		return self;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x37B52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Maps_MacOS_MapRenderer {
}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0xB50);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2450);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_macOS_Controls_FormsBoxView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_macOS_Controls_FormsBoxView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x1F52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2252);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_macOS_Controls_FormsNSSlider : NSSlider {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGSize) sizeThatFits:(CGSize)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_macOS_Controls_FormsNSSlider {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGSize) sizeThatFits:(CGSize)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_389 (self, _cmd, &managed_method, p0, 0x2452);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2352);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSlider class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_FormsNSDatePicker : NSDatePicker {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) resignFirstResponder;
	-(BOOL) becomeFirstResponder;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_FormsNSDatePicker {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) resignFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x3552);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x3652);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x3752);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSDatePicker class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_FormsApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x4052);
	}

	-(void) applicationDidBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x4152);
	}

	-(void) applicationDidResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x4252);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4B52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_PlatformRenderer : NSViewController {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) viewDidAppear;
	-(void) viewDidLayout;
	-(void) viewWillAppear;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_PlatformRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x5052);
	}

	-(void) viewDidLayout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x5152);
	}

	-(void) viewWillAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x5252);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_FlippedClipView : NSClipView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isFlipped;
	-(CGRect) constrainBoundsRect:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_FlippedClipView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isFlipped
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x7E52);
	}

	-(CGRect) constrainBoundsRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_390 (self, _cmd, &managed_method, p0, 0x8152);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8252);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSClipView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_PageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x8F52);
	}

	-(void) viewDidDisappear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x9052);
	}

	-(void) viewWillAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x9152);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8452);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_DefaultRenderer : Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1 {
}
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_DefaultRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9D52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_BoxViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB952);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ScrollViewRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0xC552);
	}

	-(void) UpdateScrollPosition
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0xD352);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBA52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSScrollView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ActivityIndicatorRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD952);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_DatePickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_FrameRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11152);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_FormsNSImageView : NSImageView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) isOpaque;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_FormsNSImageView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) isOpaque
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x11352);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11452);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSImageView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_OpenGLViewRenderer : Xamarin_Forms_Platform_MacOS_ViewRenderer_2 {
}
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_OpenGLViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12552);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_MacOSOpenGLView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_PickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13452);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ProgressBarRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13A52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_SearchBarRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14C52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_SliderRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x15552);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_StepperRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x15F52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_CheckBoxRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_SwitchRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x16D52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_TimePickerRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x17852);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_CellNSView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) layout;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_CellNSView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1AC52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_TrackingClickNSView : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) rightMouseDown:(NSEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_TrackingClickNSView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) rightMouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, 0x1B152);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1B052);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_ViewCellNSView : Xamarin_Forms_Platform_MacOS_CellNSView {
}
	-(void) layout;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_ViewCellNSView {
}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x1E252);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1DE52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_CellNSView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_ListViewDataSource : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_ListViewDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1F052);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1F152);
	}

	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x1F252);
	}

	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_392 (self, _cmd, &managed_method, p0, 0x1F352);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, p2, 0x1F452);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_CustomNSTableHeaderView : NSTableHeaderView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSAttributedString *) pageHeader;
	-(void) drawRect:(CGRect)p0;
	-(void) layout;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_CustomNSTableHeaderView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSAttributedString *) pageHeader
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_12 (self, _cmd, &managed_method, 0x1FF52);
	}

	-(void) drawRect:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x20052);
	}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x20152);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1FC52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTableHeaderView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_FormsPageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_FormsPageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, 0x29552);
	}

	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, p1, 0x29652);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_NavigationChildPageWrapper : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_NavigationChildPageWrapper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_NativeViewPropertyListener : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_NativeViewPropertyListener {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_370 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x2A352);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_LayoutRenderer : Xamarin_Forms_Platform_MacOS_DefaultRenderer {
}
	-(void) layout;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_LayoutRenderer {
}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x2A452);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2A552);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_DefaultRenderer class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_NSPageContainer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_NSPageContainer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_PageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_PageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, p1, 0x2AB52);
	}

	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, 0x2AC52);
	}

	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, 0x2AD52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2AE52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_TableViewRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2D852);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_TableViewDataSource : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_TableViewDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x2DD52);
	}

	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_392 (self, _cmd, &managed_method, p0, 0x2DE52);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x2DF52);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, p2, 0x2E052);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_UnEvenTableViewModelRenderer : Xamarin_Forms_Platform_MacOS_TableViewDataSource {
}
@end

@implementation Xamarin_Forms_Platform_MacOS_UnEvenTableViewModelRenderer {
}
@end

@interface Xamarin_Forms_Platform_MacOS_VerticallyCenteredTextFieldCell : NSTextFieldCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGRect) drawingRectForBounds:(CGRect)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
@end

@implementation Xamarin_Forms_Platform_MacOS_VerticallyCenteredTextFieldCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) drawingRectForBounds:(CGRect)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_390 (self, _cmd, &managed_method, p0, 0x30852);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_NativeViewWrapperRenderer {
}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x34352);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x34652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_LabelRenderer {
}

	-(void) layout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x35152);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x36552);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ButtonRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAB52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_EntryRenderer_FormsNSTextField : NSTextField {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) resignFirstResponder;
	-(BOOL) becomeFirstResponder;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(void) keyUp:(NSEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_EntryRenderer_FormsNSTextField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) resignFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x44252);
	}

	-(BOOL) becomeFirstResponder
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_30 (self, _cmd, &managed_method, 0x44352);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x44452);
	}

	-(void) keyUp:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, 0x44552);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x44952);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTextField class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_EntryRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFE52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_EditorRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10D52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ImageRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11552);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_WebViewRenderer_FormsWebFrameDelegate : NSObject<WebFrameLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_WebViewRenderer_FormsWebFrameDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, p1, 0x45852);
	}

	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, p2, 0x45952);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_WebViewRenderer {
}

	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(id)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_393 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x17B52);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_ListViewRenderer_FormsNSTableView : NSTableView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mouseDown:(NSEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_ListViewRenderer_FormsNSTableView {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, 0x45E52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x45F52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTableView class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_ListViewRenderer {
}

	-(void) viewWillDraw
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x18952);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x19E52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation CarouselPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) selectedIndex
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_26 (self, _cmd, &managed_method, 0x20552);
	}

	-(void) setSelectedIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0x20652);
	}

	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x21052);
	}

	-(void) viewDidDisappear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x21152);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x20252);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSPageController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer_ViewControllerWrapper : NSViewController {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) viewWillLayout;
	-(void) viewWillAppear;
	-(void) viewWillDisappear;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer_ViewControllerWrapper {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewWillLayout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x46D52);
	}

	-(void) viewWillAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x46E52);
	}

	-(void) viewWillDisappear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x46F52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewWillAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x23252);
	}

	-(CGRect) splitView:(NSSplitView *)p0 effectiveRect:(CGRect)p1 forDrawnRect:(CGRect)p2 ofDividerAtIndex:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_394 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x23352);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x23C52);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSSplitViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_TabbedPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewWillLayout
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x24852);
	}

	-(NSInteger) selectedTabViewItemIndex
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_26 (self, _cmd, &managed_method, 0x24952);
	}

	-(void) setSelectedTabViewItemIndex:(NSInteger)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, 0x24A52);
	}

	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x24B52);
	}

	-(void) viewDidDisappear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x24C52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x26252);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSTabViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation Xamarin_Forms_Platform_MacOS_NavigationPageRenderer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) viewDidDisappear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x27752);
	}

	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x27852);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x26852);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSViewController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_NativeToolbarTracker_ToolBarItemNSButton : NSView {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Xamarin_Forms_Platform_MacOS_NativeToolbarTracker_ToolBarItemNSButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
@end

@interface Xamarin_Forms_Platform_MacOS_NativeToolbarTracker : NSObject<NSToolbarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0;
	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0;
	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_NativeToolbarTracker {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, 0x2EC52);
	}

	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, 0x2ED52);
	}

	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_320 (self, _cmd, &managed_method, p0, p1, p2, 0x2EE52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E852);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton_FormsNSButtonCell : NSButtonCell {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(CGRect) drawTitle:(NSAttributedString *)p0 withFrame:(CGRect)p1 inView:(NSView *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) copyWithZone: (NSZone *)zone;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton_FormsNSButtonCell {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(CGRect) drawTitle:(NSAttributedString *)p0 withFrame:(CGRect)p1 inView:(NSView *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_395 (self, _cmd, &managed_method, p0, p1, p2, 0x4D752);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}
	-(id) copyWithZone: (NSZone *) zone
	{
		id rv;
		int gchandle;

		gchandle = xamarin_get_gchandle_with_flags (self);
		if (gchandle != 0)
			xamarin_set_gchandle (self, 0);
		rv = [super copyWithZone: zone];

		if (gchandle != 0)
			xamarin_set_gchandle (self, gchandle);

		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4D852);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButtonCell class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton : NSButton {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mouseDown:(NSEvent *)p0;
	-(CGSize) intrinsicContentSize;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mouseDown:(NSEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_391 (self, _cmd, &managed_method, p0, 0x43B52);
	}

	-(CGSize) intrinsicContentSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_396 (self, _cmd, &managed_method, 0x43D52);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x43652);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSButton class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation AppDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x3);
	}

	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x5);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation AnimatingViewsWindow {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) simpleLayoutView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_397 (self, _cmd, &managed_method, 0xB);
	}

	-(void) setSimpleLayoutView:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_398 (self, _cmd, &managed_method, p0, 0xD);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0xF);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSWindow class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@interface AnimatingViews_AnimatingViewsWindowController_MessageTypeDataSource : NSObject<NSComboBoxDataSource> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) numberOfItemsInComboBox:(NSComboBox *)p0;
	-(NSObject *) comboBox:(NSComboBox *)p0 objectValueForItemAtIndex:(NSInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AnimatingViews_AnimatingViewsWindowController_MessageTypeDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) numberOfItemsInComboBox:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_399 (self, _cmd, &managed_method, p0, 0x13);
	}

	-(NSObject *) comboBox:(NSComboBox *)p0 objectValueForItemAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_400 (self, _cmd, &managed_method, p0, p1, 0x15);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x17);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation AnimatingViewsWindowController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTextField *) laterLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, 0x1B);
	}

	-(void) setLaterLabel:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x1D);
	}

	-(NSTextFieldCell *) laterWeatherLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_403 (self, _cmd, &managed_method, 0x1F);
	}

	-(void) setLaterWeatherLabel:(NSTextFieldCell *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_404 (self, _cmd, &managed_method, p0, 0x21);
	}

	-(NSTextField *) nowLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, 0x23);
	}

	-(void) setNowLabel:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x25);
	}

	-(NSTextField *) nowWeatherLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, 0x27);
	}

	-(void) setNowWeatherLabel:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x29);
	}

	-(NSComboBox *) outletFoodSelectionComboBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_405 (self, _cmd, &managed_method, 0x2B);
	}

	-(void) setOutletFoodSelectionComboBox:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_406 (self, _cmd, &managed_method, p0, 0x2D);
	}

	-(NSTextField *) plantSize
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, 0x2F);
	}

	-(void) setPlantSize:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x31);
	}

	-(NSStepper *) plantSizeStepper
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_407 (self, _cmd, &managed_method, 0x33);
	}

	-(void) setPlantSizeStepper:(NSStepper *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_408 (self, _cmd, &managed_method, p0, 0x35);
	}

	-(NSView *) simpleView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_397 (self, _cmd, &managed_method, 0x37);
	}

	-(void) setSimpleView:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_398 (self, _cmd, &managed_method, p0, 0x39);
	}

	-(NSTextField *) tenHoursFromNow2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_401 (self, _cmd, &managed_method, 0x3B);
	}

	-(void) setTenHoursFromNow2:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_402 (self, _cmd, &managed_method, p0, 0x3D);
	}

	-(void) awakeFromNib
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_43 (self, _cmd, &managed_method, 0x3F);
	}

	-(void) addABox:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_409 (self, _cmd, &managed_method, p0, 0x41);
	}

	-(void) sizeTicker:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x43);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x1475C20);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, &call_super, 0x45);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSWindowController class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x47);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSWindowController class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

	static MTClassMap __xamarin_class_map [] = {
		{ NULL, 0x1C6420 /* #0 'NSObject' => 'Foundation.NSObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x620 /* #1 'SNAudioStreamAnalyzer' => 'SoundAnalysis.SNAudioStreamAnalyzer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x720 /* #2 'SNClassification' => 'SoundAnalysis.SNClassification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x820 /* #3 'SNClassificationResult' => 'SoundAnalysis.SNClassificationResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x920 /* #4 'SNClassifySoundRequest' => 'SoundAnalysis.SNClassifySoundRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1520 /* #5 'SFContentBlockerState' => 'SafariServices.SFContentBlockerState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131D20 /* #6 'NSResponder' => 'AppKit.NSResponder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170220 /* #7 'NSViewController' => 'AppKit.NSViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2020 /* #8 'SFSafariExtensionViewController' => 'SafariServices.SFSafariExtensionViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2220 /* #9 'SFSafariPageProperties' => 'SafariServices.SFSafariPageProperties, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2520 /* #10 'SFSafariToolbarItem' => 'SafariServices.SFSafariToolbarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2720 /* #11 'SFUniversalLink' => 'SafariServices.SFUniversalLink, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2920 /* #12 'SFAcousticFeature' => 'Speech.SFAcousticFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B20 /* #13 'SFSpeechRecognitionRequest' => 'Speech.SFSpeechRecognitionRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A20 /* #14 'SFSpeechAudioBufferRecognitionRequest' => 'Speech.SFSpeechAudioBufferRecognitionRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C20 /* #15 'SFSpeechRecognitionResult' => 'Speech.SFSpeechRecognitionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D20 /* #16 'SFSpeechRecognitionTask' => 'Speech.SFSpeechRecognitionTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3120 /* #17 'SFSpeechRecognitionTaskDelegate' => 'Speech.SFSpeechRecognitionTaskDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3420 /* #18 'SFSpeechRecognizer' => 'Speech.SFSpeechRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3920 /* #19 'SFSpeechRecognizerDelegate' => 'Speech.SFSpeechRecognizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3A20 /* #20 'SFSpeechURLRecognitionRequest' => 'Speech.SFSpeechUrlRecognitionRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3B20 /* #21 'SFTranscription' => 'Speech.SFTranscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3C20 /* #22 'SFTranscriptionSegment' => 'Speech.SFTranscriptionSegment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D20 /* #23 'SFVoiceAnalytics' => 'Speech.SFVoiceAnalytics, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E20 /* #24 'QLFileThumbnailRequest' => 'QuickLookThumbnailing.QLFileThumbnailRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4120 /* #25 'QLThumbnailGenerationRequest' => 'QuickLookThumbnailing.QLThumbnailGenerationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4520 /* #26 'QLThumbnailProvider' => 'QuickLookThumbnailing.QLThumbnailProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4620 /* #27 'QLThumbnailReply' => 'QuickLookThumbnailing.QLThumbnailReply, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4720 /* #28 'QLThumbnailRepresentation' => 'QuickLookThumbnailing.QLThumbnailRepresentation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4920 /* #29 'QCComposition' => 'QuartzComposer.QCComposition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCB20 /* #30 'CALayer' => 'CoreAnimation.CALayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF120 /* #31 'CAOpenGLLayer' => 'CoreAnimation.CAOpenGLLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A20 /* #32 'QCCompositionLayer' => 'QuartzComposer.QCCompositionLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B20 /* #33 'QCCompositionRepository' => 'QuartzComposer.QCCompositionRepository, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C20 /* #34 'PKPushCredentials' => 'PushKit.PKPushCredentials, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D20 /* #35 'PKPushPayload' => 'PushKit.PKPushPayload, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E20 /* #36 'PKPushRegistry' => 'PushKit.PKPushRegistry, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5220 /* #37 'PKPushRegistryDelegate' => 'PushKit.PKPushRegistryDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5420 /* #38 'PKDrawing' => 'PencilKit.PKDrawing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133A20 /* #39 'NSView' => 'AppKit.NSView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5720 /* #40 'PHLivePhotoView' => 'PhotosUI.PHLivePhotoView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5C20 /* #41 'PHLivePhotoViewDelegate' => 'PhotosUI.PHLivePhotoViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6120 /* #42 'PHProjectElement' => 'PhotosUI.PHProjectElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E20 /* #43 'PHProjectAssetElement' => 'PhotosUI.PHProjectAssetElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAB20 /* #44 'NSExtensionContext' => 'Foundation.NSExtensionContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6220 /* #45 'PHProjectExtensionContext' => 'PhotosUI.PHProjectExtensionContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6620 /* #46 'PHProjectInfo' => 'PhotosUI.PHProjectInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6720 /* #47 'PHProjectJournalEntryElement' => 'PhotosUI.PHProjectJournalEntryElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6820 /* #48 'PHProjectMapElement' => 'PhotosUI.PHProjectMapElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6920 /* #49 'PHProjectRegionOfInterest' => 'PhotosUI.PHProjectRegionOfInterest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A20 /* #50 'PHProjectSection' => 'PhotosUI.PHProjectSection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B20 /* #51 'PHProjectSectionContent' => 'PhotosUI.PHProjectSectionContent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C20 /* #52 'PHProjectTextElement' => 'PhotosUI.PHProjectTextElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E20 /* #53 'PHProjectTypeDescription' => 'PhotosUI.PHProjectTypeDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7220 /* #54 'PHProjectTypeDescriptionDataSource' => 'PhotosUI.PHProjectTypeDescriptionDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8320 /* #55 'NCWidgetController' => 'NotificationCenter.NCWidgetController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8A20 /* #56 'NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E20 /* #57 'NCWidgetProviding' => 'NotificationCenter.NCWidgetProviding, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9420 /* #58 'NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9920 /* #59 'MLMediaGroup' => 'MediaLibrary.MLMediaGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A20 /* #60 'MLMediaLibrary' => 'MediaLibrary.MLMediaLibrary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B20 /* #61 'MLMediaObject' => 'MediaLibrary.MLMediaObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9C20 /* #62 'MLMediaSource' => 'MediaLibrary.MLMediaSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA120 /* #63 'LPLinkMetadata' => 'LinkPresentation.LPLinkMetadata, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA220 /* #64 'LPLinkView' => 'LinkPresentation.LPLinkView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB20 /* #65 'ICDevice' => 'ImageCaptureCore.ICDevice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE20 /* #66 'ICCameraDevice' => 'ImageCaptureCore.ICCameraDevice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB220 /* #67 'Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDelegate' => 'ImageCaptureCore.ICCameraDeviceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB620 /* #68 'Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDownloadDelegate' => 'ImageCaptureCore.ICCameraDeviceDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBA20 /* #69 'ICCameraItem' => 'ImageCaptureCore.ICCameraItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB820 /* #70 'ICCameraFile' => 'ImageCaptureCore.ICCameraFile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB920 /* #71 'ICCameraFolder' => 'ImageCaptureCore.ICCameraFolder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBC20 /* #72 'ICDeviceBrowser' => 'ImageCaptureCore.ICDeviceBrowser, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC020 /* #73 'Xamarin_Mac__ImageCaptureCore_ICDeviceBrowserDelegate' => 'ImageCaptureCore.ICDeviceBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC520 /* #74 'Xamarin_Mac__ImageCaptureCore_ICDeviceDelegate' => 'ImageCaptureCore.ICDeviceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCC20 /* #75 'ICScannerBandData' => 'ImageCaptureCore.ICScannerBandData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCF20 /* #76 'ICScannerDevice' => 'ImageCaptureCore.ICScannerDevice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD320 /* #77 'Xamarin_Mac__ImageCaptureCore_ICScannerDeviceDelegate' => 'ImageCaptureCore.ICScannerDeviceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD520 /* #78 'ICScannerFeature' => 'ImageCaptureCore.ICScannerFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD620 /* #79 'ICScannerFeatureBoolean' => 'ImageCaptureCore.ICScannerFeatureBoolean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD720 /* #80 'ICScannerFeatureEnumeration' => 'ImageCaptureCore.ICScannerFeatureEnumeration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD820 /* #81 'ICScannerFeatureRange' => 'ImageCaptureCore.ICScannerFeatureRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD920 /* #82 'ICScannerFeatureTemplate' => 'ImageCaptureCore.ICScannerFeatureTemplate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDB20 /* #83 'ICScannerFunctionalUnit' => 'ImageCaptureCore.ICScannerFunctionalUnit, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC20 /* #84 'ICScannerFunctionalUnitDocumentFeeder' => 'ImageCaptureCore.ICScannerFunctionalUnitDocumentFeeder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD20 /* #85 'ICScannerFunctionalUnitFlatbed' => 'ImageCaptureCore.ICScannerFunctionalUnitFlatbed, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE20 /* #86 'ICScannerFunctionalUnitNegativeTransparency' => 'ImageCaptureCore.ICScannerFunctionalUnitNegativeTransparency, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF20 /* #87 'ICScannerFunctionalUnitPositiveTransparency' => 'ImageCaptureCore.ICScannerFunctionalUnitPositiveTransparency, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE920 /* #88 'FPUIActionExtensionContext' => 'FileProviderUI.FPUIActionExtensionContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEA20 /* #89 'FPUIActionExtensionViewController' => 'FileProviderUI.FPUIActionExtensionViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xED20 /* #90 'EPDeveloperTool' => 'ExecutionPolicy.EPDeveloperTool, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF120 /* #91 'EPExecutionPolicy' => 'ExecutionPolicy.EPExecutionPolicy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF620 /* #92 'EAAccessoryDelegate' => 'ExternalAccessory.EAAccessoryDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFA20 /* #93 'EASession' => 'ExternalAccessory.EASession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10020 /* #94 'CNContactPicker' => 'ContactsUI.CNContactPicker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10420 /* #95 'CNContactPickerDelegate' => 'ContactsUI.CNContactPickerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10520 /* #96 'CNContactViewController' => 'ContactsUI.CNContactViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10620 /* #97 'AUAudioUnitViewConfiguration' => 'CoreAudioKit.AUAudioUnitViewConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A20 /* #98 'AUGenericView' => 'CoreAudioKit.AUGenericView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C20 /* #99 'AUPannerView' => 'CoreAudioKit.AUPannerView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D20 /* #100 'AUViewController' => 'CoreAudioKit.AUViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170B20 /* #101 'NSWindowController' => 'AppKit.NSWindowController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10E20 /* #102 'CABTLEMIDIWindowController' => 'CoreAudioKit.CABtleMidiWindowController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10F20 /* #103 'CAInterDeviceAudioViewController' => 'CoreAudioKit.CAInterDeviceAudioViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11020 /* #104 'CANetworkBrowserWindowController' => 'CoreAudioKit.CANetworkBrowserWindowController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11120 /* #105 'ASIdentifierManager' => 'AdSupport.ASIdentifierManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E20 /* #106 'IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13520 /* #107 'IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13720 /* #108 'IKFilterBrowserView' => 'ImageKit.IKFilterBrowserView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13A20 /* #109 'IKFilterCustomUIProvider' => 'ImageKit.IKFilterCustomUIProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13B20 /* #110 'IKFilterUIView' => 'ImageKit.IKFilterUIView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13C20 /* #111 'IKImageBrowserCell' => 'ImageKit.IKImageBrowserCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14020 /* #112 'IKImageBrowserDataSource' => 'ImageKit.IKImageBrowserDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14420 /* #113 'IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14820 /* #114 'IKImageBrowserItem' => 'ImageKit.IKImageBrowserItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132F20 /* #115 'NSWindow' => 'AppKit.NSWindow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C220 /* #116 'NSPanel' => 'AppKit.NSPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D20 /* #117 'IKImageEditPanel' => 'ImageKit.IKImageEditPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15120 /* #118 'IKImageEditPanelDataSource' => 'ImageKit.IKImageEditPanelDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15220 /* #119 'IKImageView' => 'ImageKit.IKImageView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15520 /* #120 'IKPictureTaker' => 'ImageKit.IKPictureTaker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A20 /* #121 'IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptionsDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16320 /* #122 'IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16420 /* #123 'IKSlideshow' => 'ImageKit.IKSlideshow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16820 /* #124 'IKSlideshowDataSource' => 'ImageKit.IKSlideshowDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19120 /* #125 'MIDICIProfile' => 'CoreMidi.MidiCIProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19220 /* #126 'MIDICIProfileState' => 'CoreMidi.MidiCIProfileState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19320 /* #127 'MIDICISession' => 'CoreMidi.MidiCISession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19920 /* #128 'ACAccount' => 'Accounts.ACAccount, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19A20 /* #129 'ACAccountCredential' => 'Accounts.ACAccountCredential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19D20 /* #130 'ACAccountType' => 'Accounts.ACAccountType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FD20 /* #131 'VNRequest' => 'Vision.VNRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23520 /* #132 'VNImageBasedRequest' => 'Vision.VNImageBasedRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FE20 /* #133 'VNDetectBarcodesRequest' => 'Vision.VNDetectBarcodesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D20 /* #134 'VNObservation' => 'Vision.VNObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20020 /* #135 'VNFeaturePrintObservation' => 'Vision.VNFeaturePrintObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21120 /* #136 'VNDetectedObjectObservation' => 'Vision.VNDetectedObjectObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24720 /* #137 'VNRectangleObservation' => 'Vision.VNRectangleObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20620 /* #138 'VNBarcodeObservation' => 'Vision.VNBarcodeObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20920 /* #139 'VNClassificationObservation' => 'Vision.VNClassificationObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20A20 /* #140 'VNClassifyImageRequest' => 'Vision.VNClassifyImageRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20C20 /* #141 'VNCoreMLFeatureValueObservation' => 'Vision.VNCoreMLFeatureValueObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20D20 /* #142 'VNCoreMLModel' => 'Vision.VNCoreMLModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x20E20 /* #143 'VNCoreMLRequest' => 'Vision.VNCoreMLRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21320 /* #144 'VNDetectFaceCaptureQualityRequest' => 'Vision.VNDetectFaceCaptureQualityRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21520 /* #145 'VNDetectFaceLandmarksRequest' => 'Vision.VNDetectFaceLandmarksRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21720 /* #146 'VNDetectFaceRectanglesRequest' => 'Vision.VNDetectFaceRectanglesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21920 /* #147 'VNDetectHorizonRequest' => 'Vision.VNDetectHorizonRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21B20 /* #148 'VNDetectHumanRectanglesRequest' => 'Vision.VNDetectHumanRectanglesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21D20 /* #149 'VNDetectRectanglesRequest' => 'Vision.VNDetectRectanglesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x21F20 /* #150 'VNDetectTextRectanglesRequest' => 'Vision.VNDetectTextRectanglesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22420 /* #151 'VNFaceLandmarkRegion' => 'Vision.VNFaceLandmarkRegion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22520 /* #152 'VNFaceLandmarks' => 'Vision.VNFaceLandmarks, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22620 /* #153 'VNFaceLandmarks2D' => 'Vision.VNFaceLandmarks2D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22720 /* #154 'VNFaceObservation' => 'Vision.VNFaceObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22B20 /* #155 'VNGenerateAttentionBasedSaliencyImageRequest' => 'Vision.VNGenerateAttentionBasedSaliencyImageRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22D20 /* #156 'VNGenerateImageFeaturePrintRequest' => 'Vision.VNGenerateImageFeaturePrintRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x22F20 /* #157 'VNGenerateObjectnessBasedSaliencyImageRequest' => 'Vision.VNGenerateObjectnessBasedSaliencyImageRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25320 /* #158 'VNTargetedImageRequest' => 'Vision.VNTargetedImageRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23A20 /* #159 'VNImageRegistrationRequest' => 'Vision.VNImageRegistrationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23120 /* #160 'VNHomographicImageRegistrationRequest' => 'Vision.VNHomographicImageRegistrationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23320 /* #161 'VNHorizonObservation' => 'Vision.VNHorizonObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23420 /* #162 'VNImageAlignmentObservation' => 'Vision.VNImageAlignmentObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23720 /* #163 'VNImageHomographicAlignmentObservation' => 'Vision.VNImageHomographicAlignmentObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23B20 /* #164 'VNImageRequestHandler' => 'Vision.VNImageRequestHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23C20 /* #165 'VNImageTranslationAlignmentObservation' => 'Vision.VNImageTranslationAlignmentObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23E20 /* #166 'VNPixelBufferObservation' => 'Vision.VNPixelBufferObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24120 /* #167 'VNRecognizedObjectObservation' => 'Vision.VNRecognizedObjectObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24320 /* #168 'VNRecognizedText' => 'Vision.VNRecognizedText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24420 /* #169 'VNRecognizedTextObservation' => 'Vision.VNRecognizedTextObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24520 /* #170 'VNRecognizeTextRequest' => 'Vision.VNRecognizeTextRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25120 /* #171 'VNSaliencyImageObservation' => 'Vision.VNSaliencyImageObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25220 /* #172 'VNSequenceRequestHandler' => 'Vision.VNSequenceRequestHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25420 /* #173 'VNTextObservation' => 'Vision.VNTextObservation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25620 /* #174 'VNTrackingRequest' => 'Vision.VNTrackingRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25720 /* #175 'VNTrackObjectRequest' => 'Vision.VNTrackObjectRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25920 /* #176 'VNTrackRectangleRequest' => 'Vision.VNTrackRectangleRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B20 /* #177 'VNTranslationalImageRegistrationRequest' => 'Vision.VNTranslationalImageRegistrationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29220 /* #178 'VSAccountMetadataRequest' => 'VideoSubscriberAccount.VSAccountMetadataRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29520 /* #179 'VSAccountManager' => 'VideoSubscriberAccount.VSAccountManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29A20 /* #180 'VSAccountManagerDelegate' => 'VideoSubscriberAccount.VSAccountManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29B20 /* #181 'VSAccountManagerResult' => 'VideoSubscriberAccount.VSAccountManagerResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29C20 /* #182 'VSAccountMetadata' => 'VideoSubscriberAccount.VSAccountMetadata, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x29E20 /* #183 'VSAccountProviderResponse' => 'VideoSubscriberAccount.VSAccountProviderResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A420 /* #184 'VSSubscription' => 'VideoSubscriberAccount.VSSubscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A620 /* #185 'VSSubscriptionRegistrationCenter' => 'VideoSubscriberAccount.VSSubscriptionRegistrationCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2A720 /* #186 'UNNotificationAttachment' => 'UserNotifications.UNNotificationAttachment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BF20 /* #187 'UNNotificationTrigger' => 'UserNotifications.UNNotificationTrigger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AB20 /* #188 'UNCalendarNotificationTrigger' => 'UserNotifications.UNCalendarNotificationTrigger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B720 /* #189 'UNNotificationContent' => 'UserNotifications.UNNotificationContent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AE20 /* #190 'UNMutableNotificationContent' => 'UserNotifications.UNMutableNotificationContent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2AF20 /* #191 'UNNotification' => 'UserNotifications.UNNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B020 /* #192 'UNNotificationAction' => 'UserNotifications.UNNotificationAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B520 /* #193 'UNNotificationCategory' => 'UserNotifications.UNNotificationCategory, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2B920 /* #194 'UNNotificationRequest' => 'UserNotifications.UNNotificationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BA20 /* #195 'UNNotificationResponse' => 'UserNotifications.UNNotificationResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BB20 /* #196 'UNNotificationServiceExtension' => 'UserNotifications.UNNotificationServiceExtension, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BD20 /* #197 'UNNotificationSettings' => 'UserNotifications.UNNotificationSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2BE20 /* #198 'UNNotificationSound' => 'UserNotifications.UNNotificationSound, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C020 /* #199 'UNPushNotificationTrigger' => 'UserNotifications.UNPushNotificationTrigger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C220 /* #200 'UNTextInputNotificationAction' => 'UserNotifications.UNTextInputNotificationAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C320 /* #201 'UNTextInputNotificationResponse' => 'UserNotifications.UNTextInputNotificationResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C420 /* #202 'UNTimeIntervalNotificationTrigger' => 'UserNotifications.UNTimeIntervalNotificationTrigger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C920 /* #203 'UNUserNotificationCenterDelegate' => 'UserNotifications.UNUserNotificationCenterDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F520 /* #204 'SKRequest' => 'StoreKit.SKRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D120 /* #205 'SKReceiptRefreshRequest' => 'StoreKit.SKReceiptRefreshRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D220 /* #206 'SKPayment' => 'StoreKit.SKPayment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D320 /* #207 'SKPaymentTransactionObserver' => 'StoreKit.SKPaymentTransactionObserver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2D720 /* #208 'SKArcadeService' => 'StoreKit.SKArcadeService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DA20 /* #209 'SKDownload' => 'StoreKit.SKDownload, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DE20 /* #210 'SKMutablePayment' => 'StoreKit.SKMutablePayment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2DF20 /* #211 'SKPaymentDiscount' => 'StoreKit.SKPaymentDiscount, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E020 /* #212 'SKPaymentQueue' => 'StoreKit.SKPaymentQueue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E420 /* #213 'Xamarin_Mac__StoreKit_SKPaymentQueueDelegate' => 'StoreKit.SKPaymentQueueDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E520 /* #214 'SKPaymentTransaction' => 'StoreKit.SKPaymentTransaction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2E920 /* #215 'SKProduct' => 'StoreKit.SKProduct, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2EA20 /* #216 'SKProductDiscount' => 'StoreKit.SKProductDiscount, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FA20 /* #217 'SKRequestDelegate' => 'StoreKit.SKRequestDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F220 /* #218 'SKProductsRequestDelegate' => 'StoreKit.SKProductsRequestDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F320 /* #219 'SKProductsResponse' => 'StoreKit.SKProductsResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2F420 /* #220 'SKProductSubscriptionPeriod' => 'StoreKit.SKProductSubscriptionPeriod, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FB20 /* #221 'SKStorefront' => 'StoreKit.SKStorefront, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FC20 /* #222 'SKStoreReviewController' => 'StoreKit.SKStoreReviewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x30320 /* #223 'SLComposeServiceViewController' => 'Social.SLComposeServiceViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x36F20 /* #224 'SBApplicationDelegate' => 'ScriptingBridge.SBApplicationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6220 /* #225 'NSArray' => 'Foundation.NSArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8820 /* #226 'NSMutableArray' => 'Foundation.NSMutableArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x37020 /* #227 'SBElementArray' => 'ScriptingBridge.SBElementArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x37120 /* #228 'SBObject' => 'ScriptingBridge.SBObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x37320 /* #229 'QLPreviewPanel' => 'QuickLookUI.QLPreviewPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x37A20 /* #230 'QLPreviewItem' => 'QuickLookUI.QLPreviewItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x37E20 /* #231 'QLPreviewPanelDataSource' => 'QuickLookUI.QLPreviewPanelDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x38220 /* #232 'QLPreviewPanelDelegate' => 'QuickLookUI.QLPreviewPanelDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x38320 /* #233 'QLPreviewView' => 'QuickLookUI.QLPreviewView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40B20 /* #234 'PHObject' => 'Photos.PHObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F220 /* #235 'PHCollection' => 'Photos.PHCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D320 /* #236 'PHAssetCollection' => 'Photos.PHAssetCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D420 /* #237 'PHCollectionList' => 'Photos.PHCollectionList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D520 /* #238 'PHContentEditingInput' => 'Photos.PHContentEditingInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D720 /* #239 'PHImageManager' => 'Photos.PHImageManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D820 /* #240 'PHLivePhoto' => 'Photos.PHLivePhoto, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D920 /* #241 'PHChangeRequest' => 'Photos.PHChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DB20 /* #242 'PHAdjustmentData' => 'Photos.PHAdjustmentData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DC20 /* #243 'PHAsset' => 'Photos.PHAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DE20 /* #244 'PHAssetChangeRequest' => 'Photos.PHAssetChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3DF20 /* #245 'PHAssetCollectionChangeRequest' => 'Photos.PHAssetCollectionChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E320 /* #246 'PHAssetCreationRequest' => 'Photos.PHAssetCreationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E820 /* #247 'PHAssetResource' => 'Photos.PHAssetResource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3E920 /* #248 'PHAssetResourceCreationOptions' => 'Photos.PHAssetResourceCreationOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EB20 /* #249 'PHAssetResourceRequestOptions' => 'Photos.PHAssetResourceRequestOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EF20 /* #250 'PHCachingImageManager' => 'Photos.PHCachingImageManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F020 /* #251 'PHChange' => 'Photos.PHChange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F120 /* #252 'PHCloudIdentifier' => 'Photos.PHCloudIdentifier, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F420 /* #253 'PHCollectionListChangeRequest' => 'Photos.PHCollectionListChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F720 /* #254 'PHContentEditingInputRequestOptions' => 'Photos.PHContentEditingInputRequestOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F820 /* #255 'PHContentEditingOutput' => 'Photos.PHContentEditingOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3F920 /* #256 'PHFetchOptions' => 'Photos.PHFetchOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3FA20 /* #257 'PHFetchResult' => 'Photos.PHFetchResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3FB20 /* #258 'PHFetchResultChangeDetails' => 'Photos.PHFetchResultChangeDetails, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3FE20 /* #259 'PHImageRequestOptions' => 'Photos.PHImageRequestOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40A20 /* #260 'PHLivePhotoRequestOptions' => 'Photos.PHLivePhotoRequestOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40C20 /* #261 'PHObjectChangeDetails' => 'Photos.PHObjectChangeDetails, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40D20 /* #262 'PHObjectPlaceholder' => 'Photos.PHObjectPlaceholder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41420 /* #263 'PHPhotoLibraryChangeObserver' => 'Photos.PHPhotoLibraryChangeObserver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41720 /* #264 'PHProject' => 'Photos.PHProject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41820 /* #265 'PHProjectChangeRequest' => 'Photos.PHProjectChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x41C20 /* #266 'PHVideoRequestOptions' => 'Photos.PHVideoRequestOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42D20 /* #267 'PDFBorder' => 'PdfKit.PdfBorder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42C20 /* #268 'PDFAnnotation' => 'PdfKit.PdfAnnotation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x42F20 /* #269 'PDFAnnotationMarkup' => 'PdfKit.PdfAnnotationMarkup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43120 /* #270 'PDFAction' => 'PdfKit.PdfAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43220 /* #271 'PDFActionGoTo' => 'PdfKit.PdfActionGoTo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43320 /* #272 'PDFActionNamed' => 'PdfKit.PdfActionNamed, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43520 /* #273 'PDFActionRemoteGoTo' => 'PdfKit.PdfActionRemoteGoTo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43620 /* #274 'PDFActionResetForm' => 'PdfKit.PdfActionResetForm, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43720 /* #275 'PDFActionURL' => 'PdfKit.PdfActionUrl, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43820 /* #276 'PDFAnnotationButtonWidget' => 'PdfKit.PdfAnnotationButtonWidget, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43920 /* #277 'PDFAnnotationChoiceWidget' => 'PdfKit.PdfAnnotationChoiceWidget, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43A20 /* #278 'PDFAnnotationCircle' => 'PdfKit.PdfAnnotationCircle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43B20 /* #279 'PDFAnnotationFreeText' => 'PdfKit.PdfAnnotationFreeText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x43E20 /* #280 'PDFAnnotationInk' => 'PdfKit.PdfAnnotationInk, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44120 /* #281 'PDFAnnotationLine' => 'PdfKit.PdfAnnotationLine, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44420 /* #282 'PDFAnnotationLink' => 'PdfKit.PdfAnnotationLink, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44520 /* #283 'PDFAnnotationPopup' => 'PdfKit.PdfAnnotationPopup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44620 /* #284 'PDFAnnotationSquare' => 'PdfKit.PdfAnnotationSquare, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44720 /* #285 'PDFAnnotationStamp' => 'PdfKit.PdfAnnotationStamp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44A20 /* #286 'PDFAnnotationText' => 'PdfKit.PdfAnnotationText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x44D20 /* #287 'PDFAnnotationTextWidget' => 'PdfKit.PdfAnnotationTextWidget, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45020 /* #288 'PDFAppearanceCharacteristics' => 'PdfKit.PdfAppearanceCharacteristics, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45520 /* #289 'PDFDestination' => 'PdfKit.PdfDestination, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x45F20 /* #290 'PDFDocumentDelegate' => 'PdfKit.PdfDocumentDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46620 /* #291 'PDFOutline' => 'PdfKit.PdfOutline, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46720 /* #292 'PDFPage' => 'PdfKit.PdfPage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46920 /* #293 'PDFSelection' => 'PdfKit.PdfSelection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x47120 /* #294 'PDFViewDelegate' => 'PdfKit.PdfViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D820 /* #295 'NETunnelNetworkSettings' => 'NetworkExtension.NETunnelNetworkSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49420 /* #296 'NEPacketTunnelNetworkSettings' => 'NetworkExtension.NEPacketTunnelNetworkSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49620 /* #297 'NWPath' => 'NetworkExtension.NWPath, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F120 /* #298 'NWEndpoint' => 'NetworkExtension.NWEndpoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49720 /* #299 'NWHostEndpoint' => 'NetworkExtension.NWHostEndpoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49820 /* #300 'NWTCPConnectionAuthenticationDelegate' => 'NetworkExtension.NWTcpConnectionAuthenticationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A420 /* #301 'NEAppRule' => 'NetworkExtension.NEAppRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4EC20 /* #302 'NEVPNProtocol' => 'NetworkExtension.NEVpnProtocol, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A920 /* #303 'NEDNSProxyProviderProtocol' => 'NetworkExtension.NEDnsProxyProviderProtocol, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4AA20 /* #304 'NEDNSSettings' => 'NetworkExtension.NEDnsSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4AB20 /* #305 'NEEvaluateConnectionRule' => 'NetworkExtension.NEEvaluateConnectionRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C020 /* #306 'NEFilterVerdict' => 'NetworkExtension.NEFilterVerdict, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4AF20 /* #307 'NEFilterDataVerdict' => 'NetworkExtension.NEFilterDataVerdict, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B020 /* #308 'NEFilterFlow' => 'NetworkExtension.NEFilterFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B520 /* #309 'NEFilterNewFlowVerdict' => 'NetworkExtension.NEFilterNewFlowVerdict, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B620 /* #310 'NEFilterPacketContext' => 'NetworkExtension.NEFilterPacketContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D120 /* #311 'NEProvider' => 'NetworkExtension.NEProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B920 /* #312 'NEFilterProvider' => 'NetworkExtension.NEFilterProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B720 /* #313 'NEFilterPacketProvider' => 'NetworkExtension.NEFilterPacketProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4BA20 /* #314 'NEFilterProviderConfiguration' => 'NetworkExtension.NEFilterProviderConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4BB20 /* #315 'NEFilterReport' => 'NetworkExtension.NEFilterReport, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4BD20 /* #316 'NEFilterRule' => 'NetworkExtension.NEFilterRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4BE20 /* #317 'NEFilterSettings' => 'NetworkExtension.NEFilterSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4BF20 /* #318 'NEFilterSocketFlow' => 'NetworkExtension.NEFilterSocketFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C120 /* #319 'NEFlowMetaData' => 'NetworkExtension.NEFlowMetaData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C220 /* #320 'NEIPv4Route' => 'NetworkExtension.NEIPv4Route, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C320 /* #321 'NEIPv4Settings' => 'NetworkExtension.NEIPv4Settings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C420 /* #322 'NEIPv6Route' => 'NetworkExtension.NEIPv6Route, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C520 /* #323 'NEIPv6Settings' => 'NetworkExtension.NEIPv6Settings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C620 /* #324 'NENetworkRule' => 'NetworkExtension.NENetworkRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4C820 /* #325 'NEOnDemandRule' => 'NetworkExtension.NEOnDemandRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CA20 /* #326 'NEOnDemandRuleConnect' => 'NetworkExtension.NEOnDemandRuleConnect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CB20 /* #327 'NEOnDemandRuleDisconnect' => 'NetworkExtension.NEOnDemandRuleDisconnect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CC20 /* #328 'NEOnDemandRuleEvaluateConnection' => 'NetworkExtension.NEOnDemandRuleEvaluateConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CD20 /* #329 'NEOnDemandRuleIgnore' => 'NetworkExtension.NEOnDemandRuleIgnore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4CF20 /* #330 'NEPacket' => 'NetworkExtension.NEPacket, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D320 /* #331 'NEProxyServer' => 'NetworkExtension.NEProxyServer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D420 /* #332 'NEProxySettings' => 'NetworkExtension.NEProxySettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D720 /* #333 'NETransparentProxyNetworkSettings' => 'NetworkExtension.NETransparentProxyNetworkSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DD20 /* #334 'NETunnelProviderProtocol' => 'NetworkExtension.NETunnelProviderProtocol, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E020 /* #335 'NEVPNConnection' => 'NetworkExtension.NEVpnConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DF20 /* #336 'NETunnelProviderSession' => 'NetworkExtension.NETunnelProviderSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4E920 /* #337 'NEVPNIKEv2SecurityAssociationParameters' => 'NetworkExtension.NEVpnIke2SecurityAssociationParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4EE20 /* #338 'NEVPNProtocolIPSec' => 'NetworkExtension.NEVpnProtocolIpSec, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4ED20 /* #339 'NEVPNProtocolIKEv2' => 'NetworkExtension.NEVpnProtocolIke2, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F020 /* #340 'NWBonjourServiceEndpoint' => 'NetworkExtension.NWBonjourServiceEndpoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F820 /* #341 'NWTLSParameters' => 'NetworkExtension.NWTlsParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x50220 /* #342 'NLGazetteer' => 'NaturalLanguage.NLGazetteer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x50520 /* #343 'NLModel' => 'NaturalLanguage.NLModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x50620 /* #344 'NLModelConfiguration' => 'NaturalLanguage.NLModelConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x50E20 /* #345 'NLTokenizer' => 'NaturalLanguage.NLTokenizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51420 /* #346 'MCPeerID' => 'MultipeerConnectivity.MCPeerID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51520 /* #347 'MCAdvertiserAssistant' => 'MultipeerConnectivity.MCAdvertiserAssistant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51A20 /* #348 'MCAdvertiserAssistantDelegate' => 'MultipeerConnectivity.MCAdvertiserAssistantDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51B20 /* #349 'MCBrowserViewController' => 'MultipeerConnectivity.MCBrowserViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51F20 /* #350 'MCBrowserViewControllerDelegate' => 'MultipeerConnectivity.MCBrowserViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x52320 /* #351 'MCNearbyServiceAdvertiser' => 'MultipeerConnectivity.MCNearbyServiceAdvertiser, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x52720 /* #352 'MCNearbyServiceAdvertiserDelegate' => 'MultipeerConnectivity.MCNearbyServiceAdvertiserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x52820 /* #353 'MCNearbyServiceBrowser' => 'MultipeerConnectivity.MCNearbyServiceBrowser, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x52C20 /* #354 'MCNearbyServiceBrowserDelegate' => 'MultipeerConnectivity.MCNearbyServiceBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53020 /* #355 'MCSessionDelegate' => 'MultipeerConnectivity.MCSessionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53620 /* #356 'MDLAnimatedValue' => 'ModelIO.MDLAnimatedValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53520 /* #357 'MDLAnimatedQuaternion' => 'ModelIO.MDLAnimatedQuaternion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53720 /* #358 'MDLAnimatedScalarArray' => 'ModelIO.MDLAnimatedScalarArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53820 /* #359 'MDLAnimatedVector3Array' => 'ModelIO.MDLAnimatedVector3Array, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53920 /* #360 'MDLAnimatedQuaternionArray' => 'ModelIO.MDLAnimatedQuaternionArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53A20 /* #361 'MDLAnimatedScalar' => 'ModelIO.MDLAnimatedScalar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53B20 /* #362 'MDLAnimatedVector2' => 'ModelIO.MDLAnimatedVector2, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53C20 /* #363 'MDLAnimatedVector3' => 'ModelIO.MDLAnimatedVector3, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53D20 /* #364 'MDLAnimatedVector4' => 'ModelIO.MDLAnimatedVector4, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53E20 /* #365 'MDLAnimatedMatrix4x4' => 'ModelIO.MDLAnimatedMatrix4x4, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x53F20 /* #366 'MDLMatrix4x4Array' => 'ModelIO.MDLMatrix4x4Array, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54120 /* #367 'MDLAsset' => 'ModelIO.MDLAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59320 /* #368 'MDLTexture' => 'ModelIO.MDLTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54320 /* #369 'MDLNoiseTexture' => 'ModelIO.MDLNoiseTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54420 /* #370 'MDLTransform' => 'ModelIO.MDLTransform, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54620 /* #371 'MDLVertexDescriptor' => 'ModelIO.MDLVertexDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55B20 /* #372 'MDLAnimationBindComponent' => 'ModelIO.MDLAnimationBindComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58220 /* #373 'MDLObject' => 'ModelIO.MDLObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56820 /* #374 'MDLLight' => 'ModelIO.MDLLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58A20 /* #375 'MDLPhysicallyPlausibleLight' => 'ModelIO.MDLPhysicallyPlausibleLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55C20 /* #376 'MDLAreaLight' => 'ModelIO.MDLAreaLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x55F20 /* #377 'MDLBundleAssetResolver' => 'ModelIO.MDLBundleAssetResolver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56020 /* #378 'MDLCamera' => 'ModelIO.MDLCamera, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56120 /* #379 'MDLCheckerboardTexture' => 'ModelIO.MDLCheckerboardTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56220 /* #380 'MDLColorSwatchTexture' => 'ModelIO.MDLColorSwatchTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56920 /* #381 'MDLLightProbe' => 'ModelIO.MDLLightProbe, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56D20 /* #382 'MDLLightProbeIrradianceDataSource' => 'ModelIO.MDLLightProbeIrradianceDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56E20 /* #383 'MDLMaterial' => 'ModelIO.MDLMaterial, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x56F20 /* #384 'MDLMaterialProperty' => 'ModelIO.MDLMaterialProperty, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57020 /* #385 'MDLMaterialPropertyConnection' => 'ModelIO.MDLMaterialPropertyConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57220 /* #386 'MDLMaterialPropertyNode' => 'ModelIO.MDLMaterialPropertyNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57120 /* #387 'MDLMaterialPropertyGraph' => 'ModelIO.MDLMaterialPropertyGraph, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57820 /* #388 'MDLMeshBufferData' => 'ModelIO.MDLMeshBufferData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57920 /* #389 'MDLMeshBufferDataAllocator' => 'ModelIO.MDLMeshBufferDataAllocator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57A20 /* #390 'MDLMeshBufferMap' => 'ModelIO.MDLMeshBufferMap, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x57E20 /* #391 'MDLMeshBufferZoneDefault' => 'ModelIO.MDLMeshBufferZoneDefault, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58120 /* #392 'MDLNormalMapTexture' => 'ModelIO.MDLNormalMapTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58320 /* #393 'MDLObjectContainer' => 'ModelIO.MDLObjectContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58720 /* #394 'MDLPackedJointAnimation' => 'ModelIO.MDLPackedJointAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58820 /* #395 'MDLPathAssetResolver' => 'ModelIO.MDLPathAssetResolver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58920 /* #396 'MDLPhotometricLight' => 'ModelIO.MDLPhotometricLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58D20 /* #397 'MDLScatteringFunction' => 'ModelIO.MDLScatteringFunction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58B20 /* #398 'MDLPhysicallyPlausibleScatteringFunction' => 'ModelIO.MDLPhysicallyPlausibleScatteringFunction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58C20 /* #399 'MDLRelativeAssetResolver' => 'ModelIO.MDLRelativeAssetResolver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58E20 /* #400 'MDLSkeleton' => 'ModelIO.MDLSkeleton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x58F20 /* #401 'MDLSkyCubeTexture' => 'ModelIO.MDLSkyCubeTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59020 /* #402 'MDLStereoscopicCamera' => 'ModelIO.MDLStereoscopicCamera, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59120 /* #403 'MDLSubmesh' => 'ModelIO.MDLSubmesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59220 /* #404 'MDLSubmeshTopology' => 'ModelIO.MDLSubmeshTopology, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59420 /* #405 'MDLTextureFilter' => 'ModelIO.MDLTextureFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59520 /* #406 'MDLTextureSampler' => 'ModelIO.MDLTextureSampler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59820 /* #407 'MDLTransformMatrixOp' => 'ModelIO.MDLTransformMatrixOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59C20 /* #408 'MDLTransformOrientOp' => 'ModelIO.MDLTransformOrientOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59D20 /* #409 'MDLTransformRotateOp' => 'ModelIO.MDLTransformRotateOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59E20 /* #410 'MDLTransformRotateXOp' => 'ModelIO.MDLTransformRotateXOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x59F20 /* #411 'MDLTransformRotateYOp' => 'ModelIO.MDLTransformRotateYOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A020 /* #412 'MDLTransformRotateZOp' => 'ModelIO.MDLTransformRotateZOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A120 /* #413 'MDLTransformScaleOp' => 'ModelIO.MDLTransformScaleOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A220 /* #414 'MDLTransformStack' => 'ModelIO.MDLTransformStack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A320 /* #415 'MDLTransformTranslateOp' => 'ModelIO.MDLTransformTranslateOp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A420 /* #416 'MDLURLTexture' => 'ModelIO.MDLUrlTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A520 /* #417 'MDLVertexAttribute' => 'ModelIO.MDLVertexAttribute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A620 /* #418 'MDLVertexAttributeData' => 'ModelIO.MDLVertexAttributeData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A820 /* #419 'MDLVertexBufferLayout' => 'ModelIO.MDLVertexBufferLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5A920 /* #420 'MDLVoxelArray' => 'ModelIO.MDLVoxelArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EE20 /* #421 'MPSNNFilterNode' => 'MetalPerformanceShaders.MPSNNFilterNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61420 /* #422 'MPSCNNConvolutionNode' => 'MetalPerformanceShaders.MPSCnnConvolutionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AC20 /* #423 'MPSCNNConvolutionTransposeNode' => 'MetalPerformanceShaders.MPSCnnConvolutionTransposeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E420 /* #424 'MPSKernel' => 'MetalPerformanceShaders.MPSKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74320 /* #425 'MPSUnaryImageKernel' => 'MetalPerformanceShaders.MPSUnaryImageKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AE20 /* #426 'MPSImageScale' => 'MetalPerformanceShaders.MPSImageScale, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5AF20 /* #427 'MPSCNNConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnConvolutionDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63420 /* #428 'MPSCNNKernel' => 'MetalPerformanceShaders.MPSCnnKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64420 /* #429 'MPSCNNNeuron' => 'MetalPerformanceShaders.MPSCnnNeuron, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B020 /* #430 'MPSCNNNeuronPReLU' => 'MetalPerformanceShaders.MPSCnnNeuronPReLU, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B120 /* #431 'MPSCNNBinaryConvolution' => 'MetalPerformanceShaders.MPSCnnBinaryConvolution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B220 /* #432 'MPSCNNBinaryFullyConnected' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnected, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5B420 /* #433 'MPSStateResourceList' => 'MetalPerformanceShaders.MPSStateResourceList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E520 /* #434 'MPSImageDilate' => 'MetalPerformanceShaders.MPSImageDilate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E620 /* #435 'MPSImageErode' => 'MetalPerformanceShaders.MPSImageErode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E720 /* #436 'MPSImageThresholdBinary' => 'MetalPerformanceShaders.MPSImageThresholdBinary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E820 /* #437 'MPSImageThresholdBinaryInverse' => 'MetalPerformanceShaders.MPSImageThresholdBinaryInverse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5E920 /* #438 'MPSImageThresholdTruncate' => 'MetalPerformanceShaders.MPSImageThresholdTruncate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EA20 /* #439 'MPSImageThresholdToZero' => 'MetalPerformanceShaders.MPSImageThresholdToZero, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EB20 /* #440 'MPSImageThresholdToZeroInverse' => 'MetalPerformanceShaders.MPSImageThresholdToZeroInverse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EC20 /* #441 'MPSImageSobel' => 'MetalPerformanceShaders.MPSImageSobel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5ED20 /* #442 'MPSCNNConvolution' => 'MetalPerformanceShaders.MPSCnnConvolution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EE20 /* #443 'MPSCNNFullyConnected' => 'MetalPerformanceShaders.MPSCnnFullyConnected, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5EF20 /* #444 'MPSImageConversion' => 'MetalPerformanceShaders.MPSImageConversion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F020 /* #445 'MPSImagePyramid' => 'MetalPerformanceShaders.MPSImagePyramid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F120 /* #446 'MPSImageGaussianPyramid' => 'MetalPerformanceShaders.MPSImageGaussianPyramid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F220 /* #447 'MPSImageLaplacianPyramid' => 'MetalPerformanceShaders.MPSImageLaplacianPyramid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F320 /* #448 'MPSImageLaplacianPyramidSubtract' => 'MetalPerformanceShaders.MPSImageLaplacianPyramidSubtract, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F420 /* #449 'MPSImageLaplacianPyramidAdd' => 'MetalPerformanceShaders.MPSImageLaplacianPyramidAdd, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F520 /* #450 'MPSCNNBinaryConvolutionNode' => 'MetalPerformanceShaders.MPSCnnBinaryConvolutionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F620 /* #451 'MPSCNNBinaryFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnectedNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F820 /* #452 'MPSAccelerationStructureGroup' => 'MetalPerformanceShaders.MPSAccelerationStructureGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F920 /* #453 'MPSBinaryImageKernel' => 'MetalPerformanceShaders.MPSBinaryImageKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60A20 /* #454 'MPSCNNBinaryKernel' => 'MetalPerformanceShaders.MPSCnnBinaryKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FC20 /* #455 'MPSCNNArithmetic' => 'MetalPerformanceShaders.MPSCnnArithmetic, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FA20 /* #456 'MPSCNNAdd' => 'MetalPerformanceShaders.MPSCnnAdd, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62A20 /* #457 'MPSCNNGradientKernel' => 'MetalPerformanceShaders.MPSCnnGradientKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FD20 /* #458 'MPSCNNArithmeticGradient' => 'MetalPerformanceShaders.MPSCnnArithmeticGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FB20 /* #459 'MPSCNNAddGradient' => 'MetalPerformanceShaders.MPSCnnAddGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73E20 /* #460 'MPSState' => 'MetalPerformanceShaders.MPSState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E520 /* #461 'MPSNNBinaryGradientState' => 'MetalPerformanceShaders.MPSNNBinaryGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FE20 /* #462 'MPSCNNArithmeticGradientState' => 'MetalPerformanceShaders.MPSCnnArithmeticGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5FF20 /* #463 'MPSCNNBatchNormalization' => 'MetalPerformanceShaders.MPSCnnBatchNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60320 /* #464 'Xamarin_Mac__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60420 /* #465 'MPSCNNBatchNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EF20 /* #466 'MPSNNGradientFilterNode' => 'MetalPerformanceShaders.MPSNNGradientFilterNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60520 /* #467 'MPSCNNBatchNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60620 /* #468 'MPSCNNBatchNormalizationNode' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F020 /* #469 'MPSNNGradientState' => 'MetalPerformanceShaders.MPSNNGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60720 /* #470 'MPSCNNBatchNormalizationState' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60820 /* #471 'MPSCNNBatchNormalizationStatistics' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationStatistics, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60920 /* #472 'MPSCNNBatchNormalizationStatisticsGradient' => 'MetalPerformanceShaders.MPSCnnBatchNormalizationStatisticsGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x60E20 /* #473 'MPSCNNConvolutionDataSource' => 'MetalPerformanceShaders.MPSCnnConvolutionDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61020 /* #474 'MPSCNNConvolutionGradient' => 'MetalPerformanceShaders.MPSCnnConvolutionGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61120 /* #475 'MPSCNNConvolutionGradientNode' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61220 /* #476 'MPSCNNConvolutionGradientState' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72E20 /* #477 'MPSNNStateNode' => 'MetalPerformanceShaders.MPSNNStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F120 /* #478 'MPSNNGradientStateNode' => 'MetalPerformanceShaders.MPSNNGradientStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61320 /* #479 'MPSCNNConvolutionGradientStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionGradientStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61520 /* #480 'MPSCNNConvolutionState' => 'MetalPerformanceShaders.MPSCnnConvolutionState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61620 /* #481 'MPSCNNConvolutionStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61720 /* #482 'MPSCNNConvolutionTranspose' => 'MetalPerformanceShaders.MPSCnnConvolutionTranspose, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61820 /* #483 'MPSCNNConvolutionWeightsAndBiasesState' => 'MetalPerformanceShaders.MPSCnnConvolutionWeightsAndBiasesState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61920 /* #484 'MPSCNNCrossChannelNormalization' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61A20 /* #485 'MPSCNNCrossChannelNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61B20 /* #486 'MPSCNNCrossChannelNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66520 /* #487 'MPSCNNNormalizationNode' => 'MetalPerformanceShaders.MPSCnnNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61C20 /* #488 'MPSCNNCrossChannelNormalizationNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61D20 /* #489 'MPSCNNDepthWiseConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnDepthWiseConvolutionDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66620 /* #490 'MPSCNNPooling' => 'MetalPerformanceShaders.MPSCnnPooling, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61E20 /* #491 'MPSCNNDilatedPoolingMax' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66B20 /* #492 'MPSCNNPoolingGradient' => 'MetalPerformanceShaders.MPSCnnPoolingGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x61F20 /* #493 'MPSCNNDilatedPoolingMaxGradient' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66C20 /* #494 'MPSCNNPoolingGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62020 /* #495 'MPSCNNDilatedPoolingMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62120 /* #496 'MPSCNNDilatedPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62220 /* #497 'MPSCNNDivide' => 'MetalPerformanceShaders.MPSCnnDivide, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62320 /* #498 'MPSCNNDropout' => 'MetalPerformanceShaders.MPSCnnDropout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62420 /* #499 'MPSCNNDropoutGradient' => 'MetalPerformanceShaders.MPSCnnDropoutGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62520 /* #500 'MPSCNNDropoutGradientNode' => 'MetalPerformanceShaders.MPSCnnDropoutGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62620 /* #501 'MPSCNNDropoutGradientState' => 'MetalPerformanceShaders.MPSCnnDropoutGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62720 /* #502 'MPSCNNDropoutNode' => 'MetalPerformanceShaders.MPSCnnDropoutNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62820 /* #503 'MPSCNNFullyConnectedGradient' => 'MetalPerformanceShaders.MPSCnnFullyConnectedGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62920 /* #504 'MPSCNNFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnFullyConnectedNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62B20 /* #505 'MPSCNNInstanceNormalization' => 'MetalPerformanceShaders.MPSCnnInstanceNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x62F20 /* #506 'Xamarin_Mac__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63020 /* #507 'MPSCNNInstanceNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63120 /* #508 'MPSCNNInstanceNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63220 /* #509 'MPSCNNInstanceNormalizationGradientState' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationGradientState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63320 /* #510 'MPSCNNInstanceNormalizationNode' => 'MetalPerformanceShaders.MPSCnnInstanceNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63520 /* #511 'MPSCNNLocalContrastNormalization' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63620 /* #512 'MPSCNNLocalContrastNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63720 /* #513 'MPSCNNLocalContrastNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63820 /* #514 'MPSCNNLocalContrastNormalizationNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63920 /* #515 'MPSCNNLogSoftMax' => 'MetalPerformanceShaders.MPSCnnLogSoftMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63A20 /* #516 'MPSCNNLogSoftMaxGradient' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63B20 /* #517 'MPSCNNLogSoftMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63C20 /* #518 'MPSCNNLogSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63D20 /* #519 'MPSCNNLoss' => 'MetalPerformanceShaders.MPSCnnLoss, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63E20 /* #520 'MPSCNNLossDataDescriptor' => 'MetalPerformanceShaders.MPSCnnLossDataDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x63F20 /* #521 'MPSCNNLossDescriptor' => 'MetalPerformanceShaders.MPSCnnLossDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64020 /* #522 'MPSCNNLossLabels' => 'MetalPerformanceShaders.MPSCnnLossLabels, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64120 /* #523 'MPSCNNLossNode' => 'MetalPerformanceShaders.MPSCnnLossNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64220 /* #524 'MPSCNNMultiply' => 'MetalPerformanceShaders.MPSCnnMultiply, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64320 /* #525 'MPSCNNMultiplyGradient' => 'MetalPerformanceShaders.MPSCnnMultiplyGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64520 /* #526 'MPSCNNNeuronAbsolute' => 'MetalPerformanceShaders.MPSCnnNeuronAbsolute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65320 /* #527 'MPSCNNNeuronNode' => 'MetalPerformanceShaders.MPSCnnNeuronNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64620 /* #528 'MPSCNNNeuronAbsoluteNode' => 'MetalPerformanceShaders.MPSCnnNeuronAbsoluteNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64720 /* #529 'MPSCNNNeuronELU' => 'MetalPerformanceShaders.MPSCnnNeuronElu, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64820 /* #530 'MPSCNNNeuronELUNode' => 'MetalPerformanceShaders.MPSCnnNeuronEluNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64920 /* #531 'MPSCNNNeuronExponential' => 'MetalPerformanceShaders.MPSCnnNeuronExponential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64A20 /* #532 'MPSCNNNeuronExponentialNode' => 'MetalPerformanceShaders.MPSCnnNeuronExponentialNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64B20 /* #533 'MPSCNNNeuronGradient' => 'MetalPerformanceShaders.MPSCnnNeuronGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64C20 /* #534 'MPSCNNNeuronGradientNode' => 'MetalPerformanceShaders.MPSCnnNeuronGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64D20 /* #535 'MPSCNNNeuronHardSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64E20 /* #536 'MPSCNNNeuronHardSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoidNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x64F20 /* #537 'MPSCNNNeuronLinear' => 'MetalPerformanceShaders.MPSCnnNeuronLinear, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65020 /* #538 'MPSCNNNeuronLinearNode' => 'MetalPerformanceShaders.MPSCnnNeuronLinearNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65120 /* #539 'MPSCNNNeuronLogarithm' => 'MetalPerformanceShaders.MPSCnnNeuronLogarithm, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65220 /* #540 'MPSCNNNeuronLogarithmNode' => 'MetalPerformanceShaders.MPSCnnNeuronLogarithmNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65420 /* #541 'MPSCNNNeuronPower' => 'MetalPerformanceShaders.MPSCnnNeuronPower, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65520 /* #542 'MPSCNNNeuronPowerNode' => 'MetalPerformanceShaders.MPSCnnNeuronPowerNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65620 /* #543 'MPSCNNNeuronPReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronPReLUNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65720 /* #544 'MPSCNNNeuronReLU' => 'MetalPerformanceShaders.MPSCnnNeuronReLU, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65820 /* #545 'MPSCNNNeuronReLUN' => 'MetalPerformanceShaders.MPSCnnNeuronReLun, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65920 /* #546 'MPSCNNNeuronReLUNNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLunNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65A20 /* #547 'MPSCNNNeuronReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLUNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65B20 /* #548 'MPSCNNNeuronSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65C20 /* #549 'MPSCNNNeuronSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoidNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65D20 /* #550 'MPSCNNNeuronSoftPlus' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlus, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65E20 /* #551 'MPSCNNNeuronSoftPlusNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlusNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x65F20 /* #552 'MPSCNNNeuronSoftSign' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSign, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66020 /* #553 'MPSCNNNeuronSoftSignNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSignNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66120 /* #554 'MPSCNNNeuronTanH' => 'MetalPerformanceShaders.MPSCnnNeuronTanH, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66220 /* #555 'MPSCNNNeuronTanHNode' => 'MetalPerformanceShaders.MPSCnnNeuronTanHNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66320 /* #556 'MPSCNNNormalizationGammaAndBetaState' => 'MetalPerformanceShaders.MPSCnnNormalizationGammaAndBetaState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66420 /* #557 'MPSCNNNormalizationMeanAndVarianceState' => 'MetalPerformanceShaders.MPSCnnNormalizationMeanAndVarianceState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66720 /* #558 'MPSCNNPoolingAverage' => 'MetalPerformanceShaders.MPSCnnPoolingAverage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66820 /* #559 'MPSCNNPoolingAverageGradient' => 'MetalPerformanceShaders.MPSCnnPoolingAverageGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66920 /* #560 'MPSCNNPoolingAverageGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67520 /* #561 'MPSCNNPoolingNode' => 'MetalPerformanceShaders.MPSCnnPoolingNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66A20 /* #562 'MPSCNNPoolingAverageNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66D20 /* #563 'MPSCNNPoolingL2Norm' => 'MetalPerformanceShaders.MPSCnnPoolingL2Norm, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66E20 /* #564 'MPSCNNPoolingL2NormGradient' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x66F20 /* #565 'MPSCNNPoolingL2NormGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67020 /* #566 'MPSCNNPoolingL2NormNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67120 /* #567 'MPSCNNPoolingMax' => 'MetalPerformanceShaders.MPSCnnPoolingMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67220 /* #568 'MPSCNNPoolingMaxGradient' => 'MetalPerformanceShaders.MPSCnnPoolingMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67320 /* #569 'MPSCNNPoolingMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67420 /* #570 'MPSCNNPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67620 /* #571 'MPSCNNSoftMax' => 'MetalPerformanceShaders.MPSCnnSoftMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67720 /* #572 'MPSCNNSoftMaxGradient' => 'MetalPerformanceShaders.MPSCnnSoftMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67820 /* #573 'MPSCNNSoftMaxGradientNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67920 /* #574 'MPSCNNSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67A20 /* #575 'MPSCNNSpatialNormalization' => 'MetalPerformanceShaders.MPSCnnSpatialNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67B20 /* #576 'MPSCNNSpatialNormalizationGradient' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67C20 /* #577 'MPSCNNSpatialNormalizationGradientNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67D20 /* #578 'MPSCNNSpatialNormalizationNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67E20 /* #579 'MPSCNNSubPixelConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnSubPixelConvolutionDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x67F20 /* #580 'MPSCNNSubtract' => 'MetalPerformanceShaders.MPSCnnSubtract, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68020 /* #581 'MPSCNNSubtractGradient' => 'MetalPerformanceShaders.MPSCnnSubtractGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68120 /* #582 'MPSCNNUpsampling' => 'MetalPerformanceShaders.MPSCnnUpsampling, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68220 /* #583 'MPSCNNUpsamplingBilinear' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinear, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68620 /* #584 'MPSCNNUpsamplingGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68320 /* #585 'MPSCNNUpsamplingBilinearGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68420 /* #586 'MPSCNNUpsamplingBilinearGradientNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68520 /* #587 'MPSCNNUpsamplingBilinearNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68720 /* #588 'MPSCNNUpsamplingNearest' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68820 /* #589 'MPSCNNUpsamplingNearestGradient' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68920 /* #590 'MPSCNNUpsamplingNearestGradientNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68A20 /* #591 'MPSCNNUpsamplingNearestNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68B20 /* #592 'MPSCNNYOLOLoss' => 'MetalPerformanceShaders.MPSCnnYoloLoss, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68C20 /* #593 'MPSCNNYOLOLossDescriptor' => 'MetalPerformanceShaders.MPSCnnYoloLossDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x68D20 /* #594 'MPSCNNYOLOLossNode' => 'MetalPerformanceShaders.MPSCnnYoloLossNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73620 /* #595 'MPSRNNDescriptor' => 'MetalPerformanceShaders.MPSRnnDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69020 /* #596 'MPSGRUDescriptor' => 'MetalPerformanceShaders.MPSGRUDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69320 /* #597 'MPSImage' => 'MetalPerformanceShaders.MPSImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69A20 /* #598 'MPSImageArithmetic' => 'MetalPerformanceShaders.MPSImageArithmetic, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69420 /* #599 'MPSImageAdd' => 'MetalPerformanceShaders.MPSImageAdd, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69820 /* #600 'MPSImageAreaMax' => 'MetalPerformanceShaders.MPSImageAreaMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69920 /* #601 'MPSImageAreaMin' => 'MetalPerformanceShaders.MPSImageAreaMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69B20 /* #602 'MPSImageBilinearScale' => 'MetalPerformanceShaders.MPSImageBilinearScale, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69C20 /* #603 'MPSImageBox' => 'MetalPerformanceShaders.MPSImageBox, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69D20 /* #604 'MPSImageConvolution' => 'MetalPerformanceShaders.MPSImageConvolution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69E20 /* #605 'MPSImageCopyToMatrix' => 'MetalPerformanceShaders.MPSImageCopyToMatrix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x69F20 /* #606 'MPSImageDescriptor' => 'MetalPerformanceShaders.MPSImageDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A020 /* #607 'MPSImageDivide' => 'MetalPerformanceShaders.MPSImageDivide, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A120 /* #608 'MPSImageEuclideanDistanceTransform' => 'MetalPerformanceShaders.MPSImageEuclideanDistanceTransform, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A220 /* #609 'MPSImageFindKeypoints' => 'MetalPerformanceShaders.MPSImageFindKeypoints, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A320 /* #610 'MPSImageGaussianBlur' => 'MetalPerformanceShaders.MPSImageGaussianBlur, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A420 /* #611 'MPSImageGuidedFilter' => 'MetalPerformanceShaders.MPSImageGuidedFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A520 /* #612 'MPSImageHistogram' => 'MetalPerformanceShaders.MPSImageHistogram, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A620 /* #613 'MPSImageHistogramEqualization' => 'MetalPerformanceShaders.MPSImageHistogramEqualization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A720 /* #614 'MPSImageHistogramSpecification' => 'MetalPerformanceShaders.MPSImageHistogramSpecification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A820 /* #615 'MPSImageIntegral' => 'MetalPerformanceShaders.MPSImageIntegral, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6A920 /* #616 'MPSImageIntegralOfSquares' => 'MetalPerformanceShaders.MPSImageIntegralOfSquares, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AA20 /* #617 'MPSImageLanczosScale' => 'MetalPerformanceShaders.MPSImageLanczosScale, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AB20 /* #618 'MPSImageLaplacian' => 'MetalPerformanceShaders.MPSImageLaplacian, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AC20 /* #619 'MPSImageMedian' => 'MetalPerformanceShaders.MPSImageMedian, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AD20 /* #620 'MPSImageMultiply' => 'MetalPerformanceShaders.MPSImageMultiply, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AE20 /* #621 'MPSImageNormalizedHistogram' => 'MetalPerformanceShaders.MPSImageNormalizedHistogram, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B720 /* #622 'MPSImageReduceUnary' => 'MetalPerformanceShaders.MPSImageReduceUnary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6AF20 /* #623 'MPSImageReduceColumnMax' => 'MetalPerformanceShaders.MPSImageReduceColumnMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B020 /* #624 'MPSImageReduceColumnMean' => 'MetalPerformanceShaders.MPSImageReduceColumnMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B120 /* #625 'MPSImageReduceColumnMin' => 'MetalPerformanceShaders.MPSImageReduceColumnMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B220 /* #626 'MPSImageReduceColumnSum' => 'MetalPerformanceShaders.MPSImageReduceColumnSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B320 /* #627 'MPSImageReduceRowMax' => 'MetalPerformanceShaders.MPSImageReduceRowMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B420 /* #628 'MPSImageReduceRowMean' => 'MetalPerformanceShaders.MPSImageReduceRowMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B520 /* #629 'MPSImageReduceRowMin' => 'MetalPerformanceShaders.MPSImageReduceRowMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6B620 /* #630 'MPSImageReduceRowSum' => 'MetalPerformanceShaders.MPSImageReduceRowSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BA20 /* #631 'MPSImageStatisticsMean' => 'MetalPerformanceShaders.MPSImageStatisticsMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BB20 /* #632 'MPSImageStatisticsMeanAndVariance' => 'MetalPerformanceShaders.MPSImageStatisticsMeanAndVariance, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BC20 /* #633 'MPSImageStatisticsMinAndMax' => 'MetalPerformanceShaders.MPSImageStatisticsMinAndMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BD20 /* #634 'MPSImageSubtract' => 'MetalPerformanceShaders.MPSImageSubtract, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6BE20 /* #635 'MPSImageTent' => 'MetalPerformanceShaders.MPSImageTent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C120 /* #636 'MPSImageTranspose' => 'MetalPerformanceShaders.MPSImageTranspose, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x5F720 /* #637 'MPSAccelerationStructure' => 'MetalPerformanceShaders.MPSAccelerationStructure, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C220 /* #638 'MPSInstanceAccelerationStructure' => 'MetalPerformanceShaders.MPSInstanceAccelerationStructure, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6920 /* #639 'NSCoder' => 'Foundation.NSCoder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8520 /* #640 'NSKeyedUnarchiver' => 'Foundation.NSKeyedUnarchiver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C320 /* #641 'MPSKeyedUnarchiver' => 'MetalPerformanceShaders.MPSKeyedUnarchiver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C420 /* #642 'MPSLSTMDescriptor' => 'MetalPerformanceShaders.MPSLSTMDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C520 /* #643 'MPSMatrix' => 'MetalPerformanceShaders.MPSMatrix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DD20 /* #644 'MPSMatrixUnaryKernel' => 'MetalPerformanceShaders.MPSMatrixUnaryKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C620 /* #645 'MPSMatrixBatchNormalization' => 'MetalPerformanceShaders.MPSMatrixBatchNormalization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C820 /* #646 'MPSMatrixBinaryKernel' => 'MetalPerformanceShaders.MPSMatrixBinaryKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C720 /* #647 'MPSMatrixBatchNormalizationGradient' => 'MetalPerformanceShaders.MPSMatrixBatchNormalizationGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6C920 /* #648 'MPSMatrixCopy' => 'MetalPerformanceShaders.MPSMatrixCopy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CA20 /* #649 'MPSMatrixCopyDescriptor' => 'MetalPerformanceShaders.MPSMatrixCopyDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CB20 /* #650 'MPSMatrixCopyToImage' => 'MetalPerformanceShaders.MPSMatrixCopyToImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CC20 /* #651 'MPSMatrixDecompositionCholesky' => 'MetalPerformanceShaders.MPSMatrixDecompositionCholesky, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CD20 /* #652 'MPSMatrixDecompositionLU' => 'MetalPerformanceShaders.MPSMatrixDecompositionLU, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CE20 /* #653 'MPSMatrixDescriptor' => 'MetalPerformanceShaders.MPSMatrixDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6CF20 /* #654 'MPSMatrixFindTopK' => 'MetalPerformanceShaders.MPSMatrixFindTopK, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D020 /* #655 'MPSMatrixFullyConnected' => 'MetalPerformanceShaders.MPSMatrixFullyConnected, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D120 /* #656 'MPSMatrixFullyConnectedGradient' => 'MetalPerformanceShaders.MPSMatrixFullyConnectedGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D720 /* #657 'MPSMatrixSoftMax' => 'MetalPerformanceShaders.MPSMatrixSoftMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D220 /* #658 'MPSMatrixLogSoftMax' => 'MetalPerformanceShaders.MPSMatrixLogSoftMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D820 /* #659 'MPSMatrixSoftMaxGradient' => 'MetalPerformanceShaders.MPSMatrixSoftMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D320 /* #660 'MPSMatrixLogSoftMaxGradient' => 'MetalPerformanceShaders.MPSMatrixLogSoftMaxGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D420 /* #661 'MPSMatrixMultiplication' => 'MetalPerformanceShaders.MPSMatrixMultiplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D520 /* #662 'MPSMatrixNeuron' => 'MetalPerformanceShaders.MPSMatrixNeuron, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D620 /* #663 'MPSMatrixNeuronGradient' => 'MetalPerformanceShaders.MPSMatrixNeuronGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6D920 /* #664 'MPSMatrixSolveCholesky' => 'MetalPerformanceShaders.MPSMatrixSolveCholesky, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DA20 /* #665 'MPSMatrixSolveLU' => 'MetalPerformanceShaders.MPSMatrixSolveLU, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DB20 /* #666 'MPSMatrixSolveTriangular' => 'MetalPerformanceShaders.MPSMatrixSolveTriangular, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DC20 /* #667 'MPSMatrixSum' => 'MetalPerformanceShaders.MPSMatrixSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DE20 /* #668 'MPSMatrixVectorMultiplication' => 'MetalPerformanceShaders.MPSMatrixVectorMultiplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E120 /* #669 'MPSNNArithmeticGradientNode' => 'MetalPerformanceShaders.MPSNNArithmeticGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6DF20 /* #670 'MPSNNAdditionGradientNode' => 'MetalPerformanceShaders.MPSNNAdditionGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E420 /* #671 'MPSNNBinaryArithmeticNode' => 'MetalPerformanceShaders.MPSNNBinaryArithmeticNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E020 /* #672 'MPSNNAdditionNode' => 'MetalPerformanceShaders.MPSNNAdditionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E620 /* #673 'MPSNNBinaryGradientStateNode' => 'MetalPerformanceShaders.MPSNNBinaryGradientStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E220 /* #674 'MPSNNArithmeticGradientStateNode' => 'MetalPerformanceShaders.MPSNNArithmeticGradientStateNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72C20 /* #675 'MPSNNScaleNode' => 'MetalPerformanceShaders.MPSNNScaleNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E320 /* #676 'MPSNNBilinearScaleNode' => 'MetalPerformanceShaders.MPSNNBilinearScaleNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E720 /* #677 'MPSNNCompare' => 'MetalPerformanceShaders.MPSNNCompare, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E820 /* #678 'MPSNNComparisonNode' => 'MetalPerformanceShaders.MPSNNComparisonNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6E920 /* #679 'MPSNNConcatenationGradientNode' => 'MetalPerformanceShaders.MPSNNConcatenationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EA20 /* #680 'MPSNNConcatenationNode' => 'MetalPerformanceShaders.MPSNNConcatenationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EB20 /* #681 'MPSNNCropAndResizeBilinear' => 'MetalPerformanceShaders.MPSNNCropAndResizeBilinear, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6EC20 /* #682 'MPSNNDefaultPadding' => 'MetalPerformanceShaders.MPSNNDefaultPadding, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6ED20 /* #683 'MPSNNDivisionNode' => 'MetalPerformanceShaders.MPSNNDivisionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F320 /* #684 'MPSNNImageNode' => 'MetalPerformanceShaders.MPSNNImageNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F420 /* #685 'MPSNNLabelsNode' => 'MetalPerformanceShaders.MPSNNLabelsNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F520 /* #686 'MPSNNLanczosScaleNode' => 'MetalPerformanceShaders.MPSNNLanczosScaleNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F620 /* #687 'MPSNNMultiplicationGradientNode' => 'MetalPerformanceShaders.MPSNNMultiplicationGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F720 /* #688 'MPSNNMultiplicationNode' => 'MetalPerformanceShaders.MPSNNMultiplicationNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F820 /* #689 'MPSNNNeuronDescriptor' => 'MetalPerformanceShaders.MPSNNNeuronDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F920 /* #690 'MPSNNOptimizer' => 'MetalPerformanceShaders.MPSNNOptimizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FA20 /* #691 'MPSNNOptimizerAdam' => 'MetalPerformanceShaders.MPSNNOptimizerAdam, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FB20 /* #692 'MPSNNOptimizerDescriptor' => 'MetalPerformanceShaders.MPSNNOptimizerDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FC20 /* #693 'MPSNNOptimizerRMSProp' => 'MetalPerformanceShaders.MPSNNOptimizerRmsProp, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FD20 /* #694 'MPSNNOptimizerStochasticGradientDescent' => 'MetalPerformanceShaders.MPSNNOptimizerStochasticGradientDescent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6FE20 /* #695 'MPSNNPad' => 'MetalPerformanceShaders.MPSNNPad, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70220 /* #696 'MPSNNPadGradient' => 'MetalPerformanceShaders.MPSNNPadGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70320 /* #697 'MPSNNPadGradientNode' => 'MetalPerformanceShaders.MPSNNPadGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70420 /* #698 'MPSNNPadNode' => 'MetalPerformanceShaders.MPSNNPadNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70520 /* #699 'MPSNNReduceBinary' => 'MetalPerformanceShaders.MPSNNReduceBinary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71620 /* #700 'MPSNNReduceUnary' => 'MetalPerformanceShaders.MPSNNReduceUnary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70620 /* #701 'MPSNNReduceColumnMax' => 'MetalPerformanceShaders.MPSNNReduceColumnMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70720 /* #702 'MPSNNReduceColumnMean' => 'MetalPerformanceShaders.MPSNNReduceColumnMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70820 /* #703 'MPSNNReduceColumnMin' => 'MetalPerformanceShaders.MPSNNReduceColumnMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70920 /* #704 'MPSNNReduceColumnSum' => 'MetalPerformanceShaders.MPSNNReduceColumnSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70A20 /* #705 'MPSNNReduceFeatureChannelsAndWeightsMean' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsAndWeightsMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70B20 /* #706 'MPSNNReduceFeatureChannelsAndWeightsSum' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsAndWeightsSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70C20 /* #707 'MPSNNReduceFeatureChannelsArgumentMax' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsArgumentMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70D20 /* #708 'MPSNNReduceFeatureChannelsArgumentMin' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsArgumentMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70E20 /* #709 'MPSNNReduceFeatureChannelsMax' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x70F20 /* #710 'MPSNNReduceFeatureChannelsMean' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71020 /* #711 'MPSNNReduceFeatureChannelsMin' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71120 /* #712 'MPSNNReduceFeatureChannelsSum' => 'MetalPerformanceShaders.MPSNNReduceFeatureChannelsSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71220 /* #713 'MPSNNReduceRowMax' => 'MetalPerformanceShaders.MPSNNReduceRowMax, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71320 /* #714 'MPSNNReduceRowMean' => 'MetalPerformanceShaders.MPSNNReduceRowMean, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71420 /* #715 'MPSNNReduceRowMin' => 'MetalPerformanceShaders.MPSNNReduceRowMin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71520 /* #716 'MPSNNReduceRowSum' => 'MetalPerformanceShaders.MPSNNReduceRowSum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73320 /* #717 'MPSNNUnaryReductionNode' => 'MetalPerformanceShaders.MPSNNUnaryReductionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71720 /* #718 'MPSNNReductionColumnMaxNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71820 /* #719 'MPSNNReductionColumnMeanNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMeanNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71920 /* #720 'MPSNNReductionColumnMinNode' => 'MetalPerformanceShaders.MPSNNReductionColumnMinNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71A20 /* #721 'MPSNNReductionColumnSumNode' => 'MetalPerformanceShaders.MPSNNReductionColumnSumNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71B20 /* #722 'MPSNNReductionFeatureChannelsArgumentMaxNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsArgumentMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71C20 /* #723 'MPSNNReductionFeatureChannelsArgumentMinNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsArgumentMinNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71D20 /* #724 'MPSNNReductionFeatureChannelsMaxNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71E20 /* #725 'MPSNNReductionFeatureChannelsMeanNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMeanNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x71F20 /* #726 'MPSNNReductionFeatureChannelsMinNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsMinNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72020 /* #727 'MPSNNReductionFeatureChannelsSumNode' => 'MetalPerformanceShaders.MPSNNReductionFeatureChannelsSumNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72120 /* #728 'MPSNNReductionRowMaxNode' => 'MetalPerformanceShaders.MPSNNReductionRowMaxNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72220 /* #729 'MPSNNReductionRowMeanNode' => 'MetalPerformanceShaders.MPSNNReductionRowMeanNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72320 /* #730 'MPSNNReductionRowMinNode' => 'MetalPerformanceShaders.MPSNNReductionRowMinNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72420 /* #731 'MPSNNReductionRowSumNode' => 'MetalPerformanceShaders.MPSNNReductionRowSumNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72520 /* #732 'MPSNNReductionSpatialMeanGradientNode' => 'MetalPerformanceShaders.MPSNNReductionSpatialMeanGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72620 /* #733 'MPSNNReductionSpatialMeanNode' => 'MetalPerformanceShaders.MPSNNReductionSpatialMeanNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72720 /* #734 'MPSNNReshape' => 'MetalPerformanceShaders.MPSNNReshape, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72820 /* #735 'MPSNNReshapeGradient' => 'MetalPerformanceShaders.MPSNNReshapeGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72920 /* #736 'MPSNNReshapeGradientNode' => 'MetalPerformanceShaders.MPSNNReshapeGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72A20 /* #737 'MPSNNReshapeNode' => 'MetalPerformanceShaders.MPSNNReshapeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72B20 /* #738 'MPSNNResizeBilinear' => 'MetalPerformanceShaders.MPSNNResizeBilinear, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72D20 /* #739 'MPSNNSlice' => 'MetalPerformanceShaders.MPSNNSlice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x72F20 /* #740 'MPSNNSubtractionGradientNode' => 'MetalPerformanceShaders.MPSNNSubtractionGradientNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73020 /* #741 'MPSNNSubtractionNode' => 'MetalPerformanceShaders.MPSNNSubtractionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73520 /* #742 'MPSRayIntersector' => 'MetalPerformanceShaders.MPSRayIntersector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73720 /* #743 'MPSRNNImageInferenceLayer' => 'MetalPerformanceShaders.MPSRnnImageInferenceLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73820 /* #744 'MPSRNNMatrixInferenceLayer' => 'MetalPerformanceShaders.MPSRnnMatrixInferenceLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73920 /* #745 'MPSRNNMatrixTrainingLayer' => 'MetalPerformanceShaders.MPSRnnMatrixTrainingLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73A20 /* #746 'MPSRNNMatrixTrainingState' => 'MetalPerformanceShaders.MPSRnnMatrixTrainingState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73B20 /* #747 'MPSRNNRecurrentImageState' => 'MetalPerformanceShaders.MPSRnnRecurrentImageState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73C20 /* #748 'MPSRNNRecurrentMatrixState' => 'MetalPerformanceShaders.MPSRnnRecurrentMatrixState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73D20 /* #749 'MPSRNNSingleGateDescriptor' => 'MetalPerformanceShaders.MPSRnnSingleGateDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x73F20 /* #750 'MPSTemporaryImage' => 'MetalPerformanceShaders.MPSTemporaryImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74020 /* #751 'MPSTemporaryMatrix' => 'MetalPerformanceShaders.MPSTemporaryMatrix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74420 /* #752 'MPSVector' => 'MetalPerformanceShaders.MPSVector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74120 /* #753 'MPSTemporaryVector' => 'MetalPerformanceShaders.MPSTemporaryVector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74220 /* #754 'MPSTriangleAccelerationStructure' => 'MetalPerformanceShaders.MPSTriangleAccelerationStructure, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74520 /* #755 'MPSVectorDescriptor' => 'MetalPerformanceShaders.MPSVectorDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74820 /* #756 'MTKMesh' => 'MetalKit.MTKMesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74920 /* #757 'MTKMeshBufferAllocator' => 'MetalKit.MTKMeshBufferAllocator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74B20 /* #758 'MTKMeshBuffer' => 'MetalKit.MTKMeshBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74D20 /* #759 'MTKSubmesh' => 'MetalKit.MTKSubmesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75520 /* #760 'MTKView' => 'MetalKit.MTKView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75820 /* #761 'MTKViewDelegate' => 'MetalKit.MTKViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x75C20 /* #762 'MTLSharedTextureHandle' => 'Metal.MTLSharedTextureHandle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76120 /* #763 'MTLRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLRenderPipelineColorAttachmentDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76220 /* #764 'MTLRenderPassColorAttachmentDescriptorArray' => 'Metal.MTLRenderPassColorAttachmentDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76320 /* #765 'MTLVertexAttributeDescriptorArray' => 'Metal.MTLVertexAttributeDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76420 /* #766 'MTLVertexBufferLayoutDescriptorArray' => 'Metal.MTLVertexBufferLayoutDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76520 /* #767 'MTLBufferLayoutDescriptorArray' => 'Metal.MTLBufferLayoutDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76620 /* #768 'MTLAttributeDescriptorArray' => 'Metal.MTLAttributeDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76720 /* #769 'MTLPipelineBufferDescriptorArray' => 'Metal.MTLPipelineBufferDescriptorArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76920 /* #770 'MTLRenderPassDescriptor' => 'Metal.MTLRenderPassDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x76A20 /* #771 'MTLVertexDescriptor' => 'Metal.MTLVertexDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x77F20 /* #772 'MTLArgument' => 'Metal.MTLArgument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78220 /* #773 'MTLArgumentDescriptor' => 'Metal.MTLArgumentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x83120 /* #774 'MTLType' => 'Metal.MTLType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78620 /* #775 'MTLArrayType' => 'Metal.MTLArrayType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78720 /* #776 'MTLAttribute' => 'Metal.MTLAttribute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x78820 /* #777 'MTLAttributeDescriptor' => 'Metal.MTLAttributeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79420 /* #778 'MTLBufferLayoutDescriptor' => 'Metal.MTLBufferLayoutDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79520 /* #779 'MTLCaptureDescriptor' => 'Metal.MTLCaptureDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79920 /* #780 'MTLCaptureManager' => 'Metal.MTLCaptureManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x79C20 /* #781 'Xamarin_Mac__Metal_MTLCaptureScope' => 'Metal.MTLCaptureScope, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AB20 /* #782 'MTLCompileOptions' => 'Metal.MTLCompileOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AE20 /* #783 'MTLComputePipelineDescriptor' => 'Metal.MTLComputePipelineDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7AF20 /* #784 'MTLComputePipelineReflection' => 'Metal.MTLComputePipelineReflection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7B920 /* #785 'MTLCounterSampleBufferDescriptor' => 'Metal.MTLCounterSampleBufferDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7C320 /* #786 'MTLDepthStencilDescriptor' => 'Metal.MTLDepthStencilDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7CC20 /* #787 'MTLDrawable' => 'Metal.MTLDrawable, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D520 /* #788 'MTLFunctionConstant' => 'Metal.MTLFunctionConstant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7D620 /* #789 'MTLFunctionConstantValues' => 'Metal.MTLFunctionConstantValues, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7DD20 /* #790 'MTLHeapDescriptor' => 'Metal.MTLHeapDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7E220 /* #791 'MTLIndirectCommandBufferDescriptor' => 'Metal.MTLIndirectCommandBufferDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F420 /* #792 'MTLPipelineBufferDescriptor' => 'Metal.MTLPipelineBufferDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7F720 /* #793 'MTLPointerType' => 'Metal.MTLPointerType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x7FF20 /* #794 'MTLRenderPassAttachmentDescriptor' => 'Metal.MTLRenderPassAttachmentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80020 /* #795 'MTLRenderPassColorAttachmentDescriptor' => 'Metal.MTLRenderPassColorAttachmentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80120 /* #796 'MTLRenderPassDepthAttachmentDescriptor' => 'Metal.MTLRenderPassDepthAttachmentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80220 /* #797 'MTLRenderPassStencilAttachmentDescriptor' => 'Metal.MTLRenderPassStencilAttachmentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80320 /* #798 'MTLRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLRenderPipelineColorAttachmentDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80420 /* #799 'MTLRenderPipelineDescriptor' => 'Metal.MTLRenderPipelineDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x80720 /* #800 'MTLRenderPipelineReflection' => 'Metal.MTLRenderPipelineReflection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81320 /* #801 'MTLSamplerDescriptor' => 'Metal.MTLSamplerDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81A20 /* #802 'MTLSharedEventHandle' => 'Metal.MTLSharedEventHandle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81B20 /* #803 'MTLSharedEventListener' => 'Metal.MTLSharedEventListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81C20 /* #804 'MTLStageInputOutputDescriptor' => 'Metal.MTLStageInputOutputDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x81D20 /* #805 'MTLStencilDescriptor' => 'Metal.MTLStencilDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x82320 /* #806 'MTLStructMember' => 'Metal.MTLStructMember, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x82420 /* #807 'MTLStructType' => 'Metal.MTLStructType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x82C20 /* #808 'MTLTextureDescriptor' => 'Metal.MTLTextureDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x82D20 /* #809 'MTLTextureReferenceType' => 'Metal.MTLTextureReferenceType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x83220 /* #810 'MTLVertexAttribute' => 'Metal.MTLVertexAttribute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x83320 /* #811 'MTLVertexAttributeDescriptor' => 'Metal.MTLVertexAttributeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x83420 /* #812 'MTLVertexBufferLayoutDescriptor' => 'Metal.MTLVertexBufferLayoutDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84720 /* #813 'MPNowPlayingInfoCenter' => 'MediaPlayer.MPNowPlayingInfoCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86720 /* #814 'MPRemoteCommandEvent' => 'MediaPlayer.MPRemoteCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84B20 /* #815 'MPChangeLanguageOptionCommandEvent' => 'MediaPlayer.MPChangeLanguageOptionCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86520 /* #816 'MPRemoteCommand' => 'MediaPlayer.MPRemoteCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84D20 /* #817 'MPChangePlaybackPositionCommand' => 'MediaPlayer.MPChangePlaybackPositionCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84E20 /* #818 'MPChangePlaybackPositionCommandEvent' => 'MediaPlayer.MPChangePlaybackPositionCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84F20 /* #819 'MPChangePlaybackRateCommand' => 'MediaPlayer.MPChangePlaybackRateCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85020 /* #820 'MPChangePlaybackRateCommandEvent' => 'MediaPlayer.MPChangePlaybackRateCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85120 /* #821 'MPChangeRepeatModeCommand' => 'MediaPlayer.MPChangeRepeatModeCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85220 /* #822 'MPChangeRepeatModeCommandEvent' => 'MediaPlayer.MPChangeRepeatModeCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85320 /* #823 'MPChangeShuffleModeCommand' => 'MediaPlayer.MPChangeShuffleModeCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85420 /* #824 'MPChangeShuffleModeCommandEvent' => 'MediaPlayer.MPChangeShuffleModeCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85520 /* #825 'MPContentItem' => 'MediaPlayer.MPContentItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85820 /* #826 'MPFeedbackCommand' => 'MediaPlayer.MPFeedbackCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85920 /* #827 'MPFeedbackCommandEvent' => 'MediaPlayer.MPFeedbackCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85B20 /* #828 'MPMediaItem' => 'MediaPlayer.MPMediaItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85C20 /* #829 'MPMediaItemArtwork' => 'MediaPlayer.MPMediaItemArtwork, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85E20 /* #830 'MPNowPlayingInfoLanguageOption' => 'MediaPlayer.MPNowPlayingInfoLanguageOption, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x85F20 /* #831 'MPNowPlayingInfoLanguageOptionGroup' => 'MediaPlayer.MPNowPlayingInfoLanguageOptionGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86320 /* #832 'MPRatingCommand' => 'MediaPlayer.MPRatingCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86420 /* #833 'MPRatingCommandEvent' => 'MediaPlayer.MPRatingCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86620 /* #834 'MPRemoteCommandCenter' => 'MediaPlayer.MPRemoteCommandCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86A20 /* #835 'MPSeekCommandEvent' => 'MediaPlayer.MPSeekCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x86D20 /* #836 'MPSkipIntervalCommandEvent' => 'MediaPlayer.MPSkipIntervalCommandEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D720 /* #837 'MKShape' => 'MapKit.MKShape, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87F20 /* #838 'MKMultiPoint' => 'MapKit.MKMultiPoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88220 /* #839 'MKPolyline' => 'MapKit.MKPolyline, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87A20 /* #840 'MKGeodesicPolyline' => 'MapKit.MKGeodesicPolyline, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87E20 /* #841 'MKMapItem' => 'MapKit.MKMapItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88120 /* #842 'MKPolygon' => 'MapKit.MKPolygon, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88D20 /* #843 'MKAnnotation' => 'MapKit.MKAnnotation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x88E20 /* #844 'MKAnnotationView' => 'MapKit.MKAnnotationView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89120 /* #845 'MKCircle' => 'MapKit.MKCircle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CA20 /* #846 'MKOverlayRenderer' => 'MapKit.MKOverlayRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C920 /* #847 'MKOverlayPathRenderer' => 'MapKit.MKOverlayPathRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89220 /* #848 'MKCircleRenderer' => 'MapKit.MKCircleRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89320 /* #849 'MKClusterAnnotation' => 'MapKit.MKClusterAnnotation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89420 /* #850 'MKDirectionsRequest' => 'MapKit.MKDirectionsRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89520 /* #851 'MKDirectionsResponse' => 'MapKit.MKDirectionsResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7C20 /* #852 'NSFormatter' => 'Foundation.NSFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89720 /* #853 'MKDistanceFormatter' => 'MapKit.MKDistanceFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89C20 /* #854 'MKETAResponse' => 'MapKit.MKETAResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89E20 /* #855 'MKGeoJSONDecoder' => 'MapKit.MKGeoJsonDecoder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x89F20 /* #856 'MKGeoJSONFeature' => 'MapKit.MKGeoJsonFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8A220 /* #857 'MKLocalSearchCompleter' => 'MapKit.MKLocalSearchCompleter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8A620 /* #858 'MKLocalSearchCompleterDelegate' => 'MapKit.MKLocalSearchCompleterDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8A820 /* #859 'MKLocalSearchCompletion' => 'MapKit.MKLocalSearchCompletion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8A920 /* #860 'MKLocalSearchRequest' => 'MapKit.MKLocalSearchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AA20 /* #861 'MKLocalSearchResponse' => 'MapKit.MKLocalSearchResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AC20 /* #862 'MKMapCamera' => 'MapKit.MKMapCamera, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AD20 /* #863 'MKMapCameraBoundary' => 'MapKit.MKMapCameraBoundary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AE20 /* #864 'MKMapCameraZoomRange' => 'MapKit.MKMapCameraZoomRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8AF20 /* #865 'MKMapSnapshot' => 'MapKit.MKMapSnapshot, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B020 /* #866 'MKMapSnapshotOptions' => 'MapKit.MKMapSnapshotOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8BF20 /* #867 'MKMapViewDelegate' => 'MapKit.MKMapViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C020 /* #868 'MKMultiPolygon' => 'MapKit.MKMultiPolygon, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C120 /* #869 'MKMultiPolygonRenderer' => 'MapKit.MKMultiPolygonRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C220 /* #870 'MKMultiPolyline' => 'MapKit.MKMultiPolyline, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C320 /* #871 'MKMultiPolylineRenderer' => 'MapKit.MKMultiPolylineRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8C720 /* #872 'MKOverlay' => 'MapKit.MKOverlay, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CC20 /* #873 'MKPinAnnotationView' => 'MapKit.MKPinAnnotationView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0720 /* #874 'CLPlacemark' => 'CoreLocation.CLPlacemark, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CD20 /* #875 'MKPlacemark' => 'MapKit.MKPlacemark, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8CE20 /* #876 'MKPointAnnotation' => 'MapKit.MKPointAnnotation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D220 /* #877 'MKPolygonRenderer' => 'MapKit.MKPolygonRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D320 /* #878 'MKPolylineRenderer' => 'MapKit.MKPolylineRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D420 /* #879 'MKRoute' => 'MapKit.MKRoute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D520 /* #880 'MKRouteStep' => 'MapKit.MKRouteStep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D820 /* #881 'MKTileOverlay' => 'MapKit.MKTileOverlay, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D920 /* #882 'MKTileOverlayRenderer' => 'MapKit.MKTileOverlayRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8DA20 /* #883 'MKUserLocation' => 'MapKit.MKUserLocation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E820 /* #884 'JSContext' => 'JavaScriptCore.JSContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8E920 /* #885 'JSValue' => 'JavaScriptCore.JSValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8EC20 /* #886 'Xamarin_Mac__JavaScriptCore_JSExport' => 'JavaScriptCore.JSExport, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8ED20 /* #887 'JSManagedValue' => 'JavaScriptCore.JSManagedValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8EF20 /* #888 'JSVirtualMachine' => 'JavaScriptCore.JSVirtualMachine, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F220 /* #889 'ITLibrary' => 'iTunesLibrary.ITLibrary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F320 /* #890 'ITLibAlbum' => 'iTunesLibrary.ITLibAlbum, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F420 /* #891 'ITLibArtist' => 'iTunesLibrary.ITLibArtist, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8F520 /* #892 'ITLibArtwork' => 'iTunesLibrary.ITLibArtwork, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FA20 /* #893 'ITLibMediaEntity' => 'iTunesLibrary.ITLibMediaEntity, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8FD20 /* #894 'ITLibMediaItem' => 'iTunesLibrary.ITLibMediaItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90220 /* #895 'ITLibMediaItemVideoInfo' => 'iTunesLibrary.ITLibMediaItemVideoInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90320 /* #896 'ITLibPlaylist' => 'iTunesLibrary.ITLibPlaylist, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x90A20 /* #897 'IOSurface' => 'IOSurface.IOSurface, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91020 /* #898 'INCallRecord' => 'Intents.INCallRecord, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91320 /* #899 'INIntentResolutionResult' => 'Intents.INIntentResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91120 /* #900 'INCallRecordTypeResolutionResult' => 'Intents.INCallRecordTypeResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91420 /* #901 'INMessageAttributeOptionsResolutionResult' => 'Intents.INMessageAttributeOptionsResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91520 /* #902 'INMessageAttributeResolutionResult' => 'Intents.INMessageAttributeResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92520 /* #903 'INIntent' => 'Intents.INIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91620 /* #904 'INSearchCallHistoryIntent' => 'Intents.INSearchCallHistoryIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91720 /* #905 'INSpeakableString' => 'Intents.INSpeakableString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91B20 /* #906 'INCallDestinationTypeResolutionResult' => 'Intents.INCallDestinationTypeResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x91E20 /* #907 'INCallRecordTypeOptionsResolutionResult' => 'Intents.INCallRecordTypeOptionsResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92220 /* #908 'INDateComponentsRange' => 'Intents.INDateComponentsRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92320 /* #909 'INDateComponentsRangeResolutionResult' => 'Intents.INDateComponentsRangeResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92420 /* #910 'INImage' => 'Intents.INImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92A20 /* #911 'INIntentResponse' => 'Intents.INIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92D20 /* #912 'INMessage' => 'Intents.INMessage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93120 /* #913 'INParameter' => 'Intents.INParameter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93220 /* #914 'INPerson' => 'Intents.INPerson, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93320 /* #915 'INPersonHandle' => 'Intents.INPersonHandle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93920 /* #916 'INPersonResolutionResult' => 'Intents.INPersonResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93B20 /* #917 'INPlacemarkResolutionResult' => 'Intents.INPlacemarkResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x93D20 /* #918 'INRecurrenceRule' => 'Intents.INRecurrenceRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94120 /* #919 'INSearchCallHistoryIntentResponse' => 'Intents.INSearchCallHistoryIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94320 /* #920 'INSearchForMessagesIntent' => 'Intents.INSearchForMessagesIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94720 /* #921 'INSearchForMessagesIntentResponse' => 'Intents.INSearchForMessagesIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94920 /* #922 'INSendMessageIntent' => 'Intents.INSendMessageIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94D20 /* #923 'INSendMessageIntentResponse' => 'Intents.INSendMessageIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x94F20 /* #924 'INSendMessageRecipientResolutionResult' => 'Intents.INSendMessageRecipientResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95520 /* #925 'INSpeakableStringResolutionResult' => 'Intents.INSpeakableStringResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95620 /* #926 'INStartAudioCallIntent' => 'Intents.INStartAudioCallIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95A20 /* #927 'INStartAudioCallIntentResponse' => 'Intents.INStartAudioCallIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x95C20 /* #928 'INStartVideoCallIntent' => 'Intents.INStartVideoCallIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96020 /* #929 'INStartVideoCallIntentResponse' => 'Intents.INStartVideoCallIntentResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x96220 /* #930 'INStringResolutionResult' => 'Intents.INStringResolutionResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x97D20 /* #931 'GLKMesh' => 'GLKit.GLKMesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98D20 /* #932 'GLKBaseEffect' => 'GLKit.GLKBaseEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98E20 /* #933 'GLKEffectProperty' => 'GLKit.GLKEffectProperty, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x98F20 /* #934 'GLKEffectPropertyFog' => 'GLKit.GLKEffectPropertyFog, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99020 /* #935 'GLKEffectPropertyLight' => 'GLKit.GLKEffectPropertyLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99120 /* #936 'GLKEffectPropertyMaterial' => 'GLKit.GLKEffectPropertyMaterial, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99220 /* #937 'GLKEffectPropertyTexture' => 'GLKit.GLKEffectPropertyTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99320 /* #938 'GLKEffectPropertyTransform' => 'GLKit.GLKEffectPropertyTransform, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99420 /* #939 'GLKMeshBuffer' => 'GLKit.GLKMeshBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99520 /* #940 'GLKMeshBufferAllocator' => 'GLKit.GLKMeshBufferAllocator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99920 /* #941 'GLKNamedEffect' => 'GLKit.GLKNamedEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99A20 /* #942 'GLKReflectionMapEffect' => 'GLKit.GLKReflectionMapEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99B20 /* #943 'GLKSkyboxEffect' => 'GLKit.GLKSkyboxEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99C20 /* #944 'GLKSubmesh' => 'GLKit.GLKSubmesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99D20 /* #945 'GLKTextureInfo' => 'GLKit.GLKTextureInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x99F20 /* #946 'GKBehavior' => 'GameplayKit.GKBehavior, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A020 /* #947 'GKComponentSystem' => 'GameplayKit.GKComponentSystem`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A120 /* #948 'GKCompositeBehavior' => 'GameplayKit.GKCompositeBehavior, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A220 /* #949 'GKEntity' => 'GameplayKit.GKEntity, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CA20 /* #950 'GKGraph' => 'GameplayKit.GKGraph, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A420 /* #951 'GKGridGraph' => 'GameplayKit.GKGridGraph, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A520 /* #952 'GKObstacleGraph' => 'GameplayKit.GKObstacleGraph, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A720 /* #953 'GKPath' => 'GameplayKit.GKPath, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D920 /* #954 'GKObstacle' => 'GameplayKit.GKObstacle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A820 /* #955 'GKPolygonObstacle' => 'GameplayKit.GKPolygonObstacle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9A920 /* #956 'GKState' => 'GameplayKit.GKState, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9AA20 /* #957 'GKStateMachine' => 'GameplayKit.GKStateMachine, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BB20 /* #958 'GKComponent' => 'GameplayKit.GKComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9AF20 /* #959 'GKAgent' => 'GameplayKit.GKAgent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B020 /* #960 'GKAgent2D' => 'GameplayKit.GKAgent2D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B120 /* #961 'GKAgent3D' => 'GameplayKit.GKAgent3D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B520 /* #962 'GKAgentDelegate' => 'GameplayKit.GKAgentDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E220 /* #963 'GKRandomSource' => 'GameplayKit.GKRandomSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B620 /* #964 'GKARC4RandomSource' => 'GameplayKit.GKARC4RandomSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D720 /* #965 'GKNoiseSource' => 'GameplayKit.GKNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BA20 /* #966 'GKCoherentNoiseSource' => 'GameplayKit.GKCoherentNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B720 /* #967 'GKBillowNoiseSource' => 'GameplayKit.GKBillowNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B820 /* #968 'GKCheckerboardNoiseSource' => 'GameplayKit.GKCheckerboardNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9B920 /* #969 'GKCircleObstacle' => 'GameplayKit.GKCircleObstacle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BC20 /* #970 'GKConstantNoiseSource' => 'GameplayKit.GKConstantNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BD20 /* #971 'GKCylindersNoiseSource' => 'GameplayKit.GKCylindersNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BE20 /* #972 'GKDecisionNode' => 'GameplayKit.GKDecisionNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9BF20 /* #973 'GKDecisionTree' => 'GameplayKit.GKDecisionTree, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E120 /* #974 'GKRandomDistribution' => 'GameplayKit.GKRandomDistribution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9C820 /* #975 'GKGaussianDistribution' => 'GameplayKit.GKGaussianDistribution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9C920 /* #976 'GKGoal' => 'GameplayKit.GKGoal, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CB20 /* #977 'GKGraphNode' => 'GameplayKit.GKGraphNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CC20 /* #978 'GKGraphNode2D' => 'GameplayKit.GKGraphNode2D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CD20 /* #979 'GKGraphNode3D' => 'GameplayKit.GKGraphNode3D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CE20 /* #980 'GKGridGraphNode' => 'GameplayKit.GKGridGraphNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9CF20 /* #981 'GKLinearCongruentialRandomSource' => 'GameplayKit.GKLinearCongruentialRandomSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D020 /* #982 'GKMersenneTwisterRandomSource' => 'GameplayKit.GKMersenneTwisterRandomSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D120 /* #983 'GKMeshGraph' => 'GameplayKit.GKMeshGraph`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D320 /* #984 'GKMinmaxStrategist' => 'GameplayKit.GKMinMaxStrategist, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D420 /* #985 'GKMonteCarloStrategist' => 'GameplayKit.GKMonteCarloStrategist, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D520 /* #986 'GKNoise' => 'GameplayKit.GKNoise, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D620 /* #987 'GKNoiseMap' => 'GameplayKit.GKNoiseMap, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E620 /* #988 'GKRule' => 'GameplayKit.GKRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9D820 /* #989 'GKNSPredicateRule' => 'GameplayKit.GKNSPredicateRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DA20 /* #990 'GKOctree' => 'GameplayKit.GKOctree`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DB20 /* #991 'GKOctreeNode' => 'GameplayKit.GKOctreeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DC20 /* #992 'GKPerlinNoiseSource' => 'GameplayKit.GKPerlinNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DD20 /* #993 'GKQuadtree' => 'GameplayKit.GKQuadTree, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9DE20 /* #994 'GKQuadtreeNode' => 'GameplayKit.GKQuadTreeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E320 /* #995 'GKRidgedNoiseSource' => 'GameplayKit.GKRidgedNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E420 /* #996 'GKRTree' => 'GameplayKit.GKRTree`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E720 /* #997 'GKRuleSystem' => 'GameplayKit.GKRuleSystem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9E820 /* #998 'GKScene' => 'GameplayKit.GKScene, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EB20 /* #999 'GKSCNNodeComponent' => 'GameplayKit.GKSCNNodeComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EC20 /* #1000 'GKShuffledDistribution' => 'GameplayKit.GKShuffledDistribution, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9ED20 /* #1001 'GKSKNodeComponent' => 'GameplayKit.GKSKNodeComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EE20 /* #1002 'GKSphereObstacle' => 'GameplayKit.GKSphereObstacle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9EF20 /* #1003 'GKSpheresNoiseSource' => 'GameplayKit.GKSpheresNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F220 /* #1004 'GKVoronoiNoiseSource' => 'GameplayKit.GKVoronoiNoiseSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0920 /* #1005 'GCExtendedGamepad' => 'GameController.GCExtendedGamepad, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F720 /* #1006 'GCExtendedGamepadSnapshot' => 'GameController.GCExtendedGamepadSnapshot, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0A20 /* #1007 'GCGamepad' => 'GameController.GCGamepad, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9F920 /* #1008 'GCGamepadSnapshot' => 'GameController.GCGamepadSnapshot, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0B20 /* #1009 'GCMicroGamepad' => 'GameController.GCMicroGamepad, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x9FC20 /* #1010 'GCMicroGamepadSnapshot' => 'GameController.GCMicroGamepadSnapshot, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0720 /* #1011 'GCControllerElement' => 'GameController.GCControllerElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0420 /* #1012 'GCControllerAxisInput' => 'GameController.GCControllerAxisInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0520 /* #1013 'GCControllerButtonInput' => 'GameController.GCControllerButtonInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0620 /* #1014 'GCControllerDirectionPad' => 'GameController.GCControllerDirectionPad, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0820 /* #1015 'GCEventViewController' => 'GameController.GCEventViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0C20 /* #1016 'GCMotion' => 'GameController.GCMotion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2720 /* #1017 'EKObject' => 'EventKit.EKObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1320 /* #1018 'EKRecurrenceRule' => 'EventKit.EKRecurrenceRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1420 /* #1019 'EKRecurrenceDayOfWeek' => 'EventKit.EKRecurrenceDayOfWeek, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1E20 /* #1020 'EKCalendarItem' => 'EventKit.EKCalendarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1620 /* #1021 'EKEvent' => 'EventKit.EKEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1720 /* #1022 'EKAlarm' => 'EventKit.EKAlarm, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1820 /* #1023 'EKReminder' => 'EventKit.EKReminder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1C20 /* #1024 'EKCalendar' => 'EventKit.EKCalendar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2820 /* #1025 'EKParticipant' => 'EventKit.EKParticipant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA2D20 /* #1026 'EKRecurrenceEnd' => 'EventKit.EKRecurrenceEnd, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3020 /* #1027 'EKSource' => 'EventKit.EKSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3320 /* #1028 'EKStructuredLocation' => 'EventKit.EKStructuredLocation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3620 /* #1029 'CWConfiguration' => 'CoreWlan.CWConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3820 /* #1030 'CW8021XProfile' => 'CoreWlan.CW8021XProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3920 /* #1031 'CWChannel' => 'CoreWlan.CWChannel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4020 /* #1032 'CWEventDelegate' => 'CoreWlan.CWEventDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4520 /* #1033 'CWMutableConfiguration' => 'CoreWlan.CWMutableConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4820 /* #1034 'CWNetworkProfile' => 'CoreWlan.CWNetworkProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4620 /* #1035 'CWMutableNetworkProfile' => 'CoreWlan.CWMutableNetworkProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4720 /* #1036 'CWNetwork' => 'CoreWlan.CWNetwork, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4D20 /* #1037 'CWWiFiClient' => 'CoreWlan.CWWiFiClient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA4E20 /* #1038 'CWWirelessProfile' => 'CoreWlan.CWWirelessProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACA20 /* #1039 'CSSearchableItemAttributeSet' => 'CoreSpotlight.CSSearchableItemAttributeSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACB20 /* #1040 'CSCustomAttributeKey' => 'CoreSpotlight.CSCustomAttributeKey, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACE20 /* #1041 'CSIndexExtensionRequestHandler' => 'CoreSpotlight.CSIndexExtensionRequestHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BAF20 /* #1042 'NSString' => 'Foundation.NSString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xACF20 /* #1043 'CSLocalizedString' => 'CoreSpotlight.CSLocalizedString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD120 /* #1044 'CSPerson' => 'CoreSpotlight.CSPerson, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD720 /* #1045 'CSSearchableIndexDelegate' => 'CoreSpotlight.CSSearchableIndexDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD820 /* #1046 'CSSearchableItem' => 'CoreSpotlight.CSSearchableItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD920 /* #1047 'CSSearchQuery' => 'CoreSpotlight.CSSearchQuery, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEB20 /* #1048 'CMLogItem' => 'CoreMotion.CMLogItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xADD20 /* #1049 'CMAccelerometerData' => 'CoreMotion.CMAccelerometerData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE520 /* #1050 'CMAttitude' => 'CoreMotion.CMAttitude, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAE720 /* #1051 'CMDeviceMotion' => 'CoreMotion.CMDeviceMotion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEA20 /* #1052 'CMGyroData' => 'CoreMotion.CMGyroData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEC20 /* #1053 'CMMagnetometerData' => 'CoreMotion.CMMagnetometerData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEE20 /* #1054 'CMPedometerData' => 'CoreMotion.CMPedometerData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAEF20 /* #1055 'CMPedometerEvent' => 'CoreMotion.CMPedometerEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF120 /* #1056 'CLHeading' => 'CoreLocation.CLHeading, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF220 /* #1057 'CLLocation' => 'CoreLocation.CLLocation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0920 /* #1058 'CLRegion' => 'CoreLocation.CLRegion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAF920 /* #1059 'CLCircularRegion' => 'CoreLocation.CLCircularRegion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFA20 /* #1060 'CLFloor' => 'CoreLocation.CLFloor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0620 /* #1061 'CLLocationManagerDelegate' => 'CoreLocation.CLLocationManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0D20 /* #1062 'CIColor' => 'CoreImage.CIColor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB0F20 /* #1063 'CIContext' => 'CoreImage.CIContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1120 /* #1064 'CIDetector' => 'CoreImage.CIDetector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1320 /* #1065 'CIFilter' => 'CoreImage.CIFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6520 /* #1066 'CoreImage_CICmykHalftone' => 'CoreImage.CICmykHalftone, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB1420 /* #1067 'CoreImage_CICMYKHalftone' => 'CoreImage.CICMYKHalftone, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB1620 /* #1068 'CIImage' => 'CoreImage.CIImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1A20 /* #1069 'CISampler' => 'CoreImage.CISampler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB1B20 /* #1070 'CIVector' => 'CoreImage.CIVector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB2320 /* #1071 'CoreImage_CIAccordionFoldTransition' => 'CoreImage.CIAccordionFoldTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9D20 /* #1072 'CoreImage_CICompositingFilter' => 'CoreImage.CICompositingFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2620 /* #1073 'CoreImage_CIAdditionCompositing' => 'CoreImage.CIAdditionCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2A20 /* #1074 'CoreImage_CIAffineFilter' => 'CoreImage.CIAffineFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2720 /* #1075 'CoreImage_CIAffineClamp' => 'CoreImage.CIAffineClamp, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2B20 /* #1076 'CoreImage_CIAffineTile' => 'CoreImage.CIAffineTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2E20 /* #1077 'CoreImage_CIAffineTransform' => 'CoreImage.CIAffineTransform, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCE920 /* #1078 'CoreImage_CIReductionFilter' => 'CoreImage.CIReductionFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB2F20 /* #1079 'CoreImage_CIAreaAverage' => 'CoreImage.CIAreaAverage, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3020 /* #1080 'CoreImage_CIAreaHistogram' => 'CoreImage.CIAreaHistogram, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3120 /* #1081 'CoreImage_CIAreaMaximum' => 'CoreImage.CIAreaMaximum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3220 /* #1082 'CoreImage_CIAreaMaximumAlpha' => 'CoreImage.CIAreaMaximumAlpha, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3320 /* #1083 'CoreImage_CIAreaMinimum' => 'CoreImage.CIAreaMinimum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3420 /* #1084 'CoreImage_CIAreaMinimumAlpha' => 'CoreImage.CIAreaMinimumAlpha, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3520 /* #1085 'CoreImage_CIAreaMinMax' => 'CoreImage.CIAreaMinMax, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3620 /* #1086 'CoreImage_CIAreaMinMaxRed' => 'CoreImage.CIAreaMinMaxRed, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC3320 /* #1087 'CoreImage_CIImageGenerator' => 'CoreImage.CIImageGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3720 /* #1088 'CoreImage_CIAttributedTextImageGenerator' => 'CoreImage.CIAttributedTextImageGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3E20 /* #1089 'CIBarcodeDescriptor' => 'CoreImage.CIBarcodeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB3A20 /* #1090 'CIAztecCodeDescriptor' => 'CoreImage.CIAztecCodeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB6B20 /* #1091 'CoreImage_CICodeGenerator' => 'CoreImage.CICodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3B20 /* #1092 'CoreImage_CIAztecCodeGenerator' => 'CoreImage.CIAztecCodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB3F20 /* #1093 'CoreImage_CIBarcodeGenerator' => 'CoreImage.CIBarcodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3B20 /* #1094 'CoreImage_CITransitionFilter' => 'CoreImage.CITransitionFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4220 /* #1095 'CoreImage_CIBarsSwipeTransition' => 'CoreImage.CIBarsSwipeTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4520 /* #1096 'CoreImage_CIBicubicScaleTransform' => 'CoreImage.CIBicubicScaleTransform, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4820 /* #1097 'CoreImage_CIBlendFilter' => 'CoreImage.CIBlendFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC4520 /* #1098 'CIKernel' => 'CoreImage.CIKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB8720 /* #1099 'CIColorKernel' => 'CoreImage.CIColorKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4920 /* #1100 'CIBlendKernel' => 'CoreImage.CIBlendKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xB4C20 /* #1101 'CoreImage_CIBlendWithMask' => 'CoreImage.CIBlendWithMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4A20 /* #1102 'CoreImage_CIBlendWithAlphaMask' => 'CoreImage.CIBlendWithAlphaMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4B20 /* #1103 'CoreImage_CIBlendWithBlueMask' => 'CoreImage.CIBlendWithBlueMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB4F20 /* #1104 'CoreImage_CIBlendWithRedMask' => 'CoreImage.CIBlendWithRedMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5020 /* #1105 'CoreImage_CIBloom' => 'CoreImage.CIBloom, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5C20 /* #1106 'CoreImage_CILinearBlur' => 'CoreImage.CILinearBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5320 /* #1107 'CoreImage_CIBokehBlur' => 'CoreImage.CIBokehBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5620 /* #1108 'CoreImage_CIBoxBlur' => 'CoreImage.CIBoxBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBCC20 /* #1109 'CoreImage_CIDistortionFilter' => 'CoreImage.CIDistortionFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5920 /* #1110 'CoreImage_CIBumpDistortion' => 'CoreImage.CIBumpDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5A20 /* #1111 'CoreImage_CIBumpDistortionLinear' => 'CoreImage.CIBumpDistortionLinear, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5B20 /* #1112 'CoreImage_CICameraCalibrationLensCorrection' => 'CoreImage.CICameraCalibrationLensCorrection, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5C20 /* #1113 'CoreImage_CICheckerboardGenerator' => 'CoreImage.CICheckerboardGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB5F20 /* #1114 'CoreImage_CICircleSplashDistortion' => 'CoreImage.CICircleSplashDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCFA20 /* #1115 'CoreImage_CIScreenFilter' => 'CoreImage.CIScreenFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6020 /* #1116 'CoreImage_CICircularScreen' => 'CoreImage.CICircularScreen, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6320 /* #1117 'CoreImage_CICircularWrap' => 'CoreImage.CICircularWrap, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6420 /* #1118 'CoreImage_CIClamp' => 'CoreImage.CIClamp, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6820 /* #1119 'CoreImage_CICode128BarcodeGenerator' => 'CoreImage.CICode128BarcodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6C20 /* #1120 'CoreImage_CIColorBlendMode' => 'CoreImage.CIColorBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6D20 /* #1121 'CoreImage_CIColorBurnBlendMode' => 'CoreImage.CIColorBurnBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB6E20 /* #1122 'CoreImage_CIColorClamp' => 'CoreImage.CIColorClamp, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB7120 /* #1123 'CoreImage_CIColorControls' => 'CoreImage.CIColorControls, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB7420 /* #1124 'CoreImage_CIColorCrossPolynomial' => 'CoreImage.CIColorCrossPolynomial, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB7720 /* #1125 'CoreImage_CIColorCube' => 'CoreImage.CIColorCube, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB7A20 /* #1126 'CoreImage_CIColorCubesMixedWithMask' => 'CoreImage.CIColorCubesMixedWithMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB7D20 /* #1127 'CoreImage_CIColorCubeWithColorSpace' => 'CoreImage.CIColorCubeWithColorSpace, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8020 /* #1128 'CoreImage_CIColorCurves' => 'CoreImage.CIColorCurves, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8320 /* #1129 'CoreImage_CIColorDodgeBlendMode' => 'CoreImage.CIColorDodgeBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8420 /* #1130 'CoreImage_CIColorInvert' => 'CoreImage.CIColorInvert, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8820 /* #1131 'CoreImage_CIColorMap' => 'CoreImage.CIColorMap, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8B20 /* #1132 'CoreImage_CIColorMatrix' => 'CoreImage.CIColorMatrix, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB8E20 /* #1133 'CoreImage_CIColorMonochrome' => 'CoreImage.CIColorMonochrome, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9120 /* #1134 'CoreImage_CIColorPolynomial' => 'CoreImage.CIColorPolynomial, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9420 /* #1135 'CoreImage_CIColorPosterize' => 'CoreImage.CIColorPosterize, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9720 /* #1136 'CoreImage_CIColumnAverage' => 'CoreImage.CIColumnAverage, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9820 /* #1137 'CoreImage_CIComicEffect' => 'CoreImage.CIComicEffect, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xB9E20 /* #1138 'CoreImage_CIConstantColorGenerator' => 'CoreImage.CIConstantColorGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA720 /* #1139 'CoreImage_CIConvolutionCore' => 'CoreImage.CIConvolutionCore, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA220 /* #1140 'CoreImage_CIConvolution3X3' => 'CoreImage.CIConvolution3X3, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA320 /* #1141 'CoreImage_CIConvolution5X5' => 'CoreImage.CIConvolution5X5, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA420 /* #1142 'CoreImage_CIConvolution7X7' => 'CoreImage.CIConvolution7X7, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA520 /* #1143 'CoreImage_CIConvolution9Horizontal' => 'CoreImage.CIConvolution9Horizontal, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBA620 /* #1144 'CoreImage_CIConvolution9Vertical' => 'CoreImage.CIConvolution9Vertical, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBAA20 /* #1145 'CoreImage_CICopyMachineTransition' => 'CoreImage.CICopyMachineTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBAD20 /* #1146 'CoreImage_CICoreMLModelFilter' => 'CoreImage.CICoreMLModelFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB020 /* #1147 'CoreImage_CICrop' => 'CoreImage.CICrop, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB120 /* #1148 'CoreImage_CICrystallize' => 'CoreImage.CICrystallize, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB420 /* #1149 'CoreImage_CIDarkenBlendMode' => 'CoreImage.CIDarkenBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB520 /* #1150 'CIDataMatrixCodeDescriptor' => 'CoreImage.CIDataMatrixCodeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBB620 /* #1151 'CoreImage_CIDepthBlurEffect' => 'CoreImage.CIDepthBlurEffect, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB720 /* #1152 'CoreImage_CIDepthDisparityConverter' => 'CoreImage.CIDepthDisparityConverter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBB820 /* #1153 'CoreImage_CIDepthOfField' => 'CoreImage.CIDepthOfField, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBBB20 /* #1154 'CoreImage_CIDepthToDisparity' => 'CoreImage.CIDepthToDisparity, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBBE20 /* #1155 'CoreImage_CIDifferenceBlendMode' => 'CoreImage.CIDifferenceBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBBF20 /* #1156 'CoreImage_CIDiscBlur' => 'CoreImage.CIDiscBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBC220 /* #1157 'CoreImage_CIDisintegrateWithMaskTransition' => 'CoreImage.CIDisintegrateWithMaskTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBC520 /* #1158 'CoreImage_CIDisparityToDepth' => 'CoreImage.CIDisparityToDepth, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBC820 /* #1159 'CoreImage_CIDisplacementDistortion' => 'CoreImage.CIDisplacementDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBC920 /* #1160 'CoreImage_CIDissolveTransition' => 'CoreImage.CIDissolveTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBCD20 /* #1161 'CoreImage_CIDither' => 'CoreImage.CIDither, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBD020 /* #1162 'CoreImage_CIDivideBlendMode' => 'CoreImage.CIDivideBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBD120 /* #1163 'CoreImage_CIDocumentEnhancer' => 'CoreImage.CIDocumentEnhancer, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBD420 /* #1164 'CoreImage_CIDotScreen' => 'CoreImage.CIDotScreen, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBD720 /* #1165 'CoreImage_CIDroste' => 'CoreImage.CIDroste, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBD820 /* #1166 'CoreImage_CIEdgePreserveUpsampleFilter' => 'CoreImage.CIEdgePreserveUpsampleFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBDB20 /* #1167 'CoreImage_CIEdges' => 'CoreImage.CIEdges, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBDE20 /* #1168 'CoreImage_CIEdgeWork' => 'CoreImage.CIEdgeWork, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3620 /* #1169 'CoreImage_CITileFilter' => 'CoreImage.CITileFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBE120 /* #1170 'CoreImage_CIEightfoldReflectedTile' => 'CoreImage.CIEightfoldReflectedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBE420 /* #1171 'CoreImage_CIExclusionBlendMode' => 'CoreImage.CIExclusionBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBE520 /* #1172 'CoreImage_CIExposureAdjust' => 'CoreImage.CIExposureAdjust, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBE820 /* #1173 'CoreImage_CIFaceBalance' => 'CoreImage.CIFaceBalance, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBED20 /* #1174 'CIFeature' => 'CoreImage.CIFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBE920 /* #1175 'CIFaceFeature' => 'CoreImage.CIFaceFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBEA20 /* #1176 'CoreImage_CIFalseColor' => 'CoreImage.CIFalseColor, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBF320 /* #1177 'CIFilterGenerator' => 'CoreImage.CIFilterGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBF820 /* #1178 'CIFilterShape' => 'CoreImage.CIFilterShape, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xBF920 /* #1179 'CoreImage_CIFlashTransition' => 'CoreImage.CIFlashTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xBFE20 /* #1180 'CoreImage_CIFourfoldReflectedTile' => 'CoreImage.CIFourfoldReflectedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC0120 /* #1181 'CoreImage_CIFourfoldRotatedTile' => 'CoreImage.CIFourfoldRotatedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC0420 /* #1182 'CoreImage_CIFourfoldTranslatedTile' => 'CoreImage.CIFourfoldTranslatedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC0720 /* #1183 'CoreImage_CIGaborGradients' => 'CoreImage.CIGaborGradients, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC0A20 /* #1184 'CoreImage_CIGammaAdjust' => 'CoreImage.CIGammaAdjust, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC0D20 /* #1185 'CoreImage_CIGaussianBlur' => 'CoreImage.CIGaussianBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1020 /* #1186 'CoreImage_CIGaussianGradient' => 'CoreImage.CIGaussianGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1320 /* #1187 'CoreImage_CIGlassDistortion' => 'CoreImage.CIGlassDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1420 /* #1188 'CoreImage_CIGlassLozenge' => 'CoreImage.CIGlassLozenge, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1520 /* #1189 'CoreImage_CIGlideReflectedTile' => 'CoreImage.CIGlideReflectedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1820 /* #1190 'CoreImage_CIGloom' => 'CoreImage.CIGloom, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1B20 /* #1191 'CoreImage_CIGuidedFilter' => 'CoreImage.CIGuidedFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1C20 /* #1192 'CoreImage_CIHardLightBlendMode' => 'CoreImage.CIHardLightBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC1D20 /* #1193 'CoreImage_CIHatchedScreen' => 'CoreImage.CIHatchedScreen, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2020 /* #1194 'CoreImage_CIHeightFieldFromMask' => 'CoreImage.CIHeightFieldFromMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2320 /* #1195 'CoreImage_CIHexagonalPixellate' => 'CoreImage.CIHexagonalPixellate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2620 /* #1196 'CoreImage_CIHighlightShadowAdjust' => 'CoreImage.CIHighlightShadowAdjust, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2920 /* #1197 'CoreImage_CIHistogramDisplayFilter' => 'CoreImage.CIHistogramDisplayFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2A20 /* #1198 'CoreImage_CIHoleDistortion' => 'CoreImage.CIHoleDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2B20 /* #1199 'CoreImage_CIHueAdjust' => 'CoreImage.CIHueAdjust, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2E20 /* #1200 'CoreImage_CIHueBlendMode' => 'CoreImage.CIHueBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC2F20 /* #1201 'CoreImage_CIHueSaturationValueGradient' => 'CoreImage.CIHueSaturationValueGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC3220 /* #1202 'CIImageAccumulator' => 'CoreImage.CIImageAccumulator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC3820 /* #1203 'CIImageProcessorKernel' => 'CoreImage.CIImageProcessorKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xC4220 /* #1204 'CoreImage_CIKaleidoscope' => 'CoreImage.CIKaleidoscope, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC4620 /* #1205 'CoreImage_CIKeystoneCorrection' => 'CoreImage.CIKeystoneCorrection, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC4720 /* #1206 'CoreImage_CIKeystoneCorrectionCombined' => 'CoreImage.CIKeystoneCorrectionCombined, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC4A20 /* #1207 'CoreImage_CIKeystoneCorrectionHorizontal' => 'CoreImage.CIKeystoneCorrectionHorizontal, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC4D20 /* #1208 'CoreImage_CIKeystoneCorrectionVertical' => 'CoreImage.CIKeystoneCorrectionVertical, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5020 /* #1209 'CoreImage_CIKMeans' => 'CoreImage.CIKMeans, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5120 /* #1210 'CoreImage_CILabDeltaE' => 'CoreImage.CILabDeltaE, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5420 /* #1211 'CoreImage_CILanczosScaleTransform' => 'CoreImage.CILanczosScaleTransform, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5720 /* #1212 'CoreImage_CILenticularHaloGenerator' => 'CoreImage.CILenticularHaloGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5A20 /* #1213 'CoreImage_CILightenBlendMode' => 'CoreImage.CILightenBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5B20 /* #1214 'CoreImage_CILightTunnel' => 'CoreImage.CILightTunnel, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5D20 /* #1215 'CoreImage_CILinearBurnBlendMode' => 'CoreImage.CILinearBurnBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5E20 /* #1216 'CoreImage_CILinearDodgeBlendMode' => 'CoreImage.CILinearDodgeBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC5F20 /* #1217 'CoreImage_CILinearGradient' => 'CoreImage.CILinearGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6220 /* #1218 'CoreImage_CILinearToSRGBToneCurve' => 'CoreImage.CILinearToSRGBToneCurve, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6520 /* #1219 'CoreImage_CILineOverlay' => 'CoreImage.CILineOverlay, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6820 /* #1220 'CoreImage_CILineScreen' => 'CoreImage.CILineScreen, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6B20 /* #1221 'CoreImage_CILuminosityBlendMode' => 'CoreImage.CILuminosityBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6C20 /* #1222 'CoreImage_CIMaskedVariableBlur' => 'CoreImage.CIMaskedVariableBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC6F20 /* #1223 'CoreImage_CIMaskToAlpha' => 'CoreImage.CIMaskToAlpha, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7220 /* #1224 'CoreImage_CIMaximumComponent' => 'CoreImage.CIMaximumComponent, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7520 /* #1225 'CoreImage_CIMaximumCompositing' => 'CoreImage.CIMaximumCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7620 /* #1226 'CoreImage_CIMedianFilter' => 'CoreImage.CIMedianFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7920 /* #1227 'CoreImage_CIMeshGenerator' => 'CoreImage.CIMeshGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7C20 /* #1228 'CoreImage_CIMinimumComponent' => 'CoreImage.CIMinimumComponent, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC7F20 /* #1229 'CoreImage_CIMinimumCompositing' => 'CoreImage.CIMinimumCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8020 /* #1230 'CoreImage_CIMix' => 'CoreImage.CIMix, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8320 /* #1231 'CoreImage_CIModTransition' => 'CoreImage.CIModTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8620 /* #1232 'CoreImage_CIMorphology' => 'CoreImage.CIMorphology, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8720 /* #1233 'CoreImage_CIMorphologyGradient' => 'CoreImage.CIMorphologyGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8A20 /* #1234 'CoreImage_CIMorphologyMaximum' => 'CoreImage.CIMorphologyMaximum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC8D20 /* #1235 'CoreImage_CIMorphologyMinimum' => 'CoreImage.CIMorphologyMinimum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9020 /* #1236 'CoreImage_CIMorphologyRectangle' => 'CoreImage.CIMorphologyRectangle, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9120 /* #1237 'CoreImage_CIMorphologyRectangleMaximum' => 'CoreImage.CIMorphologyRectangleMaximum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9420 /* #1238 'CoreImage_CIMorphologyRectangleMinimum' => 'CoreImage.CIMorphologyRectangleMinimum, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9720 /* #1239 'CoreImage_CIMotionBlur' => 'CoreImage.CIMotionBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9A20 /* #1240 'CoreImage_CIMultiplyBlendMode' => 'CoreImage.CIMultiplyBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9B20 /* #1241 'CoreImage_CIMultiplyCompositing' => 'CoreImage.CIMultiplyCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9C20 /* #1242 'CoreImage_CINinePartStretched' => 'CoreImage.CINinePartStretched, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9D20 /* #1243 'CoreImage_CINinePartTiled' => 'CoreImage.CINinePartTiled, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xC9E20 /* #1244 'CoreImage_CINoiseReduction' => 'CoreImage.CINoiseReduction, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCA120 /* #1245 'CoreImage_CIOpTile' => 'CoreImage.CIOpTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCA420 /* #1246 'CoreImage_CIOverlayBlendMode' => 'CoreImage.CIOverlayBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCA520 /* #1247 'CoreImage_CIPageCurlTransition' => 'CoreImage.CIPageCurlTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCA820 /* #1248 'CoreImage_CIPageCurlWithShadowTransition' => 'CoreImage.CIPageCurlWithShadowTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCAB20 /* #1249 'CoreImage_CIPaletteCentroid' => 'CoreImage.CIPaletteCentroid, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCAE20 /* #1250 'CoreImage_CIPalettize' => 'CoreImage.CIPalettize, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCB120 /* #1251 'CoreImage_CIParallelogramTile' => 'CoreImage.CIParallelogramTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCB420 /* #1252 'CoreImage_CIPdf417BarcodeGenerator' => 'CoreImage.CIPdf417BarcodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCB720 /* #1253 'CIPDF417CodeDescriptor' => 'CoreImage.CIPdf417CodeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCC120 /* #1254 'CoreImage_CIPerspectiveTransform' => 'CoreImage.CIPerspectiveTransform, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCB820 /* #1255 'CoreImage_CIPerspectiveCorrection' => 'CoreImage.CIPerspectiveCorrection, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCBB20 /* #1256 'CoreImage_CIPerspectiveRotate' => 'CoreImage.CIPerspectiveRotate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCBE20 /* #1257 'CoreImage_CIPerspectiveTile' => 'CoreImage.CIPerspectiveTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCC420 /* #1258 'CoreImage_CIPerspectiveTransformWithExtent' => 'CoreImage.CIPerspectiveTransformWithExtent, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCC720 /* #1259 'CoreImage_CIPhotoEffect' => 'CoreImage.CIPhotoEffect, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCC820 /* #1260 'CoreImage_CIPhotoEffectChrome' => 'CoreImage.CIPhotoEffectChrome, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCC920 /* #1261 'CoreImage_CIPhotoEffectFade' => 'CoreImage.CIPhotoEffectFade, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCCA20 /* #1262 'CoreImage_CIPhotoEffectInstant' => 'CoreImage.CIPhotoEffectInstant, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCCB20 /* #1263 'CoreImage_CIPhotoEffectMono' => 'CoreImage.CIPhotoEffectMono, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCCC20 /* #1264 'CoreImage_CIPhotoEffectNoir' => 'CoreImage.CIPhotoEffectNoir, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCCD20 /* #1265 'CoreImage_CIPhotoEffectProcess' => 'CoreImage.CIPhotoEffectProcess, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD020 /* #1266 'CoreImage_CIPhotoEffectTonal' => 'CoreImage.CIPhotoEffectTonal, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD120 /* #1267 'CoreImage_CIPhotoEffectTransfer' => 'CoreImage.CIPhotoEffectTransfer, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD220 /* #1268 'CoreImage_CIPinchDistortion' => 'CoreImage.CIPinchDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD320 /* #1269 'CoreImage_CIPinLightBlendMode' => 'CoreImage.CIPinLightBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD420 /* #1270 'CoreImage_CIPixellate' => 'CoreImage.CIPixellate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCD720 /* #1271 'CIPlugIn' => 'CoreImage.CIPlugIn, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCD820 /* #1272 'CoreImage_CIPointillize' => 'CoreImage.CIPointillize, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCDB20 /* #1273 'CIQRCodeDescriptor' => 'CoreImage.CIQRCodeDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDC20 /* #1274 'CIQRCodeFeature' => 'CoreImage.CIQRCodeFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCDD20 /* #1275 'CoreImage_CIQRCodeGenerator' => 'CoreImage.CIQRCodeGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCE020 /* #1276 'CoreImage_CIRadialGradient' => 'CoreImage.CIRadialGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCE320 /* #1277 'CoreImage_CIRandomGenerator' => 'CoreImage.CIRandomGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCE820 /* #1278 'CIRectangleFeature' => 'CoreImage.CIRectangleFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEA20 /* #1279 'CIRenderDestination' => 'CoreImage.CIRenderDestination, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEB20 /* #1280 'CIRenderInfo' => 'CoreImage.CIRenderInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCEC20 /* #1281 'CIRenderTask' => 'CoreImage.CIRenderTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xCED20 /* #1282 'CoreImage_CIRippleTransition' => 'CoreImage.CIRippleTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF020 /* #1283 'CoreImage_CIRoundedRectangleGenerator' => 'CoreImage.CIRoundedRectangleGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF320 /* #1284 'CoreImage_CIRowAverage' => 'CoreImage.CIRowAverage, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF420 /* #1285 'CoreImage_CISaliencyMapFilter' => 'CoreImage.CISaliencyMapFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF720 /* #1286 'CoreImage_CISampleNearest' => 'CoreImage.CISampleNearest, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF820 /* #1287 'CoreImage_CISaturationBlendMode' => 'CoreImage.CISaturationBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCF920 /* #1288 'CoreImage_CIScreenBlendMode' => 'CoreImage.CIScreenBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCFB20 /* #1289 'CoreImage_CISepiaTone' => 'CoreImage.CISepiaTone, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xCFE20 /* #1290 'CoreImage_CIShadedMaterial' => 'CoreImage.CIShadedMaterial, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0120 /* #1291 'CoreImage_CISharpenLuminance' => 'CoreImage.CISharpenLuminance, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0420 /* #1292 'CoreImage_CISixfoldReflectedTile' => 'CoreImage.CISixfoldReflectedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0720 /* #1293 'CoreImage_CISixfoldRotatedTile' => 'CoreImage.CISixfoldRotatedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0A20 /* #1294 'CoreImage_CISmoothLinearGradient' => 'CoreImage.CISmoothLinearGradient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0D20 /* #1295 'CoreImage_CISoftLightBlendMode' => 'CoreImage.CISoftLightBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0E20 /* #1296 'CoreImage_CISourceAtopCompositing' => 'CoreImage.CISourceAtopCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD0F20 /* #1297 'CoreImage_CISourceInCompositing' => 'CoreImage.CISourceInCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1020 /* #1298 'CoreImage_CISourceOutCompositing' => 'CoreImage.CISourceOutCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1120 /* #1299 'CoreImage_CISourceOverCompositing' => 'CoreImage.CISourceOverCompositing, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1220 /* #1300 'CoreImage_CISpotColor' => 'CoreImage.CISpotColor, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1520 /* #1301 'CoreImage_CISpotLight' => 'CoreImage.CISpotLight, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1820 /* #1302 'CoreImage_CISRGBToneCurveToLinear' => 'CoreImage.CISRGBToneCurveToLinear, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1B20 /* #1303 'CoreImage_CIStarShineGenerator' => 'CoreImage.CIStarShineGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD1E20 /* #1304 'CoreImage_CIStraightenFilter' => 'CoreImage.CIStraightenFilter, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2120 /* #1305 'CoreImage_CIStretchCrop' => 'CoreImage.CIStretchCrop, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2220 /* #1306 'CoreImage_CIStripesGenerator' => 'CoreImage.CIStripesGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2520 /* #1307 'CoreImage_CISubtractBlendMode' => 'CoreImage.CISubtractBlendMode, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2620 /* #1308 'CoreImage_CISunbeamsGenerator' => 'CoreImage.CISunbeamsGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2920 /* #1309 'CoreImage_CISwipeTransition' => 'CoreImage.CISwipeTransition, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2C20 /* #1310 'CoreImage_CITemperatureAndTint' => 'CoreImage.CITemperatureAndTint, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD2F20 /* #1311 'CITextFeature' => 'CoreImage.CITextFeature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD3020 /* #1312 'CoreImage_CITextImageGenerator' => 'CoreImage.CITextImageGenerator, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3320 /* #1313 'CoreImage_CIThermal' => 'CoreImage.CIThermal, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3720 /* #1314 'CoreImage_CIToneCurve' => 'CoreImage.CIToneCurve, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3A20 /* #1315 'CoreImage_CITorusLensDistortion' => 'CoreImage.CITorusLensDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD3E20 /* #1316 'CoreImage_CITriangleKaleidoscope' => 'CoreImage.CITriangleKaleidoscope, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4120 /* #1317 'CoreImage_CITriangleTile' => 'CoreImage.CITriangleTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4420 /* #1318 'CoreImage_CITwelvefoldReflectedTile' => 'CoreImage.CITwelvefoldReflectedTile, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4720 /* #1319 'CoreImage_CITwirlDistortion' => 'CoreImage.CITwirlDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4920 /* #1320 'CoreImage_CIUnsharpMask' => 'CoreImage.CIUnsharpMask, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4C20 /* #1321 'CoreImage_CIVibrance' => 'CoreImage.CIVibrance, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD4F20 /* #1322 'CoreImage_CIVignette' => 'CoreImage.CIVignette, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD5020 /* #1323 'CoreImage_CIVignetteEffect' => 'CoreImage.CIVignetteEffect, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD5520 /* #1324 'CoreImage_CIVortexDistortion' => 'CoreImage.CIVortexDistortion, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD5620 /* #1325 'CIWarpKernel' => 'CoreImage.CIWarpKernel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xD5720 /* #1326 'CoreImage_CIWhitePointAdjust' => 'CoreImage.CIWhitePointAdjust, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD5A20 /* #1327 'CoreImage_CIXRay' => 'CoreImage.CIXRay, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xD5D20 /* #1328 'CoreImage_CIZoomBlur' => 'CoreImage.CIZoomBlur, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0xDC620 /* #1329 'CAAnimation' => 'CoreAnimation.CAAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF220 /* #1330 'CAPropertyAnimation' => 'CoreAnimation.CAPropertyAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC420 /* #1331 'CABasicAnimation' => 'CoreAnimation.CABasicAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC520 /* #1332 'CAScrollLayer' => 'CoreAnimation.CAScrollLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC820 /* #1333 'CAEmitterBehavior' => 'CoreAnimation.CAEmitterBehavior, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDC920 /* #1334 'CAGradientLayer' => 'CoreAnimation.CAGradientLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCA20 /* #1335 'CAKeyframeAnimation' => 'CoreAnimation.CAKeyFrameAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCC20 /* #1336 'CALayerDelegate' => 'CoreAnimation.CALayerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCD20 /* #1337 'CAMediaTimingFunction' => 'CoreAnimation.CAMediaTimingFunction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDCE20 /* #1338 'CATextLayer' => 'CoreAnimation.CATextLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDD620 /* #1339 'CAAction' => 'CoreAnimation.CAAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDA20 /* #1340 'CAAnimationDelegate' => 'CoreAnimation.CAAnimationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDB20 /* #1341 'CAAnimationGroup' => 'CoreAnimation.CAAnimationGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDC20 /* #1342 'CAConstraint' => 'CoreAnimation.CAConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDDD20 /* #1343 'CAConstraintLayoutManager' => 'CoreAnimation.CAConstraintLayoutManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE220 /* #1344 'CAEDRMetadata' => 'CoreAnimation.CAEdrMetadata, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE320 /* #1345 'CAEmitterCell' => 'CoreAnimation.CAEmitterCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDE420 /* #1346 'CAEmitterLayer' => 'CoreAnimation.CAEmitterLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDED20 /* #1347 'CAMediaTiming' => 'CoreAnimation.CAMediaTiming, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF020 /* #1348 'CAMetalLayer' => 'CoreAnimation.CAMetalLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF320 /* #1349 'CARenderer' => 'CoreAnimation.CARenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF620 /* #1350 'CAReplicatorLayer' => 'CoreAnimation.CAReplicatorLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDF920 /* #1351 'CAShapeLayer' => 'CoreAnimation.CAShapeLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDFA20 /* #1352 'CASpringAnimation' => 'CoreAnimation.CASpringAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xDFF20 /* #1353 'CATiledLayer' => 'CoreAnimation.CATiledLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0020 /* #1354 'CATransaction' => 'CoreAnimation.CATransaction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0120 /* #1355 'CATransformLayer' => 'CoreAnimation.CATransformLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0220 /* #1356 'CATransition' => 'CoreAnimation.CATransition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0320 /* #1357 'CAValueFunction' => 'CoreAnimation.CAValueFunction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3220 /* #1358 'CNFetchRequest' => 'Contacts.CNFetchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0620 /* #1359 'CNContactFetchRequest' => 'Contacts.CNContactFetchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0A20 /* #1360 'CNInstantMessageAddress' => 'Contacts.CNInstantMessageAddress, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0E20 /* #1361 'CNSocialProfile' => 'Contacts.CNSocialProfile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1720 /* #1362 'CNChangeHistoryEvent' => 'Contacts.CNChangeHistoryEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1020 /* #1363 'CNChangeHistoryAddContactEvent' => 'Contacts.CNChangeHistoryAddContactEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1120 /* #1364 'CNChangeHistoryAddGroupEvent' => 'Contacts.CNChangeHistoryAddGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1220 /* #1365 'CNChangeHistoryAddMemberToGroupEvent' => 'Contacts.CNChangeHistoryAddMemberToGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1320 /* #1366 'CNChangeHistoryAddSubgroupToGroupEvent' => 'Contacts.CNChangeHistoryAddSubgroupToGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1420 /* #1367 'CNChangeHistoryDeleteContactEvent' => 'Contacts.CNChangeHistoryDeleteContactEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1520 /* #1368 'CNChangeHistoryDeleteGroupEvent' => 'Contacts.CNChangeHistoryDeleteGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1620 /* #1369 'CNChangeHistoryDropEverythingEvent' => 'Contacts.CNChangeHistoryDropEverythingEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1B20 /* #1370 'CNChangeHistoryFetchRequest' => 'Contacts.CNChangeHistoryFetchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1C20 /* #1371 'CNChangeHistoryRemoveMemberFromGroupEvent' => 'Contacts.CNChangeHistoryRemoveMemberFromGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1D20 /* #1372 'CNChangeHistoryRemoveSubgroupFromGroupEvent' => 'Contacts.CNChangeHistoryRemoveSubgroupFromGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1E20 /* #1373 'CNChangeHistoryUpdateContactEvent' => 'Contacts.CNChangeHistoryUpdateContactEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE1F20 /* #1374 'CNChangeHistoryUpdateGroupEvent' => 'Contacts.CNChangeHistoryUpdateGroupEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2120 /* #1375 'CNContactFormatter' => 'Contacts.CNContactFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2420 /* #1376 'CNContactProperty' => 'Contacts.CNContactProperty, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2520 /* #1377 'CNContactRelation' => 'Contacts.CNContactRelation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2720 /* #1378 'CNContactsUserDefaults' => 'Contacts.CNContactsUserDefaults, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2920 /* #1379 'CNContactVCardSerialization' => 'Contacts.CNContactVCardSerialization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE2A20 /* #1380 'CNContainer' => 'Contacts.CNContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3320 /* #1381 'CNFetchResult' => 'Contacts.CNFetchResult`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3420 /* #1382 'CNGroup' => 'Contacts.CNGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3B20 /* #1383 'CNLabeledValue' => 'Contacts.CNLabeledValue`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE0520 /* #1384 'CNContact' => 'Contacts.CNContact, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3E20 /* #1385 'CNMutableContact' => 'Contacts.CNMutableContact, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE3F20 /* #1386 'CNMutableGroup' => 'Contacts.CNMutableGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4220 /* #1387 'CNPostalAddress' => 'Contacts.CNPostalAddress, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4020 /* #1388 'CNMutablePostalAddress' => 'Contacts.CNMutablePostalAddress, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4120 /* #1389 'CNPhoneNumber' => 'Contacts.CNPhoneNumber, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4320 /* #1390 'CNPostalAddressFormatter' => 'Contacts.CNPostalAddressFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4820 /* #1391 'CNSaveRequest' => 'Contacts.CNSaveRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B5D20 /* #1392 'NSOperation' => 'Foundation.NSOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4E20 /* #1393 'CKOperation' => 'CloudKit.CKOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE4F20 /* #1394 'CKNotificationID' => 'CloudKit.CKNotificationID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5020 /* #1395 'CKRecord' => 'CloudKit.CKRecord, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5120 /* #1396 'CKRecordID' => 'CloudKit.CKRecordID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5220 /* #1397 'CKRecordZoneID' => 'CloudKit.CKRecordZoneID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5320 /* #1398 'CKUserIdentityLookupInfo' => 'CloudKit.CKUserIdentityLookupInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5420 /* #1399 'CKAcceptSharesOperation' => 'CloudKit.CKAcceptSharesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5820 /* #1400 'CKAsset' => 'CloudKit.CKAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7920 /* #1401 'CKNotification' => 'CloudKit.CKNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5B20 /* #1402 'CKDatabaseNotification' => 'CloudKit.CKDatabaseNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5C20 /* #1403 'CKDatabaseOperation' => 'CloudKit.CKDatabaseOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9920 /* #1404 'CKSubscription' => 'CloudKit.CKSubscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5E20 /* #1405 'CKDatabaseSubscription' => 'CloudKit.CKDatabaseSubscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5F20 /* #1406 'CKDiscoverAllContactsOperation' => 'CloudKit.CKDiscoverAllContactsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6020 /* #1407 'CKDiscoverAllUserIdentitiesOperation' => 'CloudKit.CKDiscoverAllUserIdentitiesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6120 /* #1408 'CKDiscoveredUserInfo' => 'CloudKit.CKDiscoveredUserInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6220 /* #1409 'CKDiscoverUserIdentitiesOperation' => 'CloudKit.CKDiscoverUserIdentitiesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6320 /* #1410 'CKDiscoverUserInfosOperation' => 'CloudKit.CKDiscoverUserInfosOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6720 /* #1411 'CKFetchDatabaseChangesOperation' => 'CloudKit.CKFetchDatabaseChangesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6820 /* #1412 'CKFetchNotificationChangesOperation' => 'CloudKit.CKFetchNotificationChangesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6920 /* #1413 'CKFetchRecordChangesOperation' => 'CloudKit.CKFetchRecordChangesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6A20 /* #1414 'CKFetchRecordsOperation' => 'CloudKit.CKFetchRecordsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6B20 /* #1415 'CKFetchRecordZoneChangesConfiguration' => 'CloudKit.CKFetchRecordZoneChangesConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6C20 /* #1416 'CKFetchRecordZoneChangesOperation' => 'CloudKit.CKFetchRecordZoneChangesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6D20 /* #1417 'CKFetchRecordZoneChangesOptions' => 'CloudKit.CKFetchRecordZoneChangesOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6E20 /* #1418 'CKFetchRecordZonesOperation' => 'CloudKit.CKFetchRecordZonesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE6F20 /* #1419 'CKFetchShareMetadataOperation' => 'CloudKit.CKFetchShareMetadataOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7020 /* #1420 'CKFetchShareParticipantsOperation' => 'CloudKit.CKFetchShareParticipantsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7120 /* #1421 'CKFetchSubscriptionsOperation' => 'CloudKit.CKFetchSubscriptionsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7220 /* #1422 'CKFetchWebAuthTokenOperation' => 'CloudKit.CKFetchWebAuthTokenOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2D20 /* #1423 'NSSortDescriptor' => 'Foundation.NSSortDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7320 /* #1424 'CKLocationSortDescriptor' => 'CloudKit.CKLocationSortDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7420 /* #1425 'CKMarkNotificationsReadOperation' => 'CloudKit.CKMarkNotificationsReadOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7520 /* #1426 'CKModifyBadgeOperation' => 'CloudKit.CKModifyBadgeOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7620 /* #1427 'CKModifyRecordsOperation' => 'CloudKit.CKModifyRecordsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7720 /* #1428 'CKModifyRecordZonesOperation' => 'CloudKit.CKModifyRecordZonesOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7820 /* #1429 'CKModifySubscriptionsOperation' => 'CloudKit.CKModifySubscriptionsOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7A20 /* #1430 'CKNotificationInfo' => 'CloudKit.CKNotificationInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7C20 /* #1431 'CKOperationConfiguration' => 'CloudKit.CKOperationConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7D20 /* #1432 'CKOperationGroup' => 'CloudKit.CKOperationGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE7F20 /* #1433 'CKQuery' => 'CloudKit.CKQuery, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8020 /* #1434 'CKQueryCursor' => 'CloudKit.CKQueryCursor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8120 /* #1435 'CKQueryNotification' => 'CloudKit.CKQueryNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8320 /* #1436 'CKQueryOperation' => 'CloudKit.CKQueryOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8420 /* #1437 'CKQuerySubscription' => 'CloudKit.CKQuerySubscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8920 /* #1438 'CKRecordValue' => 'CloudKit.CKRecordValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8A20 /* #1439 'CKRecordZone' => 'CloudKit.CKRecordZone, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8C20 /* #1440 'CKRecordZoneNotification' => 'CloudKit.CKRecordZoneNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8D20 /* #1441 'CKRecordZoneSubscription' => 'CloudKit.CKRecordZoneSubscription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE8E20 /* #1442 'CKReference' => 'CloudKit.CKReference, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9020 /* #1443 'CKServerChangeToken' => 'CloudKit.CKServerChangeToken, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9120 /* #1444 'CKShare' => 'CloudKit.CKShare, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9320 /* #1445 'CKShareMetadata' => 'CloudKit.CKShareMetadata, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9420 /* #1446 'CKShareParticipant' => 'CloudKit.CKShareParticipant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE9C20 /* #1447 'CKUserIdentity' => 'CloudKit.CKUserIdentity, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBC20 /* #1448 'BCChatAction' => 'BusinessChat.BCChatAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FF20 /* #1449 'NSControl' => 'AppKit.NSControl, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEBD20 /* #1450 'BCChatButton' => 'BusinessChat.BCChatButton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xECA20 /* #1451 'AUParameterNode' => 'AudioUnit.AUParameterNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xEC920 /* #1452 'AUParameter' => 'AudioUnit.AUParameter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1720 /* #1453 'AUAudioUnitBus' => 'AudioUnit.AUAudioUnitBus, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1820 /* #1454 'AUAudioUnitBusArray' => 'AudioUnit.AUAudioUnitBusArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1B20 /* #1455 'AUAudioUnitPreset' => 'AudioUnit.AUAudioUnitPreset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1C20 /* #1456 'AUParameterGroup' => 'AudioUnit.AUParameterGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1D20 /* #1457 'AUParameterTree' => 'AudioUnit.AUParameterTree, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBB20 /* #1458 'SKAction' => 'SpriteKit.SKAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBC20 /* #1459 'SKKeyframeSequence' => 'SpriteKit.SKKeyframeSequence, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBD20 /* #1460 'SKNode' => 'SpriteKit.SKNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBE20 /* #1461 'SKShapeNode' => 'SpriteKit.SKShapeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFBF20 /* #1462 'SKUniform' => 'SpriteKit.SKUniform, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC020 /* #1463 'SKVideoNode' => 'SpriteKit.SKVideoNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100920 /* #1464 'SKWarpGeometry' => 'SpriteKit.SKWarpGeometry, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC120 /* #1465 'SKWarpGeometryGrid' => 'SpriteKit.SKWarpGeometryGrid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC220 /* #1466 'SK3DNode' => 'SpriteKit.SK3DNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC420 /* #1467 'SKAttribute' => 'SpriteKit.SKAttribute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC620 /* #1468 'SKAttributeValue' => 'SpriteKit.SKAttributeValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC720 /* #1469 'SKAudioNode' => 'SpriteKit.SKAudioNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC920 /* #1470 'SKCameraNode' => 'SpriteKit.SKCameraNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCA20 /* #1471 'SKConstraint' => 'SpriteKit.SKConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCB20 /* #1472 'SKCropNode' => 'SpriteKit.SKCropNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCC20 /* #1473 'SKEffectNode' => 'SpriteKit.SKEffectNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCD20 /* #1474 'SKEmitterNode' => 'SpriteKit.SKEmitterNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFCE20 /* #1475 'SKFieldNode' => 'SpriteKit.SKFieldNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD120 /* #1476 'SKLabelNode' => 'SpriteKit.SKLabelNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD320 /* #1477 'SKLightNode' => 'SpriteKit.SKLightNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF220 /* #1478 'SKTexture' => 'SpriteKit.SKTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD420 /* #1479 'SKMutableTexture' => 'SpriteKit.SKMutableTexture, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD720 /* #1480 'SKPhysicsBody' => 'SpriteKit.SKPhysicsBody, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFD820 /* #1481 'SKPhysicsContact' => 'SpriteKit.SKPhysicsContact, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDC20 /* #1482 'SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsContactDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDD20 /* #1483 'SKPhysicsJoint' => 'SpriteKit.SKPhysicsJoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDE20 /* #1484 'SKPhysicsJointFixed' => 'SpriteKit.SKPhysicsJointFixed, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFDF20 /* #1485 'SKPhysicsJointLimit' => 'SpriteKit.SKPhysicsJointLimit, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE020 /* #1486 'SKPhysicsJointPin' => 'SpriteKit.SKPhysicsJointPin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE120 /* #1487 'SKPhysicsJointSliding' => 'SpriteKit.SKPhysicsJointSliding, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE220 /* #1488 'SKPhysicsJointSpring' => 'SpriteKit.SKPhysicsJointSpring, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE420 /* #1489 'SKRange' => 'SpriteKit.SKRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE520 /* #1490 'SKReachConstraints' => 'SpriteKit.SKReachConstraints, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE620 /* #1491 'SKReferenceNode' => 'SpriteKit.SKReferenceNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE720 /* #1492 'SKRegion' => 'SpriteKit.SKRegion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFE820 /* #1493 'SKRenderer' => 'SpriteKit.SKRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEA20 /* #1494 'SKScene' => 'SpriteKit.SKScene, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFEE20 /* #1495 'SKSceneDelegate' => 'SpriteKit.SKSceneDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF020 /* #1496 'SKShader' => 'SpriteKit.SKShader, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF120 /* #1497 'SKSpriteNode' => 'SpriteKit.SKSpriteNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF720 /* #1498 'SKTileDefinition' => 'SpriteKit.SKTileDefinition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF920 /* #1499 'SKTileGroup' => 'SpriteKit.SKTileGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFA20 /* #1500 'SKTileGroupRule' => 'SpriteKit.SKTileGroupRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFB20 /* #1501 'SKTileMapNode' => 'SpriteKit.SKTileMapNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFC20 /* #1502 'SKTileSet' => 'SpriteKit.SKTileSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFE20 /* #1503 'SKTransformNode' => 'SpriteKit.SKTransformNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFFF20 /* #1504 'SKTransition' => 'SpriteKit.SKTransition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100220 /* #1505 'SKView' => 'SpriteKit.SKView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x100620 /* #1506 'SKViewDelegate' => 'SpriteKit.SKViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101B20 /* #1507 'SCNGeometry' => 'SceneKit.SCNGeometry, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101220 /* #1508 'SCNText' => 'SceneKit.SCNText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101320 /* #1509 'SCNAnimatable' => 'SceneKit.SCNAnimatable, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101520 /* #1510 'SCNScene' => 'SceneKit.SCNScene, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101620 /* #1511 'SCNSceneRenderer' => 'SceneKit.SCNSceneRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101C20 /* #1512 'SCNGeometrySource' => 'SceneKit.SCNGeometrySource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102020 /* #1513 'SCNParticleSystem' => 'SceneKit.SCNParticleSystem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102120 /* #1514 'SCNPhysicsShape' => 'SceneKit.SCNPhysicsShape, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102820 /* #1515 'SCNSceneSource' => 'SceneKit.SCNSceneSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102920 /* #1516 'SCNSkinner' => 'SceneKit.SCNSkinner, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x102A20 /* #1517 'SCNTechnique' => 'SceneKit.SCNTechnique, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105D20 /* #1518 'SCNConstraint' => 'SceneKit.SCNConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103020 /* #1519 'SCNAccelerationConstraint' => 'SceneKit.SCNAccelerationConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103420 /* #1520 'SCNActionable' => 'SceneKit.SCNActionable, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103920 /* #1521 'SCNAnimation' => 'SceneKit.SCNAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103B20 /* #1522 'SCNAnimationPlayer' => 'SceneKit.SCNAnimationPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x103F20 /* #1523 'SCNAudioPlayer' => 'SceneKit.SCNAudioPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104020 /* #1524 'SCNAudioSource' => 'SceneKit.SCNAudioSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104120 /* #1525 'SCNAvoidOccluderConstraint' => 'SceneKit.SCNAvoidOccluderConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104520 /* #1526 'SCNAvoidOccluderConstraintDelegate' => 'SceneKit.SCNAvoidOccluderConstraintDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104720 /* #1527 'SCNBillboardConstraint' => 'SceneKit.SCNBillboardConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104B20 /* #1528 'SCNBoundingVolume' => 'SceneKit.SCNBoundingVolume, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x104C20 /* #1529 'SCNBox' => 'SceneKit.SCNBox, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105020 /* #1530 'SCNCamera' => 'SceneKit.SCNCamera, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105320 /* #1531 'SCNCameraController' => 'SceneKit.SCNCameraController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105720 /* #1532 'SCNCameraControllerDelegate' => 'SceneKit.SCNCameraControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105920 /* #1533 'SCNCapsule' => 'SceneKit.SCNCapsule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105C20 /* #1534 'SCNCone' => 'SceneKit.SCNCone, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x105F20 /* #1535 'SCNCylinder' => 'SceneKit.SCNCylinder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106120 /* #1536 'SCNDistanceConstraint' => 'SceneKit.SCNDistanceConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106620 /* #1537 'SCNFloor' => 'SceneKit.SCNFloor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106720 /* #1538 'SCNGeometryElement' => 'SceneKit.SCNGeometryElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106B20 /* #1539 'SCNGeometryTessellator' => 'SceneKit.SCNGeometryTessellator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106D20 /* #1540 'SCNHitTestResult' => 'SceneKit.SCNHitTestResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x106F20 /* #1541 'SCNIKConstraint' => 'SceneKit.SCNIKConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107220 /* #1542 'SCNLevelOfDetail' => 'SceneKit.SCNLevelOfDetail, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107320 /* #1543 'SCNLight' => 'SceneKit.SCNLight, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107A20 /* #1544 'SCNLookAtConstraint' => 'SceneKit.SCNLookAtConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107B20 /* #1545 'SCNMaterial' => 'SceneKit.SCNMaterial, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107C20 /* #1546 'SCNMaterialProperty' => 'SceneKit.SCNMaterialProperty, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107D20 /* #1547 'SCNMorpher' => 'SceneKit.SCNMorpher, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108420 /* #1548 'SCNNodeRendererDelegate' => 'SceneKit.SCNNodeRendererDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x108E20 /* #1549 'SCNParticlePropertyController' => 'SceneKit.SCNParticlePropertyController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109120 /* #1550 'SCNPhysicsBehavior' => 'SceneKit.SCNPhysicsBehavior, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109020 /* #1551 'SCNPhysicsBallSocketJoint' => 'SceneKit.SCNPhysicsBallSocketJoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109220 /* #1552 'SCNPhysicsBody' => 'SceneKit.SCNPhysicsBody, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109520 /* #1553 'SCNPhysicsConeTwistJoint' => 'SceneKit.SCNPhysicsConeTwistJoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109620 /* #1554 'SCNPhysicsContact' => 'SceneKit.SCNPhysicsContact, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109A20 /* #1555 'SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsContactDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109B20 /* #1556 'SCNPhysicsField' => 'SceneKit.SCNPhysicsField, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x109D20 /* #1557 'SCNPhysicsHingeJoint' => 'SceneKit.SCNPhysicsHingeJoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A120 /* #1558 'SCNPhysicsSliderJoint' => 'SceneKit.SCNPhysicsSliderJoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A420 /* #1559 'SCNPhysicsVehicle' => 'SceneKit.SCNPhysicsVehicle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A520 /* #1560 'SCNPhysicsVehicleWheel' => 'SceneKit.SCNPhysicsVehicleWheel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A820 /* #1561 'SCNPlane' => 'SceneKit.SCNPlane, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10A920 /* #1562 'SCNProgram' => 'SceneKit.SCNProgram, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10AD20 /* #1563 'SCNProgramDelegate' => 'SceneKit.SCNProgramDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10AF20 /* #1564 'SCNPyramid' => 'SceneKit.SCNPyramid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101E20 /* #1565 'SCNNode' => 'SceneKit.SCNNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10B120 /* #1566 'SCNReferenceNode' => 'SceneKit.SCNReferenceNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10B620 /* #1567 'SCNReplicatorConstraint' => 'SceneKit.SCNReplicatorConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10BA20 /* #1568 'SCNSceneExportDelegate' => 'SceneKit.SCNSceneExportDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C020 /* #1569 'SCNSceneRendererDelegate' => 'SceneKit.SCNSceneRendererDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10C820 /* #1570 'SCNShadable' => 'SceneKit.SCNShadable, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CB20 /* #1571 'SCNShape' => 'SceneKit.SCNShape, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CC20 /* #1572 'SCNSliderConstraint' => 'SceneKit.SCNSliderConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10CD20 /* #1573 'SCNSphere' => 'SceneKit.SCNSphere, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D020 /* #1574 'SCNTechniqueSupport' => 'SceneKit.SCNTechniqueSupport, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D220 /* #1575 'SCNTimingFunction' => 'SceneKit.SCNTimingFunction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D320 /* #1576 'SCNTorus' => 'SceneKit.SCNTorus, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D420 /* #1577 'SCNTransaction' => 'SceneKit.SCNTransaction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D520 /* #1578 'SCNTransformConstraint' => 'SceneKit.SCNTransformConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D720 /* #1579 'SCNTube' => 'SceneKit.SCNTube, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x112F20 /* #1580 'GKVoiceChat' => 'GameKit.GKVoiceChat, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113120 /* #1581 'GKTurnBasedExchangeReply' => 'GameKit.GKTurnBasedExchangeReply, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113420 /* #1582 'GKMatchRequest' => 'GameKit.GKMatchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113220 /* #1583 'GKChallenge' => 'GameKit.GKChallenge, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113920 /* #1584 'GKAchievementChallenge' => 'GameKit.GKAchievementChallenge, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113E20 /* #1585 'GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114020 /* #1586 'GKBasePlayer' => 'GameKit.GKBasePlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114520 /* #1587 'GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandlerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114920 /* #1588 'GKChallengeListener' => 'GameKit.GKChallengeListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114B20 /* #1589 'GKChallengesViewController' => 'GameKit.GKChallengesViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114E20 /* #1590 'GKChallengesViewControllerDelegate' => 'GameKit.GKChallengesViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x114F20 /* #1591 'GKCloudPlayer' => 'GameKit.GKCloudPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115120 /* #1592 'GKDialogController' => 'GameKit.GKDialogController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115720 /* #1593 'GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x115A20 /* #1594 'GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116220 /* #1595 'GKInvite' => 'GameKit.GKInvite, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116720 /* #1596 'GKInviteEventListener' => 'GameKit.GKInviteEventListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x117120 /* #1597 'GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x117620 /* #1598 'GKLocalPlayerListener' => 'GameKit.GKLocalPlayerListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x118120 /* #1599 'GKMatchDelegate' => 'GameKit.GKMatchDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x118B20 /* #1600 'GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119720 /* #1601 'GKSavedGameListener' => 'GameKit.GKSavedGameListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119920 /* #1602 'GKScoreChallenge' => 'GameKit.GKScoreChallenge, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119B20 /* #1603 'GKSession' => 'GameKit.GKSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119F20 /* #1604 'GKSessionDelegate' => 'GameKit.GKSessionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11A220 /* #1605 'GKTurnBasedEventHandler' => 'GameKit.GKTurnBasedEventHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11A620 /* #1606 'GKTurnBasedEventHandlerDelegate' => 'GameKit.GKTurnBasedEventHandlerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11AA20 /* #1607 'GKTurnBasedEventListener' => 'GameKit.GKTurnBasedEventListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11AD20 /* #1608 'GKTurnBasedMatchmakerViewController' => 'GameKit.GKTurnBasedMatchmakerViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11B020 /* #1609 'GKTurnBasedMatchmakerViewControllerDelegate' => 'GameKit.GKTurnBasedMatchmakerViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11B320 /* #1610 'GKTurnBasedParticipant' => 'GameKit.GKTurnBasedParticipant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128920 /* #1611 'WebScriptObject' => 'WebKit.WebScriptObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124820 /* #1612 'DOMObject' => 'WebKit.DomObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D420 /* #1613 'DOMCSSRuleList' => 'WebKit.DomCssRuleList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D520 /* #1614 'DOMCSSStyleDeclaration' => 'WebKit.DomCssStyleDeclaration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D620 /* #1615 'DOMHTMLCollection' => 'WebKit.DomHtmlCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D720 /* #1616 'DOMMediaList' => 'WebKit.DomMediaList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D820 /* #1617 'DOMNamedNodeMap' => 'WebKit.DomNamedNodeMap, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D920 /* #1618 'DOMNodeList' => 'WebKit.DomNodeList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DA20 /* #1619 'DOMStyleSheetList' => 'WebKit.DomStyleSheetList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DB20 /* #1620 'WebFrame' => 'WebKit.WebFrame, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11D120 /* #1621 'DOMNode' => 'WebKit.DomNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120120 /* #1622 'DOMElement' => 'WebKit.DomElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121820 /* #1623 'DOMHTMLElement' => 'WebKit.DomHtmlElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DC20 /* #1624 'DOMHTMLSelectElement' => 'WebKit.DomHtmlSelectElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11DD20 /* #1625 'DOMHTMLOptionsCollection' => 'WebKit.DomHtmlOptionsCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E020 /* #1626 'WebPolicyDelegate' => 'WebKit.WebPolicyDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11E220 /* #1627 'WKWindowFeatures' => 'WebKit.WKWindowFeatures, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11EF20 /* #1628 'DOMAbstractView' => 'WebKit.DomAbstractView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F020 /* #1629 'DOMAttr' => 'WebKit.DomAttr, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F120 /* #1630 'DOMBlob' => 'WebKit.DomBlob, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F320 /* #1631 'DOMCharacterData' => 'WebKit.DomCharacterData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124E20 /* #1632 'DOMText' => 'WebKit.DomText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F220 /* #1633 'DOMCDATASection' => 'WebKit.DomCDataSection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F420 /* #1634 'DOMComment' => 'WebKit.DomComment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F920 /* #1635 'DOMCSSRule' => 'WebKit.DomCssRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F520 /* #1636 'DOMCSSCharsetRule' => 'WebKit.DomCssCharsetRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F620 /* #1637 'DOMCSSFontFaceRule' => 'WebKit.DomCssFontFaceRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F720 /* #1638 'DOMCSSMediaRule' => 'WebKit.DomCssMediaRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11F820 /* #1639 'DOMCSSPageRule' => 'WebKit.DomCssPageRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FA20 /* #1640 'DOMCSSStyleRule' => 'WebKit.DomCssStyleRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124D20 /* #1641 'DOMStyleSheet' => 'WebKit.DomStyleSheet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FB20 /* #1642 'DOMCSSStyleSheet' => 'WebKit.DomCssStyleSheet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FC20 /* #1643 'DOMCSSUnknownRule' => 'WebKit.DomCssUnknownRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FD20 /* #1644 'DOMCSSValue' => 'WebKit.DomCssValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FE20 /* #1645 'DOMDocument' => 'WebKit.DomDocument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11FF20 /* #1646 'DOMDocumentFragment' => 'WebKit.DomDocumentFragment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120020 /* #1647 'DOMDocumentType' => 'WebKit.DomDocumentType, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120220 /* #1648 'DOMEntityReference' => 'WebKit.DomEntityReference, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120320 /* #1649 'DOMEvent' => 'WebKit.DomEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120620 /* #1650 'DOMEventListener' => 'WebKit.DomEventListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120920 /* #1651 'DOMEventTarget' => 'WebKit.DomEventTarget, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120A20 /* #1652 'DOMFile' => 'WebKit.DomFile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120B20 /* #1653 'DOMFileList' => 'WebKit.DomFileList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120C20 /* #1654 'DOMHTMLAnchorElement' => 'WebKit.DomHtmlAnchorElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120D20 /* #1655 'DOMHTMLAppletElement' => 'WebKit.DomHtmlAppletElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120E20 /* #1656 'DOMHTMLAreaElement' => 'WebKit.DomHtmlAreaElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x120F20 /* #1657 'DOMHTMLBaseElement' => 'WebKit.DomHtmlBaseElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121020 /* #1658 'DOMHTMLBaseFontElement' => 'WebKit.DomHtmlBaseFontElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121120 /* #1659 'DOMHTMLBodyElement' => 'WebKit.DomHtmlBodyElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121220 /* #1660 'DOMHTMLBRElement' => 'WebKit.DomHtmlBRElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121320 /* #1661 'DOMHTMLButtonElement' => 'WebKit.DomHtmlButtonElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121420 /* #1662 'DOMHTMLDirectoryElement' => 'WebKit.DomHtmlDirectoryElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121520 /* #1663 'DOMHTMLDivElement' => 'WebKit.DomHtmlDivElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121620 /* #1664 'DOMHTMLDListElement' => 'WebKit.DomHtmlDListElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121720 /* #1665 'DOMHTMLDocument' => 'WebKit.DomHtmlDocument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121920 /* #1666 'DOMHTMLEmbedElement' => 'WebKit.DomHtmlEmbedElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121A20 /* #1667 'DOMHTMLFieldSetElement' => 'WebKit.DomHtmlFieldSetElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121B20 /* #1668 'DOMHTMLFontElement' => 'WebKit.DomHtmlFontElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121C20 /* #1669 'DOMHTMLFormElement' => 'WebKit.DomHtmlFormElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121D20 /* #1670 'DOMHTMLFrameElement' => 'WebKit.DomHtmlFrameElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121E20 /* #1671 'DOMHTMLFrameSetElement' => 'WebKit.DomHtmlFrameSetElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x121F20 /* #1672 'DOMHTMLHeadElement' => 'WebKit.DomHtmlHeadElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122020 /* #1673 'DOMHTMLHeadingElement' => 'WebKit.DomHtmlHeadingElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122120 /* #1674 'DOMHTMLHRElement' => 'WebKit.DomHtmlHRElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122220 /* #1675 'DOMHTMLHtmlElement' => 'WebKit.DomHtmlHtmlElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122320 /* #1676 'DOMHTMLIFrameElement' => 'WebKit.DomHtmlIFrameElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122420 /* #1677 'DOMHTMLImageElement' => 'WebKit.DomHtmlImageElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122520 /* #1678 'DOMHTMLInputElement' => 'WebKit.DomHtmlInputElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122620 /* #1679 'DOMHTMLLabelElement' => 'WebKit.DomHtmlLabelElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122720 /* #1680 'DOMHTMLLegendElement' => 'WebKit.DomHtmlLegendElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122820 /* #1681 'DOMHTMLLIElement' => 'WebKit.DomHtmlLIElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122920 /* #1682 'DOMHTMLLinkElement' => 'WebKit.DomHtmlLinkElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122A20 /* #1683 'DOMHTMLMapElement' => 'WebKit.DomHtmlMapElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122B20 /* #1684 'DOMHTMLMarqueeElement' => 'WebKit.DomHtmlMarqueeElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122C20 /* #1685 'DOMHTMLMenuElement' => 'WebKit.DomHtmlMenuElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122D20 /* #1686 'DOMHTMLMetaElement' => 'WebKit.DomHtmlMetaElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122E20 /* #1687 'DOMHTMLModElement' => 'WebKit.DomHtmlModElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x122F20 /* #1688 'DOMHTMLObjectElement' => 'WebKit.DomHtmlObjectElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123020 /* #1689 'DOMHTMLOListElement' => 'WebKit.DomHtmlOListElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123120 /* #1690 'DOMHTMLOptGroupElement' => 'WebKit.DomHtmlOptGroupElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123220 /* #1691 'DOMHTMLOptionElement' => 'WebKit.DomHtmlOptionElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123320 /* #1692 'DOMHTMLParagraphElement' => 'WebKit.DomHtmlParagraphElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123420 /* #1693 'DOMHTMLParamElement' => 'WebKit.DomHtmlParamElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123520 /* #1694 'DOMHTMLPreElement' => 'WebKit.DomHtmlPreElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123620 /* #1695 'DOMHTMLQuoteElement' => 'WebKit.DomHtmlQuoteElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123720 /* #1696 'DOMHTMLScriptElement' => 'WebKit.DomHtmlScriptElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123820 /* #1697 'DOMHTMLStyleElement' => 'WebKit.DomHtmlStyleElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123920 /* #1698 'DOMHTMLTableCaptionElement' => 'WebKit.DomHtmlTableCaptionElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123A20 /* #1699 'DOMHTMLTableCellElement' => 'WebKit.DomHtmlTableCellElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123B20 /* #1700 'DOMHTMLTableColElement' => 'WebKit.DomHtmlTableColElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123C20 /* #1701 'DOMHTMLTableElement' => 'WebKit.DomHtmlTableElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123D20 /* #1702 'DOMHTMLTableRowElement' => 'WebKit.DomHtmlTableRowElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123E20 /* #1703 'DOMHTMLTableSectionElement' => 'WebKit.DomHtmlTableSectionElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x123F20 /* #1704 'DOMHTMLTextAreaElement' => 'WebKit.DomHtmlTextAreaElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124020 /* #1705 'DOMImplementation' => 'WebKit.DomImplementation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124120 /* #1706 'DOMCSSImportRule' => 'WebKit.DomImportCssRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124F20 /* #1707 'DOMUIEvent' => 'WebKit.DomUIEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124220 /* #1708 'DOMKeyboardEvent' => 'WebKit.DomKeyboardEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124320 /* #1709 'DOMMouseEvent' => 'WebKit.DomMouseEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124620 /* #1710 'Xamarin_Mac__WebKit_DomNodeFilter' => 'WebKit.DomNodeFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124720 /* #1711 'DOMNodeIterator' => 'WebKit.DomNodeIterator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124920 /* #1712 'DOMOverflowEvent' => 'WebKit.DomOverflowEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124A20 /* #1713 'DOMProcessingInstruction' => 'WebKit.DomProcessingInstruction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124B20 /* #1714 'DOMProgressEvent' => 'WebKit.DomProgressEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x124C20 /* #1715 'DOMRange' => 'WebKit.DomRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x125020 /* #1716 'DOMWheelEvent' => 'WebKit.DomWheelEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126620 /* #1717 'WebArchive' => 'WebKit.WebArchive, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126720 /* #1718 'WebBackForwardList' => 'WebKit.WebBackForwardList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126820 /* #1719 'WebDataSource' => 'WebKit.WebDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126B20 /* #1720 'WebDocumentRepresentation' => 'WebKit.WebDocumentRepresentation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BCF20 /* #1721 'NSURLDownload' => 'Foundation.NSUrlDownload, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x126C20 /* #1722 'WebDownload' => 'WebKit.WebDownload, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127020 /* #1723 'WebDownloadDelegate' => 'WebKit.WebDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127420 /* #1724 'WebFrameLoadDelegate' => 'WebKit.WebFrameLoadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127520 /* #1725 'WebFrameView' => 'WebKit.WebFrameView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127620 /* #1726 'WebHistory' => 'WebKit.WebHistory, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127B20 /* #1727 'Xamarin_Mac__WebKit_WebOpenPanelResultListener' => 'WebKit.WebOpenPanelResultListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127F20 /* #1728 'Xamarin_Mac__WebKit_WebPolicyDecisionListener' => 'WebKit.WebPolicyDecisionListener, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128320 /* #1729 'WebPreferences' => 'WebKit.WebPreferences, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128420 /* #1730 'WebResource' => 'WebKit.WebResource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128820 /* #1731 'WebResourceLoadDelegate' => 'WebKit.WebResourceLoadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x128D20 /* #1732 'WebUIDelegate' => 'WebKit.WebUIDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B120 /* #1733 'WKBackForwardList' => 'WebKit.WKBackForwardList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B220 /* #1734 'WKBackForwardListItem' => 'WebKit.WKBackForwardListItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B420 /* #1735 'WKContentRuleList' => 'WebKit.WKContentRuleList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B820 /* #1736 'WKFrameInfo' => 'WebKit.WKFrameInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12BD20 /* #1737 'WKNavigation' => 'WebKit.WKNavigation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12BE20 /* #1738 'WKNavigationAction' => 'WebKit.WKNavigationAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C320 /* #1739 'WKNavigationDelegate' => 'WebKit.WKNavigationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C420 /* #1740 'WKNavigationResponse' => 'WebKit.WKNavigationResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C720 /* #1741 'WKOpenPanelParameters' => 'WebKit.WKOpenPanelParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C820 /* #1742 'WKPreferences' => 'WebKit.WKPreferences, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12C920 /* #1743 'WKProcessPool' => 'WebKit.WKProcessPool, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12CA20 /* #1744 'WKScriptMessage' => 'WebKit.WKScriptMessage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12CD20 /* #1745 'WKScriptMessageHandler' => 'WebKit.WKScriptMessageHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12CE20 /* #1746 'WKSecurityOrigin' => 'WebKit.WKSecurityOrigin, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D020 /* #1747 'WKSnapshotConfiguration' => 'WebKit.WKSnapshotConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D420 /* #1748 'WKUIDelegate' => 'WebKit.WKUIDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12D920 /* #1749 'WKUserContentController' => 'WebKit.WKUserContentController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DA20 /* #1750 'WKUserScript' => 'WebKit.WKUserScript, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DC20 /* #1751 'WKWebpagePreferences' => 'WebKit.WKWebpagePreferences, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DD20 /* #1752 'WKWebsiteDataRecord' => 'WebKit.WKWebsiteDataRecord, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E020 /* #1753 'WKWebViewConfiguration' => 'WebKit.WKWebViewConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E120 /* #1754 'NSLayoutConstraint' => 'AppKit.NSLayoutConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E220 /* #1755 '__monomac_internal_ActionDispatcher' => 'AppKit.ActionDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x160120 /* #1756 'NSSavePanel' => 'AppKit.NSSavePanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E620 /* #1757 'NSOpenPanel' => 'AppKit.NSOpenPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E720 /* #1758 'NSPageLayout' => 'AppKit.NSPageLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EB20 /* #1759 'NSPathControl' => 'AppKit.NSPathControl, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12EC20 /* #1760 'NSStatusItem' => 'AppKit.NSStatusItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FB20 /* #1761 'NSCell' => 'AppKit.NSCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F320 /* #1762 'NSActionCell' => 'AppKit.NSActionCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F420 /* #1763 '__MonoMac_NSAlertDidEndDispatcher' => 'AppKit.NSAlertDidEndDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x12F620 /* #1764 'NSApplicationDelegate' => 'AppKit.NSApplicationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152520 /* #1765 'NSController' => 'AppKit.NSController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15AA20 /* #1766 'NSObjectController' => 'AppKit.NSObjectController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F720 /* #1767 'NSArrayController' => 'AppKit.NSArrayController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F820 /* #1768 'NSBezierPath' => 'AppKit.NSBezierPath, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131220 /* #1769 'NSImageRep' => 'AppKit.NSImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12F920 /* #1770 'NSBitmapImageRep' => 'AppKit.NSBitmapImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FA20 /* #1771 'NSButton' => 'AppKit.NSButton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A220 /* #1772 'NSTextFieldCell' => 'AppKit.NSTextFieldCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FE20 /* #1773 'NSComboBoxCell' => 'AppKit.NSComboBoxCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130120 /* #1774 'NSDraggingSession' => 'AppKit.NSDraggingSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130220 /* #1775 'NSDraggingItem' => 'AppKit.NSDraggingItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130320 /* #1776 'NSPasteboard' => 'AppKit.NSPasteboard, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130420 /* #1777 'NSSharingServiceDelegate' => 'AppKit.NSSharingServiceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131020 /* #1778 'NSGraphicsContext' => 'AppKit.NSGraphicsContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131320 /* #1779 'NSLayoutManager' => 'AppKit.NSLayoutManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131420 /* #1780 'NSLevelIndicator' => 'AppKit.NSLevelIndicator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131620 /* #1781 'NSOpenGLContext' => 'AppKit.NSOpenGLContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131720 /* #1782 'NSOpenGLPixelFormat' => 'AppKit.NSOpenGLPixelFormat, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131820 /* #1783 'NSPathControlItem' => 'AppKit.NSPathControlItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131C20 /* #1784 'NSPrintInfo' => 'AppKit.NSPrintInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131F20 /* #1785 'NSSegmentedControl' => 'AppKit.NSSegmentedControl, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132120 /* #1786 'NSSlider' => 'AppKit.NSSlider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132320 /* #1787 'NSSpeechSynthesizer' => 'AppKit.NSSpeechSynthesizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132620 /* #1788 'NSStatusBar' => 'AppKit.NSStatusBar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132920 /* #1789 'NSTextContainer' => 'AppKit.NSTextContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132C20 /* #1790 'NSToolbarItem' => 'AppKit.NSToolbarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132D20 /* #1791 'NSTouch' => 'AppKit.NSTouch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132E20 /* #1792 'NSTreeController' => 'AppKit.NSTreeController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133120 /* #1793 'NSCollectionView' => 'AppKit.NSCollectionView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133220 /* #1794 'NSCollectionViewDelegate' => 'AppKit.NSCollectionViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133320 /* #1795 'NSCollectionViewDelegateFlowLayout' => 'AppKit.NSCollectionViewDelegateFlowLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169620 /* #1796 'NSTextBlock' => 'AppKit.NSTextBlock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133520 /* #1797 'NSTextTableBlock' => 'AppKit.NSTextTableBlock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156120 /* #1798 'NSFontCollection' => 'AppKit.NSFontCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133620 /* #1799 'NSMutableFontCollection' => 'AppKit.NSMutableFontCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133720 /* #1800 'NSCollectionViewLayout' => 'AppKit.NSCollectionViewLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16EC20 /* #1801 'NSTouchBarItem' => 'AppKit.NSTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133820 /* #1802 'NSColorPickerTouchBarItem' => 'AppKit.NSColorPickerTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133920 /* #1803 'NSSliderTouchBarItem' => 'AppKit.NSSliderTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x133C20 /* #1804 'NSCollectionLayoutAnchor' => 'AppKit.NSCollectionLayoutAnchor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146E20 /* #1805 'NSAccessibilityCustomAction' => 'AppKit.NSAccessibilityCustomAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x146F20 /* #1806 'NSAccessibilityCustomRotor' => 'AppKit.NSAccessibilityCustomRotor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147020 /* #1807 'NSAccessibilityCustomRotorItemResult' => 'AppKit.NSAccessibilityCustomRotorItemResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147320 /* #1808 'NSAccessibilityCustomRotorItemSearchDelegate' => 'AppKit.NSAccessibilityCustomRotorItemSearchDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147420 /* #1809 'NSAccessibilityCustomRotorSearchParameters' => 'AppKit.NSAccessibilityCustomRotorSearchParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14A820 /* #1810 'NSAlertDelegate' => 'AppKit.NSAlertDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14A920 /* #1811 'NSAlignmentFeedbackFilter' => 'AppKit.NSAlignmentFeedbackFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AC20 /* #1812 'NSAlignmentFeedbackToken' => 'AppKit.NSAlignmentFeedbackToken, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AF20 /* #1813 'NSAnimationContext' => 'AppKit.NSAnimationContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B320 /* #1814 'NSAnimationDelegate' => 'AppKit.NSAnimationDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B420 /* #1815 'NSAppearance' => 'AppKit.NSAppearance, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14B820 /* #1816 'NSAppearanceCustomization' => 'AppKit.NSAppearanceCustomization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F320 /* #1817 'NSTypesetter' => 'AppKit.NSTypesetter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14C620 /* #1818 'NSATSTypesetter' => 'AppKit.NSATSTypesetter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14C820 /* #1819 'NSBox' => 'AppKit.NSBox, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14C920 /* #1820 'NSBrowserCell' => 'AppKit.NSBrowserCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CD20 /* #1821 'NSBrowserDelegate' => 'AppKit.NSBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CE20 /* #1822 'NSButtonCell' => 'AppKit.NSButtonCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14CF20 /* #1823 'NSButtonTouchBarItem' => 'AppKit.NSButtonTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D020 /* #1824 'NSCachedImageRep' => 'AppKit.NSCachedImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D120 /* #1825 'NSCandidateListTouchBarItem' => 'AppKit.NSCandidateListTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D520 /* #1826 'NSCandidateListTouchBarItemDelegate' => 'AppKit.NSCandidateListTouchBarItemDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D620 /* #1827 'NSCIImageRep' => 'AppKit.NSCIImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14D720 /* #1828 'NSClipView' => 'AppKit.NSClipView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14DB20 /* #1829 'NSCloudSharingServiceDelegate' => 'AppKit.NSCloudSharingServiceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EA20 /* #1830 'NSCollectionLayoutItem' => 'AppKit.NSCollectionLayoutItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EF20 /* #1831 'NSCollectionLayoutSupplementaryItem' => 'AppKit.NSCollectionLayoutSupplementaryItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E020 /* #1832 'NSCollectionLayoutBoundarySupplementaryItem' => 'AppKit.NSCollectionLayoutBoundarySupplementaryItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E320 /* #1833 'NSCollectionLayoutDecorationItem' => 'AppKit.NSCollectionLayoutDecorationItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E420 /* #1834 'NSCollectionLayoutDimension' => 'AppKit.NSCollectionLayoutDimension, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E520 /* #1835 'NSCollectionLayoutEdgeSpacing' => 'AppKit.NSCollectionLayoutEdgeSpacing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E820 /* #1836 'NSCollectionLayoutGroup' => 'AppKit.NSCollectionLayoutGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14E920 /* #1837 'NSCollectionLayoutGroupCustomItem' => 'AppKit.NSCollectionLayoutGroupCustomItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EB20 /* #1838 'NSCollectionLayoutSection' => 'AppKit.NSCollectionLayoutSection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14ED20 /* #1839 'NSCollectionLayoutSize' => 'AppKit.NSCollectionLayoutSize, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14EE20 /* #1840 'NSCollectionLayoutSpacing' => 'AppKit.NSCollectionLayoutSpacing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F220 /* #1841 'NSCollectionViewCompositionalLayout' => 'AppKit.NSCollectionViewCompositionalLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F320 /* #1842 'NSCollectionViewCompositionalLayoutConfiguration' => 'AppKit.NSCollectionViewCompositionalLayoutConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14F720 /* #1843 'NSCollectionViewDataSource' => 'AppKit.NSCollectionViewDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14FD20 /* #1844 'NSCollectionViewDiffableDataSource' => 'AppKit.NSCollectionViewDiffableDataSource`2, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150120 /* #1845 'NSCollectionViewElement' => 'AppKit.NSCollectionViewElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150220 /* #1846 'NSCollectionViewFlowLayout' => 'AppKit.NSCollectionViewFlowLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150720 /* #1847 'NSCollectionViewLayoutInvalidationContext' => 'AppKit.NSCollectionViewLayoutInvalidationContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150320 /* #1848 'NSCollectionViewFlowLayoutInvalidationContext' => 'AppKit.NSCollectionViewFlowLayoutInvalidationContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150420 /* #1849 'NSCollectionViewGridLayout' => 'AppKit.NSCollectionViewGridLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150520 /* #1850 'NSCollectionViewItem' => 'AppKit.NSCollectionViewItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150620 /* #1851 'NSCollectionViewLayoutAttributes' => 'AppKit.NSCollectionViewLayoutAttributes, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150E20 /* #1852 'NSCollectionViewTransitionLayout' => 'AppKit.NSCollectionViewTransitionLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x150F20 /* #1853 'NSCollectionViewUpdateItem' => 'AppKit.NSCollectionViewUpdateItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151220 /* #1854 'NSColorList' => 'AppKit.NSColorList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151420 /* #1855 'NSColorPicker' => 'AppKit.NSColorPicker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151520 /* #1856 'NSColorSampler' => 'AppKit.NSColorSampler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151620 /* #1857 'NSColorSpace' => 'AppKit.NSColorSpace, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151720 /* #1858 'NSColorWell' => 'AppKit.NSColorWell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151B20 /* #1859 'NSComboBoxCellDataSource' => 'AppKit.NSComboBoxCellDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x151F20 /* #1860 'NSComboBoxDataSource' => 'AppKit.NSComboBoxDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A620 /* #1861 'NSTextFieldDelegate' => 'AppKit.NSTextFieldDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152320 /* #1862 'NSComboBoxDelegate' => 'AppKit.NSComboBoxDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152920 /* #1863 'NSControlTextEditingDelegate' => 'AppKit.NSControlTextEditingDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152A20 /* #1864 'NSCursor' => 'AppKit.NSCursor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152B20 /* #1865 'NSCustomImageRep' => 'AppKit.NSCustomImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152C20 /* #1866 'NSCustomTouchBarItem' => 'AppKit.NSCustomTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x152D20 /* #1867 'NSDataAsset' => 'AppKit.NSDataAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153420 /* #1868 'NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153520 /* #1869 'NSDictionaryController' => 'AppKit.NSDictionaryController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153620 /* #1870 'NSDictionaryControllerKeyValuePair' => 'AppKit.NSDictionaryControllerKeyValuePair, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153720 /* #1871 'NSDiffableDataSourceSnapshot' => 'AppKit.NSDiffableDataSourceSnapshot`2, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153920 /* #1872 'NSDockTile' => 'AppKit.NSDockTile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153C20 /* #1873 'NSDockTilePlugIn' => 'AppKit.NSDockTilePlugIn, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x153D20 /* #1874 'NSDocumentController' => 'AppKit.NSDocumentController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154120 /* #1875 'NSDraggingDestination' => 'AppKit.NSDraggingDestination, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154220 /* #1876 'NSDraggingImageComponent' => 'AppKit.NSDraggingImageComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154920 /* #1877 'NSDraggingSource' => 'AppKit.NSDraggingSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x154E20 /* #1878 'NSDrawerDelegate' => 'AppKit.NSDrawerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155420 /* #1879 'NSEPSImageRep' => 'AppKit.NSEPSImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155720 /* #1880 'NSFilePromiseProvider' => 'AppKit.NSFilePromiseProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155B20 /* #1881 'NSFilePromiseProviderDelegate' => 'AppKit.NSFilePromiseProviderDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155C20 /* #1882 'NSFilePromiseReceiver' => 'AppKit.NSFilePromiseReceiver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x155D20 /* #1883 'NSFontAssetRequest' => 'AppKit.NSFontAssetRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156220 /* #1884 'NSFontDescriptor' => 'AppKit.NSFontDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156520 /* #1885 'NSFontManager' => 'AppKit.NSFontManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156620 /* #1886 'NSFontPanel' => 'AppKit.NSFontPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E920 /* #1887 'NSMatrix' => 'AppKit.NSMatrix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156820 /* #1888 'NSForm' => 'AppKit.NSForm, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156920 /* #1889 'NSFormCell' => 'AppKit.NSFormCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156E20 /* #1890 'NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x156F20 /* #1891 'NSGlyphGenerator' => 'AppKit.NSGlyphGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157020 /* #1892 'NSGlyphInfo' => 'AppKit.NSGlyphInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157120 /* #1893 'NSGridCell' => 'AppKit.NSGridCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157220 /* #1894 'NSGridColumn' => 'AppKit.NSGridColumn, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157320 /* #1895 'NSGridRow' => 'AppKit.NSGridRow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157420 /* #1896 'NSGridView' => 'AppKit.NSGridView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157520 /* #1897 'NSGroupTouchBarItem' => 'AppKit.NSGroupTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157620 /* #1898 'NSHapticFeedbackManager' => 'AppKit.NSHapticFeedbackManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157920 /* #1899 'NSHapticFeedbackPerformer' => 'AppKit.NSHapticFeedbackPerformer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157E20 /* #1900 'NSImageCell' => 'AppKit.NSImageCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158220 /* #1901 'NSImageDelegate' => 'AppKit.NSImageDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158620 /* #1902 'NSImageView' => 'AppKit.NSImageView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158A20 /* #1903 'NSLayoutAnchor' => 'AppKit.NSLayoutAnchor`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158B20 /* #1904 'NSLayoutDimension' => 'AppKit.NSLayoutDimension, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x158C20 /* #1905 'NSLayoutGuide' => 'AppKit.NSLayoutGuide, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159120 /* #1906 'NSLayoutManagerDelegate' => 'AppKit.NSLayoutManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159220 /* #1907 'NSLayoutXAxisAnchor' => 'AppKit.NSLayoutXAxisAnchor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159320 /* #1908 'NSLayoutYAxisAnchor' => 'AppKit.NSLayoutYAxisAnchor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159420 /* #1909 'NSLevelIndicatorCell' => 'AppKit.NSLevelIndicatorCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159720 /* #1910 'NSMatrixDelegate' => 'AppKit.NSMatrixDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159C20 /* #1911 'NSMenuDelegate' => 'AppKit.NSMenuDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159D20 /* #1912 'NSMenuItemCell' => 'AppKit.NSMenuItemCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A020 /* #1913 'NSMenuToolbarItem' => 'AppKit.NSMenuToolbarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A320 /* #1914 'NSMenuView' => 'AppKit.NSMenuView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C320 /* #1915 'NSParagraphStyle' => 'AppKit.NSParagraphStyle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A520 /* #1916 'NSMutableParagraphStyle' => 'AppKit.NSMutableParagraphStyle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15A620 /* #1917 'NSNib' => 'AppKit.NSNib, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15AB20 /* #1918 'NSOpenGLLayer' => 'AppKit.NSOpenGLLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15AC20 /* #1919 'NSOpenGLPixelBuffer' => 'AppKit.NSOpenGLPixelBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15AD20 /* #1920 'NSOpenGLView' => 'AppKit.NSOpenGLView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15B120 /* #1921 'NSOpenSavePanelDelegate' => 'AppKit.NSOpenSavePanelDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15B620 /* #1922 'NSOutlineViewDataSource' => 'AppKit.NSOutlineViewDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15BA20 /* #1923 'NSOutlineViewDelegate' => 'AppKit.NSOutlineViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C120 /* #1924 'NSPageControllerDelegate' => 'AppKit.NSPageControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C420 /* #1925 'NSPasteboardItem' => 'AppKit.NSPasteboardItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15C720 /* #1926 'NSPasteboardItemDataProvider' => 'AppKit.NSPasteboardItemDataProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15CA20 /* #1927 'NSPasteboardReading' => 'AppKit.NSPasteboardReading, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D120 /* #1928 'NSPasteboardWriting' => 'AppKit.NSPasteboardWriting, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D720 /* #1929 'NSPathCellDelegate' => 'AppKit.NSPathCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15D820 /* #1930 'NSPathComponentCell' => 'AppKit.NSPathComponentCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DC20 /* #1931 'NSPathControlDelegate' => 'AppKit.NSPathControlDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DD20 /* #1932 'NSPDFImageRep' => 'AppKit.NSPdfImageRep, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15DE20 /* #1933 'NSPickerTouchBarItem' => 'AppKit.NSPickerTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E520 /* #1934 'NSPopoverDelegate' => 'AppKit.NSPopoverDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E620 /* #1935 'NSPopoverTouchBarItem' => 'AppKit.NSPopoverTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F620 /* #1936 'NSRuleEditor' => 'AppKit.NSRuleEditor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E720 /* #1937 'NSPredicateEditor' => 'AppKit.NSPredicateEditor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E820 /* #1938 'NSPressureConfiguration' => 'AppKit.NSPressureConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E920 /* #1939 'NSPrinter' => 'AppKit.NSPrinter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15EA20 /* #1940 'NSPrintOperation' => 'AppKit.NSPrintOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15EB20 /* #1941 'NSPrintPanel' => 'AppKit.NSPrintPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15EE20 /* #1942 'NSPrintPanelAccessorizing' => 'AppKit.NSPrintPanelAccessorizing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15EF20 /* #1943 'NSPrintPreviewGraphicsContext' => 'AppKit.NSPrintPreviewGraphicsContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F020 /* #1944 'NSProgressIndicator' => 'AppKit.NSProgressIndicator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F320 /* #1945 'NSRemoteOpenPanel' => 'AppKit.NSRemoteOpenPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15F420 /* #1946 'NSRemoteSavePanel' => 'AppKit.NSRemoteSavePanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15FA20 /* #1947 'NSRuleEditorDelegate' => 'AppKit.NSRuleEditorDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15FB20 /* #1948 'NSRulerMarker' => 'AppKit.NSRulerMarker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15FD20 /* #1949 'NSRulerView' => 'AppKit.NSRulerView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160020 /* #1950 'NSRunningApplication' => 'AppKit.NSRunningApplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160720 /* #1951 'NSScrubber' => 'AppKit.NSScrubber, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160820 /* #1952 'NSScrubberArrangedView' => 'AppKit.NSScrubberArrangedView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160B20 /* #1953 'NSScrubberDataSource' => 'AppKit.NSScrubberDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160F20 /* #1954 'NSScrubberDelegate' => 'AppKit.NSScrubberDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161720 /* #1955 'NSScrubberLayout' => 'AppKit.NSScrubberLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161020 /* #1956 'NSScrubberFlowLayout' => 'AppKit.NSScrubberFlowLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161420 /* #1957 'NSScrubberFlowLayoutDelegate' => 'AppKit.NSScrubberFlowLayoutDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161620 /* #1958 'NSScrubberItemView' => 'AppKit.NSScrubberItemView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161520 /* #1959 'NSScrubberImageItemView' => 'AppKit.NSScrubberImageItemView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161820 /* #1960 'NSScrubberLayoutAttributes' => 'AppKit.NSScrubberLayoutAttributes, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161920 /* #1961 'NSScrubberProportionalLayout' => 'AppKit.NSScrubberProportionalLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161A20 /* #1962 'NSScrubberSelectionStyle' => 'AppKit.NSScrubberSelectionStyle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161B20 /* #1963 'NSScrubberSelectionView' => 'AppKit.NSScrubberSelectionView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161C20 /* #1964 'NSScrubberTextItemView' => 'AppKit.NSScrubberTextItemView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x161E20 /* #1965 'NSSearchFieldCell' => 'AppKit.NSSearchFieldCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162220 /* #1966 'NSSearchFieldDelegate' => 'AppKit.NSSearchFieldDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132A20 /* #1967 'NSTextField' => 'AppKit.NSTextField, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162320 /* #1968 'NSSecureTextField' => 'AppKit.NSSecureTextField, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162420 /* #1969 'NSSecureTextFieldCell' => 'AppKit.NSSecureTextFieldCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162620 /* #1970 'NSSegmentedCell' => 'AppKit.NSSegmentedCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162A20 /* #1971 'NSSeguePerforming' => 'AppKit.NSSeguePerforming, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x162E20 /* #1972 'NSShadow' => 'AppKit.NSShadow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163B20 /* #1973 'NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePickerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163C20 /* #1974 'NSSharingServicePickerToolbarItem' => 'AppKit.NSSharingServicePickerToolbarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x163F20 /* #1975 'Xamarin_Mac__AppKit_NSSharingServicePickerToolbarItemDelegate' => 'AppKit.NSSharingServicePickerToolbarItemDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164020 /* #1976 'NSSharingServicePickerTouchBarItem' => 'AppKit.NSSharingServicePickerTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164320 /* #1977 'NSSharingServicePickerTouchBarItemDelegate' => 'AppKit.NSSharingServicePickerTouchBarItemDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164520 /* #1978 'NSSliderAccessoryBehavior' => 'AppKit.NSSliderAccessoryBehavior, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164620 /* #1979 'NSSliderCell' => 'AppKit.NSSliderCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164B20 /* #1980 'NSSoundDelegate' => 'AppKit.NSSoundDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164C20 /* #1981 'NSSpeechRecognizer' => 'AppKit.NSSpeechRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165020 /* #1982 'NSSpeechRecognizerDelegate' => 'AppKit.NSSpeechRecognizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165420 /* #1983 'NSSpeechSynthesizerDelegate' => 'AppKit.NSSpeechSynthesizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165720 /* #1984 'NSSplitViewController' => 'AppKit.NSSplitViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165B20 /* #1985 'NSSplitViewDelegate' => 'AppKit.NSSplitViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165C20 /* #1986 'NSSplitViewItem' => 'AppKit.NSSplitViewItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166020 /* #1987 'NSSpringLoadingDestination' => 'AppKit.NSSpringLoadingDestination, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166120 /* #1988 'NSStackView' => 'AppKit.NSStackView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166520 /* #1989 'NSStackViewDelegate' => 'AppKit.NSStackViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166A20 /* #1990 'NSStatusBarButton' => 'AppKit.NSStatusBarButton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166B20 /* #1991 'NSStepper' => 'AppKit.NSStepper, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166C20 /* #1992 'NSStepperCell' => 'AppKit.NSStepperCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166D20 /* #1993 'NSStepperTouchBarItem' => 'AppKit.NSStepperTouchBarItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166E20 /* #1994 'NSStoryboard' => 'AppKit.NSStoryboard, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x166F20 /* #1995 'NSStoryboardSegue' => 'AppKit.NSStoryboardSegue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167320 /* #1996 'NSStringDrawingContext' => 'AppKit.NSStringDrawingContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167420 /* #1997 'NSSwitch' => 'AppKit.NSSwitch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167520 /* #1998 'NSTableCellView' => 'AppKit.NSTableCellView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167620 /* #1999 'NSTableColumn' => 'AppKit.NSTableColumn, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167720 /* #2000 'NSTableHeaderCell' => 'AppKit.NSTableHeaderCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167820 /* #2001 'NSTableHeaderView' => 'AppKit.NSTableHeaderView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x167920 /* #2002 'NSTableRowView' => 'AppKit.NSTableRowView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168020 /* #2003 'NSTableViewDataSource' => 'AppKit.NSTableViewDataSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168420 /* #2004 'NSTableViewDelegate' => 'AppKit.NSTableViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168520 /* #2005 'NSTableViewRowAction' => 'AppKit.NSTableViewRowAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168620 /* #2006 'NSTableViewSource' => 'AppKit.NSTableViewSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168920 /* #2007 'NSTabViewController' => 'AppKit.NSTabViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168D20 /* #2008 'NSTabViewDelegate' => 'AppKit.NSTabViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x168E20 /* #2009 'NSTabViewItem' => 'AppKit.NSTabViewItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169120 /* #2010 'NSTextAttachment' => 'AppKit.NSTextAttachment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169220 /* #2011 'NSTextAttachmentCell' => 'AppKit.NSTextAttachmentCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169520 /* #2012 'NSTextAttachmentContainer' => 'AppKit.NSTextAttachmentContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169920 /* #2013 'NSTextCheckingController' => 'AppKit.NSTextCheckingController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169F20 /* #2014 'NSTextDelegate' => 'AppKit.NSTextDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16A720 /* #2015 'NSTextFinder' => 'AppKit.NSTextFinder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16AB20 /* #2016 'NSTextFinderBarContainer' => 'AppKit.NSTextFinderBarContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16AE20 /* #2017 'NSTextFinderClient' => 'AppKit.NSTextFinderClient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B520 /* #2018 'NSTextInputClient' => 'AppKit.NSTextInputClient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16BB20 /* #2019 'NSTextList' => 'AppKit.NSTextList, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16C320 /* #2020 'NSTextStorageDelegate' => 'AppKit.NSTextStorageDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16C420 /* #2021 'NSTextTab' => 'AppKit.NSTextTab, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16C520 /* #2022 'NSTextTable' => 'AppKit.NSTextTable, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16CE20 /* #2023 'NSTextViewDelegate' => 'AppKit.NSTextViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16CF20 /* #2024 'NSTitlebarAccessoryViewController' => 'AppKit.NSTitlebarAccessoryViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D020 /* #2025 'NSTokenField' => 'AppKit.NSTokenField, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D120 /* #2026 'NSTokenFieldCell' => 'AppKit.NSTokenFieldCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D520 /* #2027 'NSTokenFieldCellDelegate' => 'AppKit.NSTokenFieldCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D920 /* #2028 'NSTokenFieldDelegate' => 'AppKit.NSTokenFieldDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16DE20 /* #2029 'NSToolbarDelegate' => 'AppKit.NSToolbarDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16DF20 /* #2030 'NSToolbarItemGroup' => 'AppKit.NSToolbarItemGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16EB20 /* #2031 'NSTouchBarDelegate' => 'AppKit.NSTouchBarDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F120 /* #2032 'NSTrackingArea' => 'AppKit.NSTrackingArea, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F220 /* #2033 'NSTreeNode' => 'AppKit.NSTreeNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F420 /* #2034 'NSUserDefaultsController' => 'AppKit.NSUserDefaultsController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16F720 /* #2035 'NSUserInterfaceCompressionOptions' => 'AppKit.NSUserInterfaceCompressionOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x14AD20 /* #2036 'NSAnimation' => 'AppKit.NSAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170120 /* #2037 'NSViewAnimation' => 'AppKit.NSViewAnimation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170520 /* #2038 'NSViewControllerPresentationAnimator' => 'AppKit.NSViewControllerPresentationAnimator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170820 /* #2039 'NSVisualEffectView' => 'AppKit.NSVisualEffectView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x170F20 /* #2040 'NSWindowDelegate' => 'AppKit.NSWindowDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171220 /* #2041 'NSWindowRestoration' => 'AppKit.NSWindowRestoration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171320 /* #2042 'NSWindowTab' => 'AppKit.NSWindowTab, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171420 /* #2043 'NSWindowTabGroup' => 'AppKit.NSWindowTabGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171620 /* #2044 'NSWorkspaceAuthorization' => 'AppKit.NSWorkspaceAuthorization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x171720 /* #2045 'NSWorkspaceOpenConfiguration' => 'AppKit.NSWorkspaceOpenConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17D220 /* #2046 'MLDictionaryFeatureProvider' => 'CoreML.MLDictionaryFeatureProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17D420 /* #2047 'MLMultiArrayConstraint' => 'CoreML.MLMultiArrayConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17D520 /* #2048 'MLArrayBatchProvider' => 'CoreML.MLArrayBatchProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17DF20 /* #2049 'Xamarin_Mac__CoreML_MLCustomModel' => 'CoreML.MLCustomModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17E020 /* #2050 'MLDictionaryConstraint' => 'CoreML.MLDictionaryConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17E120 /* #2051 'MLFeatureDescription' => 'CoreML.MLFeatureDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17E520 /* #2052 'MLFeatureValue' => 'CoreML.MLFeatureValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17E820 /* #2053 'MLImageConstraint' => 'CoreML.MLImageConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17E920 /* #2054 'MLImageSize' => 'CoreML.MLImageSize, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17EA20 /* #2055 'MLImageSizeConstraint' => 'CoreML.MLImageSizeConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17EC20 /* #2056 'MLKey' => 'CoreML.MLKey, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17ED20 /* #2057 'MLMetricKey' => 'CoreML.MLMetricKey, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17EE20 /* #2058 'MLModel' => 'CoreML.MLModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17EF20 /* #2059 'MLModelConfiguration' => 'CoreML.MLModelConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17F020 /* #2060 'MLModelDescription' => 'CoreML.MLModelDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17F620 /* #2061 'MLMultiArrayShapeConstraint' => 'CoreML.MLMultiArrayShapeConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17F820 /* #2062 'MLNumericConstraint' => 'CoreML.MLNumericConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17F920 /* #2063 'MLParameterDescription' => 'CoreML.MLParameterDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17FA20 /* #2064 'MLParameterKey' => 'CoreML.MLParameterKey, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17FB20 /* #2065 'MLPredictionOptions' => 'CoreML.MLPredictionOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17FC20 /* #2066 'MLSequence' => 'CoreML.MLSequence, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17FD20 /* #2067 'MLSequenceConstraint' => 'CoreML.MLSequenceConstraint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17FE20 /* #2068 'MLTask' => 'CoreML.MLTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x180020 /* #2069 'MLUpdateContext' => 'CoreML.MLUpdateContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x180220 /* #2070 'MLUpdateProgressHandlers' => 'CoreML.MLUpdateProgressHandlers, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x180320 /* #2071 'MLUpdateTask' => 'CoreML.MLUpdateTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C720 /* #2072 'NSPropertyDescription' => 'CoreData.NSPropertyDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188220 /* #2073 'NSAttributeDescription' => 'CoreData.NSAttributeDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188320 /* #2074 'NSEntityDescription' => 'CoreData.NSEntityDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188420 /* #2075 'NSMergeConflict' => 'CoreData.NSMergeConflict, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188520 /* #2076 'NSMergePolicy' => 'CoreData.NSMergePolicy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C320 /* #2077 'NSPersistentStoreRequest' => 'CoreData.NSPersistentStoreRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188B20 /* #2078 'NSAsynchronousFetchRequest' => 'CoreData.NSAsynchronousFetchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C520 /* #2079 'NSPersistentStoreResult' => 'CoreData.NSPersistentStoreResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C020 /* #2080 'NSPersistentStoreAsynchronousResult' => 'CoreData.NSPersistentStoreAsynchronousResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188C20 /* #2081 'NSAsynchronousFetchResult' => 'CoreData.NSAsynchronousFetchResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188620 /* #2082 'NSPersistentStore' => 'CoreData.NSPersistentStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188D20 /* #2083 'NSAtomicStore' => 'CoreData.NSAtomicStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x188E20 /* #2084 'NSAtomicStoreCacheNode' => 'CoreData.NSAtomicStoreCacheNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189020 /* #2085 'NSBatchDeleteRequest' => 'CoreData.NSBatchDeleteRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189220 /* #2086 'NSBatchDeleteResult' => 'CoreData.NSBatchDeleteResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189320 /* #2087 'NSBatchInsertRequest' => 'CoreData.NSBatchInsertRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189520 /* #2088 'NSBatchInsertResult' => 'CoreData.NSBatchInsertResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189620 /* #2089 'NSBatchUpdateRequest' => 'CoreData.NSBatchUpdateRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189820 /* #2090 'NSBatchUpdateResult' => 'CoreData.NSBatchUpdateResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189920 /* #2091 'NSConstraintConflict' => 'CoreData.NSConstraintConflict, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189A20 /* #2092 'NSCoreDataCoreSpotlightDelegate' => 'CoreData.NSCoreDataCoreSpotlightDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189C20 /* #2093 'NSDerivedAttributeDescription' => 'CoreData.NSDerivedAttributeDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189D20 /* #2094 'NSEntityMapping' => 'CoreData.NSEntityMapping, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x189F20 /* #2095 'NSEntityMigrationPolicy' => 'CoreData.NSEntityMigrationPolicy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A020 /* #2096 'NSExpressionDescription' => 'CoreData.NSExpressionDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A120 /* #2097 'NSFetchedPropertyDescription' => 'CoreData.NSFetchedPropertyDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A320 /* #2098 'NSFetchIndexDescription' => 'CoreData.NSFetchIndexDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A420 /* #2099 'NSFetchIndexElementDescription' => 'CoreData.NSFetchIndexElementDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A620 /* #2100 'NSFetchRequest' => 'CoreData.NSFetchRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7220 /* #2101 'NSExpression' => 'Foundation.NSExpression, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18A720 /* #2102 'NSFetchRequestExpression' => 'CoreData.NSFetchRequestExpression, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AB20 /* #2103 'NSIncrementalStore' => 'CoreData.NSIncrementalStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AC20 /* #2104 'NSIncrementalStoreNode' => 'CoreData.NSIncrementalStoreNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AD20 /* #2105 'NSManagedObject' => 'CoreData.NSManagedObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B020 /* #2106 'NSManagedObjectID' => 'CoreData.NSManagedObjectID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B120 /* #2107 'NSManagedObjectModel' => 'CoreData.NSManagedObjectModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B220 /* #2108 'NSMappingModel' => 'CoreData.NSMappingModel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B420 /* #2109 'NSMigrationManager' => 'CoreData.NSMigrationManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B820 /* #2110 'NSPersistentContainer' => 'CoreData.NSPersistentContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B520 /* #2111 'NSPersistentCloudKitContainer' => 'CoreData.NSPersistentCloudKitContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B620 /* #2112 'NSPersistentCloudKitContainerOptions' => 'CoreData.NSPersistentCloudKitContainerOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18B920 /* #2113 'NSPersistentHistoryChange' => 'CoreData.NSPersistentHistoryChange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18BA20 /* #2114 'NSPersistentHistoryChangeRequest' => 'CoreData.NSPersistentHistoryChangeRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18BC20 /* #2115 'NSPersistentHistoryResult' => 'CoreData.NSPersistentHistoryResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18BE20 /* #2116 'NSPersistentHistoryToken' => 'CoreData.NSPersistentHistoryToken, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18BF20 /* #2117 'NSPersistentHistoryTransaction' => 'CoreData.NSPersistentHistoryTransaction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C220 /* #2118 'NSPersistentStoreDescription' => 'CoreData.NSPersistentStoreDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C820 /* #2119 'NSPropertyMapping' => 'CoreData.NSPropertyMapping, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C920 /* #2120 'NSQueryGenerationToken' => 'CoreData.NSQueryGenerationToken, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18CA20 /* #2121 'NSRelationshipDescription' => 'CoreData.NSRelationshipDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18CB20 /* #2122 'NSSaveChangesRequest' => 'CoreData.NSSaveChangesRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18E220 /* #2123 'CBAttribute' => 'CoreBluetooth.CBAttribute, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18F020 /* #2124 'CBCharacteristic' => 'CoreBluetooth.CBCharacteristic, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18D220 /* #2125 'CBMutableCharacteristic' => 'CoreBluetooth.CBMutableCharacteristic, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191720 /* #2126 'CBService' => 'CoreBluetooth.CBService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18D320 /* #2127 'CBMutableService' => 'CoreBluetooth.CBMutableService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18D420 /* #2128 'CBUUID' => 'CoreBluetooth.CBUUID, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18E120 /* #2129 'CBATTRequest' => 'CoreBluetooth.CBATTRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FE20 /* #2130 'CBPeer' => 'CoreBluetooth.CBPeer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18E420 /* #2131 'CBCentral' => 'CoreBluetooth.CBCentral, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18EE20 /* #2132 'CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18F620 /* #2133 'CBDescriptor' => 'CoreBluetooth.CBDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18F920 /* #2134 'CBL2CAPChannel' => 'CoreBluetooth.CBL2CapChannel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FA20 /* #2135 'CBManager' => 'CoreBluetooth.CBManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18FD20 /* #2136 'CBMutableDescriptor' => 'CoreBluetooth.CBMutableDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x190820 /* #2137 'CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheralDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191420 /* #2138 'CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191A20 /* #2139 'AVCaptureView' => 'AVKit.AVCaptureView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x191E20 /* #2140 'AVCaptureViewDelegate' => 'AVKit.AVCaptureViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192120 /* #2141 'AVPictureInPictureController' => 'AVKit.AVPictureInPictureController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192520 /* #2142 'AVPictureInPictureControllerDelegate' => 'AVKit.AVPictureInPictureControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192620 /* #2143 'AVPlayerView' => 'AVKit.AVPlayerView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192B20 /* #2144 'Xamarin_Mac__AVKit_AVPlayerViewPictureInPictureDelegate' => 'AVKit.AVPlayerViewPictureInPictureDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x192D20 /* #2145 'AVRoutePickerView' => 'AVKit.AVRoutePickerView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193220 /* #2146 'AVRoutePickerViewDelegate' => 'AVKit.AVRoutePickerViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193320 /* #2147 'AVAssetImageGenerator' => 'AVFoundation.AVAssetImageGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198420 /* #2148 'AVAssetReaderOutput' => 'AVFoundation.AVAssetReaderOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193420 /* #2149 'AVAssetReaderVideoCompositionOutput' => 'AVFoundation.AVAssetReaderVideoCompositionOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193520 /* #2150 'AVAssetResourceLoadingDataRequest' => 'AVFoundation.AVAssetResourceLoadingDataRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193620 /* #2151 'AVAudioBuffer' => 'AVFoundation.AVAudioBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193720 /* #2152 'AVAudioChannelLayout' => 'AVFoundation.AVAudioChannelLayout, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193820 /* #2153 'AVAudioFormat' => 'AVFoundation.AVAudioFormat, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193920 /* #2154 'AVAudioPlayer' => 'AVFoundation.AVAudioPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193A20 /* #2155 'AVAudioRecorder' => 'AVFoundation.AVAudioRecorder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193B20 /* #2156 'AVCaptureConnection' => 'AVFoundation.AVCaptureConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A1E20 /* #2157 'AVCaptureInput' => 'AVFoundation.AVCaptureInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193C20 /* #2158 'AVCaptureDeviceInput' => 'AVFoundation.AVCaptureDeviceInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193E20 /* #2159 'AVCaptureSynchronizedDataCollection' => 'AVFoundation.AVCaptureSynchronizedDataCollection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194020 /* #2160 'AVFoundation_AVCaptureDataOutputSynchronizer' => 'AVFoundation.AVCaptureDataOutputSynchronizer, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x194220 /* #2161 'AVFoundation_AVCaptureDataOutputSynchronizerDelegate' => 'AVFoundation.AVCaptureDataOutputSynchronizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x194420 /* #2162 'AVAssetTrack' => 'AVFoundation.AVAssetTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A4020 /* #2163 'AVCompositionTrack' => 'AVFoundation.AVCompositionTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194520 /* #2164 'AVMutableCompositionTrack' => 'AVFoundation.AVMutableCompositionTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194620 /* #2165 'AVCaptureAudioDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194820 /* #2166 'AVCaptureInputPort' => 'AVFoundation.AVCaptureInputPort, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194920 /* #2167 'AVAudioConnectionPoint' => 'AVFoundation.AVAudioConnectionPoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194D20 /* #2168 'AVContentKeyResponse' => 'AVFoundation.AVContentKeyResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194E20 /* #2169 'AVDepthData' => 'AVFoundation.AVDepthData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194320 /* #2170 'AVAsset' => 'AVFoundation.AVAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AEA20 /* #2171 'AVURLAsset' => 'AVFoundation.AVUrlAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194F20 /* #2172 'AVFragmentedAsset' => 'AVFoundation.AVFragmentedAsset, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195020 /* #2173 'AVFragmentedAssetTrack' => 'AVFoundation.AVFragmentedAssetTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195220 /* #2174 'AVPlayerLayer' => 'AVFoundation.AVPlayerLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195420 /* #2175 'AVMetadataItemFilter' => 'AVFoundation.AVMetadataItemFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195720 /* #2176 'AVTextStyleRule' => 'AVFoundation.AVTextStyleRule, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19CB20 /* #2177 'AVAudioPlayerDelegate' => 'AVFoundation.AVAudioPlayerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195A20 /* #2178 'AVFoundation_InternalAVAudioPlayerDelegate' => 'AVFoundation.InternalAVAudioPlayerDelegate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x19D320 /* #2179 'AVAudioRecorderDelegate' => 'AVFoundation.AVAudioRecorderDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195B20 /* #2180 'AVFoundation_InternalAVAudioRecorderDelegate' => 'AVFoundation.InternalAVAudioRecorderDelegate, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x195F20 /* #2181 'AVPlayerLooper' => 'AVFoundation.AVPlayerLooper, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x197B20 /* #2182 'AVAssetCache' => 'AVFoundation.AVAssetCache, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198220 /* #2183 'AVAssetReader' => 'AVFoundation.AVAssetReader, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198320 /* #2184 'AVAssetReaderAudioMixOutput' => 'AVFoundation.AVAssetReaderAudioMixOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198520 /* #2185 'AVAssetReaderOutputMetadataAdaptor' => 'AVFoundation.AVAssetReaderOutputMetadataAdaptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198620 /* #2186 'AVAssetReaderSampleReferenceOutput' => 'AVFoundation.AVAssetReaderSampleReferenceOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198820 /* #2187 'AVAssetReaderTrackOutput' => 'AVFoundation.AVAssetReaderTrackOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198A20 /* #2188 'AVAssetResourceLoader' => 'AVFoundation.AVAssetResourceLoader, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198E20 /* #2189 'AVAssetResourceLoaderDelegate' => 'AVFoundation.AVAssetResourceLoaderDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x198F20 /* #2190 'AVAssetResourceLoadingContentInformationRequest' => 'AVFoundation.AVAssetResourceLoadingContentInformationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199020 /* #2191 'AVAssetResourceLoadingRequest' => 'AVFoundation.AVAssetResourceLoadingRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199120 /* #2192 'AVAssetResourceLoadingRequestor' => 'AVFoundation.AVAssetResourceLoadingRequestor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199220 /* #2193 'AVAssetResourceRenewalRequest' => 'AVFoundation.AVAssetResourceRenewalRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199320 /* #2194 'AVAssetTrackGroup' => 'AVFoundation.AVAssetTrackGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199420 /* #2195 'AVAssetTrackSegment' => 'AVFoundation.AVAssetTrackSegment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199720 /* #2196 'AVAssetWriterInput' => 'AVFoundation.AVAssetWriterInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6D20 /* #2197 'AVMediaSelectionGroup' => 'AVFoundation.AVMediaSelectionGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199820 /* #2198 'AVAssetWriterInputGroup' => 'AVFoundation.AVAssetWriterInputGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199B20 /* #2199 'AVAssetWriterInputMetadataAdaptor' => 'AVFoundation.AVAssetWriterInputMetadataAdaptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199C20 /* #2200 'AVAssetWriterInputPassDescription' => 'AVFoundation.AVAssetWriterInputPassDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199D20 /* #2201 'AVAssetWriterInputPixelBufferAdaptor' => 'AVFoundation.AVAssetWriterInputPixelBufferAdaptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199F20 /* #2202 'AVAsynchronousCIImageFilteringRequest' => 'AVFoundation.AVAsynchronousCIImageFilteringRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19A220 /* #2203 'AVAsynchronousKeyValueLoading' => 'AVFoundation.AVAsynchronousKeyValueLoading, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19A320 /* #2204 'AVAsynchronousVideoCompositionRequest' => 'AVFoundation.AVAsynchronousVideoCompositionRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19A720 /* #2205 'AVAudio3DMixing' => 'AVFoundation.AVAudio3DMixing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19AD20 /* #2206 'AVAudioCompressedBuffer' => 'AVFoundation.AVAudioCompressedBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19AE20 /* #2207 'AVAudioConverter' => 'AVFoundation.AVAudioConverter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19B720 /* #2208 'AVAudioEnvironmentDistanceAttenuationParameters' => 'AVFoundation.AVAudioEnvironmentDistanceAttenuationParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C520 /* #2209 'AVAudioNode' => 'AVFoundation.AVAudioNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19B820 /* #2210 'AVAudioEnvironmentNode' => 'AVFoundation.AVAudioEnvironmentNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BA20 /* #2211 'AVAudioEnvironmentReverbParameters' => 'AVFoundation.AVAudioEnvironmentReverbParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BB20 /* #2212 'AVAudioFile' => 'AVFoundation.AVAudioFile, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BD20 /* #2213 'AVAudioIONode' => 'AVFoundation.AVAudioIONode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BC20 /* #2214 'AVAudioInputNode' => 'AVFoundation.AVAudioInputNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BE20 /* #2215 'AVAudioMix' => 'AVFoundation.AVAudioMix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19BF20 /* #2216 'AVAudioMixerNode' => 'AVFoundation.AVAudioMixerNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C320 /* #2217 'AVAudioMixingDestination' => 'AVFoundation.AVAudioMixingDestination, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C420 /* #2218 'AVAudioMixInputParameters' => 'AVFoundation.AVAudioMixInputParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C620 /* #2219 'AVAudioOutputNode' => 'AVFoundation.AVAudioOutputNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C720 /* #2220 'AVAudioPCMBuffer' => 'AVFoundation.AVAudioPcmBuffer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19D420 /* #2221 'AVAudioSequencer' => 'AVFoundation.AVAudioSequencer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19E520 /* #2222 'AVAudioSinkNode' => 'AVFoundation.AVAudioSinkNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19E620 /* #2223 'AVAudioSourceNode' => 'AVFoundation.AVAudioSourceNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19E920 /* #2224 'AVAudioStereoMixing' => 'AVFoundation.AVAudioStereoMixing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19EA20 /* #2225 'AVAudioTime' => 'AVFoundation.AVAudioTime, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19EC20 /* #2226 'AVAudioUnit' => 'AVFoundation.AVAudioUnit, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F120 /* #2227 'AVAudioUnitEffect' => 'AVFoundation.AVAudioUnitEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19EE20 /* #2228 'AVAudioUnitDelay' => 'AVFoundation.AVAudioUnitDelay, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19EF20 /* #2229 'AVAudioUnitDistortion' => 'AVFoundation.AVAudioUnitDistortion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F220 /* #2230 'AVAudioUnitEQ' => 'AVFoundation.AVAudioUnitEQ, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F320 /* #2231 'AVAudioUnitEQFilterParameters' => 'AVFoundation.AVAudioUnitEQFilterParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F520 /* #2232 'AVAudioUnitGenerator' => 'AVFoundation.AVAudioUnitGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F720 /* #2233 'AVAudioUnitMIDIInstrument' => 'AVFoundation.AVAudioUnitMidiInstrument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19F820 /* #2234 'AVAudioUnitReverb' => 'AVFoundation.AVAudioUnitReverb, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19FA20 /* #2235 'AVAudioUnitSampler' => 'AVFoundation.AVAudioUnitSampler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19FB20 /* #2236 'AVAudioUnitTimeEffect' => 'AVFoundation.AVAudioUnitTimeEffect, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19FC20 /* #2237 'AVAudioUnitTimePitch' => 'AVFoundation.AVAudioUnitTimePitch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19FE20 /* #2238 'AVAudioUnitVarispeed' => 'AVFoundation.AVAudioUnitVarispeed, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0120 /* #2239 'AVCameraCalibrationData' => 'AVFoundation.AVCameraCalibrationData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0220 /* #2240 'AVCaptureAudioChannel' => 'AVFoundation.AVCaptureAudioChannel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2120 /* #2241 'AVCaptureOutput' => 'AVFoundation.AVCaptureOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0320 /* #2242 'AVCaptureAudioDataOutput' => 'AVFoundation.AVCaptureAudioDataOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x193D20 /* #2243 'AVCaptureFileOutput' => 'AVFoundation.AVCaptureFileOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0620 /* #2244 'AVCaptureAudioFileOutput' => 'AVFoundation.AVCaptureAudioFileOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0720 /* #2245 'AVCaptureAudioPreviewOutput' => 'AVFoundation.AVCaptureAudioPreviewOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0C20 /* #2246 'AVCaptureDeviceDiscoverySession' => 'AVFoundation.AVCaptureDeviceDiscoverySession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0D20 /* #2247 'AVCaptureDeviceFormat' => 'AVFoundation.AVCaptureDeviceFormat, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0E20 /* #2248 'AVCaptureDeviceInputSource' => 'AVFoundation.AVCaptureDeviceInputSource, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A1720 /* #2249 'AVCaptureFileOutputDelegate' => 'AVFoundation.AVCaptureFileOutputDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A1B20 /* #2250 'AVCaptureFileOutputRecordingDelegate' => 'AVFoundation.AVCaptureFileOutputRecordingDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2020 /* #2251 'AVCaptureMovieFileOutput' => 'AVFoundation.AVCaptureMovieFileOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2320 /* #2252 'AVCapturePhoto' => 'AVFoundation.AVCapturePhoto, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2720 /* #2253 'AVCapturePhotoCaptureDelegate' => 'AVFoundation.AVCapturePhotoCaptureDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2C20 /* #2254 'AVCaptureResolvedPhotoSettings' => 'AVFoundation.AVCaptureResolvedPhotoSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2D20 /* #2255 'AVCaptureScreenInput' => 'AVFoundation.AVCaptureScreenInput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A3020 /* #2256 'AVCaptureSynchronizedData' => 'AVFoundation.AVCaptureSynchronizedData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A3220 /* #2257 'AVCaptureVideoDataOutput' => 'AVFoundation.AVCaptureVideoDataOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A3620 /* #2258 'AVCaptureVideoDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A3E20 /* #2259 'AVComposition' => 'AVFoundation.AVComposition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A4120 /* #2260 'AVCompositionTrackFormatDescriptionReplacement' => 'AVFoundation.AVCompositionTrackFormatDescriptionReplacement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A4220 /* #2261 'AVCompositionTrackSegment' => 'AVFoundation.AVCompositionTrackSegment, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A5120 /* #2262 'AVContentKeySessionDelegate' => 'AVFoundation.AVContentKeySessionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7A20 /* #2263 'AVMetadataGroup' => 'AVFoundation.AVMetadataGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A5520 /* #2264 'AVDateRangeMetadataGroup' => 'AVFoundation.AVDateRangeMetadataGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A5E20 /* #2265 'AVFragmentedAssetMinder' => 'AVFoundation.AVFragmentedAssetMinder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6120 /* #2266 'AVFragmentedMovieMinder' => 'AVFoundation.AVFragmentedMovieMinder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6620 /* #2267 'AVFrameRateRange' => 'AVFoundation.AVFrameRateRange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6B20 /* #2268 'AVMediaDataStorage' => 'AVFoundation.AVMediaDataStorage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6C20 /* #2269 'AVMediaSelection' => 'AVFoundation.AVMediaSelection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6E20 /* #2270 'AVMediaSelectionOption' => 'AVFoundation.AVMediaSelectionOption, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7F20 /* #2271 'AVMetadataObject' => 'AVFoundation.AVMetadataObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7320 /* #2272 'AVMetadataBodyObject' => 'AVFoundation.AVMetadataBodyObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7420 /* #2273 'AVMetadataCatBodyObject' => 'AVFoundation.AVMetadataCatBodyObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7520 /* #2274 'AVMetadataDogBodyObject' => 'AVFoundation.AVMetadataDogBodyObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7720 /* #2275 'AVMetadataFaceObject' => 'AVFoundation.AVMetadataFaceObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7B20 /* #2276 'AVMetadataHumanBodyObject' => 'AVFoundation.AVMetadataHumanBodyObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7D20 /* #2277 'AVMetadataItemValueRequest' => 'AVFoundation.AVMetadataItemValueRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7E20 /* #2278 'AVMetadataMachineReadableCodeObject' => 'AVFoundation.AVMetadataMachineReadableCodeObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8120 /* #2279 'AVMetadataSalientObject' => 'AVFoundation.AVMetadataSalientObject, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8320 /* #2280 'AVMovie' => 'AVFoundation.AVMovie, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8620 /* #2281 'AVMovieTrack' => 'AVFoundation.AVMovieTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8920 /* #2282 'AVMusicTrack' => 'AVFoundation.AVMusicTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8B20 /* #2283 'AVMutableAudioMix' => 'AVFoundation.AVMutableAudioMix, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8C20 /* #2284 'AVMutableAudioMixInputParameters' => 'AVFoundation.AVMutableAudioMixInputParameters, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8D20 /* #2285 'AVMutableComposition' => 'AVFoundation.AVMutableComposition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8F20 /* #2286 'AVMutableDateRangeMetadataGroup' => 'AVFoundation.AVMutableDateRangeMetadataGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9020 /* #2287 'AVMutableMediaSelection' => 'AVFoundation.AVMutableMediaSelection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A7C20 /* #2288 'AVMetadataItem' => 'AVFoundation.AVMetadataItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9120 /* #2289 'AVMutableMetadataItem' => 'AVFoundation.AVMutableMetadataItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9220 /* #2290 'AVMutableMovie' => 'AVFoundation.AVMutableMovie, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9620 /* #2291 'AVMutableMovieTrack' => 'AVFoundation.AVMutableMovieTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AE920 /* #2292 'AVTimedMetadataGroup' => 'AVFoundation.AVTimedMetadataGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9920 /* #2293 'AVMutableTimedMetadataGroup' => 'AVFoundation.AVMutableTimedMetadataGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF520 /* #2294 'AVVideoComposition' => 'AVFoundation.AVVideoComposition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9A20 /* #2295 'AVMutableVideoComposition' => 'AVFoundation.AVMutableVideoComposition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF720 /* #2296 'AVVideoCompositionInstruction' => 'AVFoundation.AVVideoCompositionInstruction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9B20 /* #2297 'AVMutableVideoCompositionInstruction' => 'AVFoundation.AVMutableVideoCompositionInstruction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF820 /* #2298 'AVVideoCompositionLayerInstruction' => 'AVFoundation.AVVideoCompositionLayerInstruction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9C20 /* #2299 'AVMutableVideoCompositionLayerInstruction' => 'AVFoundation.AVMutableVideoCompositionLayerInstruction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A9D20 /* #2300 'AVOutputSettingsAssistant' => 'AVFoundation.AVOutputSettingsAssistant, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194B20 /* #2301 'AVContentKeyRequest' => 'AVFoundation.AVContentKeyRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA020 /* #2302 'AVPersistableContentKeyRequest' => 'AVFoundation.AVPersistableContentKeyRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA520 /* #2303 'AVPlayerItemAccessLog' => 'AVFoundation.AVPlayerItemAccessLog, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA620 /* #2304 'AVPlayerItemAccessLogEvent' => 'AVFoundation.AVPlayerItemAccessLogEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA720 /* #2305 'AVPlayerItemErrorLog' => 'AVFoundation.AVPlayerItemErrorLog, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA820 /* #2306 'AVPlayerItemErrorLogEvent' => 'AVFoundation.AVPlayerItemErrorLogEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AB820 /* #2307 'AVPlayerItemOutput' => 'AVFoundation.AVPlayerItemOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AA920 /* #2308 'AVPlayerItemLegibleOutput' => 'AVFoundation.AVPlayerItemLegibleOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AC020 /* #2309 'AVPlayerItemOutputPushDelegate' => 'AVFoundation.AVPlayerItemOutputPushDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AAD20 /* #2310 'AVPlayerItemLegibleOutputPushDelegate' => 'AVFoundation.AVPlayerItemLegibleOutputPushDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AAE20 /* #2311 'AVPlayerItemMediaDataCollector' => 'AVFoundation.AVPlayerItemMediaDataCollector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AAF20 /* #2312 'AVPlayerItemMetadataCollector' => 'AVFoundation.AVPlayerItemMetadataCollector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AB220 /* #2313 'AVPlayerItemMetadataCollectorPushDelegate' => 'AVFoundation.AVPlayerItemMetadataCollectorPushDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AB320 /* #2314 'AVPlayerItemMetadataOutput' => 'AVFoundation.AVPlayerItemMetadataOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AB720 /* #2315 'AVPlayerItemMetadataOutputPushDelegate' => 'AVFoundation.AVPlayerItemMetadataOutputPushDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ABC20 /* #2316 'AVPlayerItemOutputPullDelegate' => 'AVFoundation.AVPlayerItemOutputPullDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AC220 /* #2317 'AVPlayerItemTrack' => 'AVFoundation.AVPlayerItemTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AC920 /* #2318 'AVPortraitEffectsMatte' => 'AVFoundation.AVPortraitEffectsMatte, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195320 /* #2319 'AVPlayer' => 'AVFoundation.AVPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ACD20 /* #2320 'AVQueuePlayer' => 'AVFoundation.AVQueuePlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD320 /* #2321 'AVSampleBufferRequest' => 'AVFoundation.AVSampleBufferRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD620 /* #2322 'AVSampleCursor' => 'AVFoundation.AVSampleCursor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD820 /* #2323 'AVSemanticSegmentationMatte' => 'AVFoundation.AVSemanticSegmentationMatte, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ADC20 /* #2324 'AVSpeechSynthesisVoice' => 'AVFoundation.AVSpeechSynthesisVoice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AE520 /* #2325 'AVSpeechSynthesizerDelegate' => 'AVFoundation.AVSpeechSynthesizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AE620 /* #2326 'AVSpeechUtterance' => 'AVFoundation.AVSpeechUtterance, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AE820 /* #2327 'AVSynchronizedLayer' => 'AVFoundation.AVSynchronizedLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF420 /* #2328 'AVVideoCompositing' => 'AVFoundation.AVVideoCompositing, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF620 /* #2329 'AVVideoCompositionCoreAnimationTool' => 'AVFoundation.AVVideoCompositionCoreAnimationTool, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AF920 /* #2330 'AVVideoCompositionRenderContext' => 'AVFoundation.AVVideoCompositionRenderContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AFA20 /* #2331 'AVVideoCompositionRenderHint' => 'AVFoundation.AVVideoCompositionRenderHint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AFE20 /* #2332 'AVVideoCompositionValidationHandling' => 'AVFoundation.AVVideoCompositionValidationHandling, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1020 /* #2333 'ASAuthorization' => 'AuthenticationServices.ASAuthorization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1120 /* #2334 'ASAuthorizationRequest' => 'AuthenticationServices.ASAuthorizationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1220 /* #2335 'ASAuthorizationAppleIDButton' => 'AuthenticationServices.ASAuthorizationAppleIdButton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B2420 /* #2336 'ASAuthorizationOpenIDRequest' => 'AuthenticationServices.ASAuthorizationOpenIdRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1820 /* #2337 'ASAuthorizationAppleIDRequest' => 'AuthenticationServices.ASAuthorizationAppleIdRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1920 /* #2338 'ASAuthorizationController' => 'AuthenticationServices.ASAuthorizationController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1D20 /* #2339 'Xamarin_Mac__AuthenticationServices_ASAuthorizationControllerDelegate' => 'AuthenticationServices.ASAuthorizationControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B2720 /* #2340 'ASAuthorizationPasswordProvider' => 'AuthenticationServices.ASAuthorizationPasswordProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B2820 /* #2341 'ASAuthorizationPasswordRequest' => 'AuthenticationServices.ASAuthorizationPasswordRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3420 /* #2342 'ASAuthorizationSingleSignOnProvider' => 'AuthenticationServices.ASAuthorizationSingleSignOnProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3520 /* #2343 'ASAuthorizationSingleSignOnRequest' => 'AuthenticationServices.ASAuthorizationSingleSignOnRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3620 /* #2344 'ASPasswordCredential' => 'AuthenticationServices.ASPasswordCredential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3A20 /* #2345 'ASWebAuthenticationSession' => 'AuthenticationServices.ASWebAuthenticationSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3D20 /* #2346 'ASWebAuthenticationSessionRequest' => 'AuthenticationServices.ASWebAuthenticationSessionRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B4120 /* #2347 'Xamarin_Mac__AuthenticationServices_ASWebAuthenticationSessionRequestDelegate' => 'AuthenticationServices.ASWebAuthenticationSessionRequestDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B4420 /* #2348 'ASWebAuthenticationSessionWebBrowserSessionManager' => 'AuthenticationServices.ASWebAuthenticationSessionWebBrowserSessionManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6120 /* #2349 'NSAppleEventDescriptor' => 'Foundation.NSAppleEventDescriptor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6620 /* #2350 'NSBundle' => 'Foundation.NSBundle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6A20 /* #2351 'NSConnection' => 'Foundation.NSConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6C20 /* #2352 'NSDate' => 'Foundation.NSDate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA920 /* #2353 'NSEnumerator' => 'Foundation.NSEnumerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6F20 /* #2354 'NSDirectoryEnumerator' => 'Foundation.NSDirectoryEnumerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7A20 /* #2355 'NSFileManagerDelegate' => 'Foundation.NSFileManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7E20 /* #2356 'NSHTTPCookie' => 'Foundation.NSHttpCookie, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BAE20 /* #2357 'NSStream' => 'Foundation.NSStream, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8220 /* #2358 'NSInputStream' => 'Foundation.NSInputStream, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8320 /* #2359 'NSJSONSerialization' => 'Foundation.NSJsonSerialization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8720 /* #2360 'NSMetadataItem' => 'Foundation.NSMetadataItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6420 /* #2361 'NSAttributedString' => 'Foundation.NSAttributedString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8A20 /* #2362 'NSMutableAttributedString' => 'Foundation.NSMutableAttributedString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9820 /* #2363 'NSOrderedSet' => 'Foundation.NSOrderedSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9920 /* #2364 'NSMutableOrderedSet' => 'Foundation.NSMutableOrderedSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BA920 /* #2365 'NSSet' => 'Foundation.NSSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8F20 /* #2366 'NSMutableSet' => 'Foundation.NSMutableSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9120 /* #2367 'NSMutableString' => 'Foundation.NSMutableString, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9220 /* #2368 'NSURLRequest' => 'Foundation.NSUrlRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9320 /* #2369 'NSMutableURLRequest' => 'Foundation.NSMutableUrlRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9420 /* #2370 'Foundation_InternalNSNotificationHandler' => 'Foundation.InternalNSNotificationHandler, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1B9720 /* #2371 'NSNull' => 'Foundation.NSNull, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9B20 /* #2372 'NSOutputStream' => 'Foundation.NSOutputStream, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9C20 /* #2373 'NSPredicate' => 'Foundation.NSPredicate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9D20 /* #2374 'NSPropertyListSerialization' => 'Foundation.NSPropertyListSerialization, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9E20 /* #2375 'NSProxy' => 'Foundation.NSProxy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9F20 /* #2376 'NSRunLoop' => 'Foundation.NSRunLoop, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BA220 /* #2377 'NSScriptCommandDescription' => 'Foundation.NSScriptCommandDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB120 /* #2378 'NSTimer' => 'Foundation.NSTimer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB220 /* #2379 'NSTimeZone' => 'Foundation.NSTimeZone, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB520 /* #2380 'NSUnit' => 'Foundation.NSUnit, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C5F20 /* #2381 'NSDimension' => 'Foundation.NSDimension, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB620 /* #2382 'NSUnitAcceleration' => 'Foundation.NSUnitAcceleration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB720 /* #2383 'NSUnitAngle' => 'Foundation.NSUnitAngle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB820 /* #2384 'NSUnitArea' => 'Foundation.NSUnitArea, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB920 /* #2385 'NSUnitConcentrationMass' => 'Foundation.NSUnitConcentrationMass, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBA20 /* #2386 'NSUnitDispersion' => 'Foundation.NSUnitDispersion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBB20 /* #2387 'NSUnitDuration' => 'Foundation.NSUnitDuration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBC20 /* #2388 'NSUnitElectricCharge' => 'Foundation.NSUnitElectricCharge, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBD20 /* #2389 'NSUnitElectricCurrent' => 'Foundation.NSUnitElectricCurrent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBE20 /* #2390 'NSUnitElectricPotentialDifference' => 'Foundation.NSUnitElectricPotentialDifference, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BBF20 /* #2391 'NSUnitElectricResistance' => 'Foundation.NSUnitElectricResistance, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC020 /* #2392 'NSUnitEnergy' => 'Foundation.NSUnitEnergy, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC120 /* #2393 'NSUnitFrequency' => 'Foundation.NSUnitFrequency, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC220 /* #2394 'NSUnitFuelEfficiency' => 'Foundation.NSUnitFuelEfficiency, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC320 /* #2395 'NSUnitLength' => 'Foundation.NSUnitLength, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC420 /* #2396 'NSUnitIlluminance' => 'Foundation.NSUnitIlluminance, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC520 /* #2397 'NSUnitMass' => 'Foundation.NSUnitMass, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC620 /* #2398 'NSUnitPower' => 'Foundation.NSUnitPower, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC720 /* #2399 'NSUnitPressure' => 'Foundation.NSUnitPressure, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC820 /* #2400 'NSUnitSpeed' => 'Foundation.NSUnitSpeed, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BC920 /* #2401 'NSUnitVolume' => 'Foundation.NSUnitVolume, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BCC20 /* #2402 'NSURLComponents' => 'Foundation.NSUrlComponents, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BCE20 /* #2403 'NSURLCredential' => 'Foundation.NSUrlCredential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD020 /* #2404 'NSURLProtectionSpace' => 'Foundation.NSUrlProtectionSpace, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD120 /* #2405 'NSURLProtocol' => 'Foundation.NSUrlProtocol, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD220 /* #2406 'Foundation_NSUrlProtocolClient' => 'Foundation.NSUrlProtocolClient, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1BD620 /* #2407 'NSUUID' => 'Foundation.NSUuid, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD920 /* #2408 'NSAppleEventManager' => 'Foundation.NSAppleEventManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C5620 /* #2409 'Foundation_NSDispatcher' => 'Foundation.NSDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5720 /* #2410 '__MonoMac_NSActionDispatcher' => 'Foundation.NSActionDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5820 /* #2411 '__MonoMac_NSSynchronizationContextDispatcher' => 'Foundation.NSSynchronizationContextDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5920 /* #2412 '__Xamarin_NSTimerActionDispatcher' => 'Foundation.NSTimerActionDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5A20 /* #2413 'Foundation_NSAsyncDispatcher' => 'Foundation.NSAsyncDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5B20 /* #2414 '__MonoMac_NSAsyncActionDispatcher' => 'Foundation.NSAsyncActionDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5C20 /* #2415 '__MonoMac_NSAsyncSynchronizationContextDispatcher' => 'Foundation.NSAsyncSynchronizationContextDispatcher, Xamarin.Mac' */, (MTTypeFlags) (2) /* UserType */ },
		{ NULL, 0x1C5D20 /* #2416 'NSAutoreleasePool' => 'Foundation.NSAutoreleasePool, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C6120 /* #2417 'NSError' => 'Foundation.NSError, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C6A20 /* #2418 'NSValue' => 'Foundation.NSValue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C6220 /* #2419 'NSNumber' => 'Foundation.NSNumber, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C7720 /* #2420 'NSDateComponents' => 'Foundation.NSDateComponents, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C7D20 /* #2421 'NSAffineTransform' => 'Foundation.NSAffineTransform, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C7E20 /* #2422 'NSAppleScript' => 'Foundation.NSAppleScript, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8120 /* #2423 'NSBindingSelectionMarker' => 'Foundation.NSBindingSelectionMarker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8220 /* #2424 'NSBlockOperation' => 'Foundation.NSBlockOperation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8320 /* #2425 'NSByteCountFormatter' => 'Foundation.NSByteCountFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8920 /* #2426 'NSCacheDelegate' => 'Foundation.NSCacheDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8A20 /* #2427 'NSCachedURLResponse' => 'Foundation.NSCachedUrlResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8B20 /* #2428 'NSCalendarDate' => 'Foundation.NSCalendarDate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8C20 /* #2429 'NSCharacterSet' => 'Foundation.NSCharacterSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C8F20 /* #2430 'NSCoding' => 'Foundation.NSCoding, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9120 /* #2431 'NSComparisonPredicate' => 'Foundation.NSComparisonPredicate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9220 /* #2432 'NSCompoundPredicate' => 'Foundation.NSCompoundPredicate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9320 /* #2433 'NSCondition' => 'Foundation.NSCondition, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9420 /* #2434 'NSConditionLock' => 'Foundation.NSConditionLock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9820 /* #2435 'NSConnectionDelegate' => 'Foundation.NSConnectionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9B20 /* #2436 'NSCopying' => 'Foundation.NSCopying, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2420 /* #2437 'NSRegularExpression' => 'Foundation.NSRegularExpression, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9D20 /* #2438 'NSDataDetector' => 'Foundation.NSDataDetector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9E20 /* #2439 'NSDateComponentsFormatter' => 'Foundation.NSDateComponentsFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1C9F20 /* #2440 'NSDateFormatter' => 'Foundation.NSDateFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA020 /* #2441 'NSDateInterval' => 'Foundation.NSDateInterval, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA120 /* #2442 'NSDateIntervalFormatter' => 'Foundation.NSDateIntervalFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA220 /* #2443 'NSDecimalNumber' => 'Foundation.NSDecimalNumber, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA520 /* #2444 'NSDistantObjectRequest' => 'Foundation.NSDistantObjectRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA620 /* #2445 'NSDistributedLock' => 'Foundation.NSDistributedLock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B9520 /* #2446 'NSNotificationCenter' => 'Foundation.NSNotificationCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA720 /* #2447 'NSDistributedNotificationCenter' => 'Foundation.NSDistributedNotificationCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CA820 /* #2448 'NSEnergyFormatter' => 'Foundation.NSEnergyFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAA20 /* #2449 'NSException' => 'Foundation.NSException, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAC20 /* #2450 'NSExtensionItem' => 'Foundation.NSExtensionItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CAF20 /* #2451 'NSExtensionRequestHandling' => 'Foundation.NSExtensionRequestHandling, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB020 /* #2452 'NSFileAccessIntent' => 'Foundation.NSFileAccessIntent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB120 /* #2453 'NSFileCoordinator' => 'Foundation.NSFileCoordinator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB920 /* #2454 'NSFilePresenter' => 'Foundation.NSFilePresenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBA20 /* #2455 'NSFileProviderService' => 'Foundation.NSFileProviderService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBC20 /* #2456 'NSFileWrapper' => 'Foundation.NSFileWrapper, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5B20 /* #2457 'NSURLResponse' => 'Foundation.NSUrlResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBD20 /* #2458 'NSHTTPURLResponse' => 'Foundation.NSHttpUrlResponse, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBE20 /* #2459 'NSInvocation' => 'Foundation.NSInvocation, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBF20 /* #2460 'NSISO8601DateFormatter' => 'Foundation.NSIso8601DateFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CCD20 /* #2461 'NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiverDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD120 /* #2462 'NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiverDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD420 /* #2463 'NSLengthFormatter' => 'Foundation.NSLengthFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CD720 /* #2464 'NSLinguisticTagger' => 'Foundation.NSLinguisticTagger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDC20 /* #2465 'NSListFormatter' => 'Foundation.NSListFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CDD20 /* #2466 'NSLock' => 'Foundation.NSLock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1020 /* #2467 'NSPort' => 'Foundation.NSPort, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE020 /* #2468 'NSMachPort' => 'Foundation.NSMachPort, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1420 /* #2469 'NSPortDelegate' => 'Foundation.NSPortDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE420 /* #2470 'NSMachPortDelegate' => 'Foundation.NSMachPortDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE520 /* #2471 'NSMassFormatter' => 'Foundation.NSMassFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE620 /* #2472 'NSMeasurement' => 'Foundation.NSMeasurement`1, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE720 /* #2473 'NSMeasurementFormatter' => 'Foundation.NSMeasurementFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CE920 /* #2474 'NSMetadataQueryAttributeValueTuple' => 'Foundation.NSMetadataQueryAttributeValueTuple, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CED20 /* #2475 'NSMetadataQueryDelegate' => 'Foundation.NSMetadataQueryDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CEE20 /* #2476 'NSMetadataQueryResultGroup' => 'Foundation.NSMetadataQueryResultGroup, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CEF20 /* #2477 'NSMethodSignature' => 'Foundation.NSMethodSignature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF020 /* #2478 'NSMutableCharacterSet' => 'Foundation.NSMutableCharacterSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF320 /* #2479 'NSMutableCopying' => 'Foundation.NSMutableCopying, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8120 /* #2480 'NSIndexSet' => 'Foundation.NSIndexSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CF420 /* #2481 'NSMutableIndexSet' => 'Foundation.NSMutableIndexSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CFE20 /* #2482 'NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0220 /* #2483 'NSNetServiceDelegate' => 'Foundation.NSNetServiceDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0320 /* #2484 'NSNotification' => 'Foundation.NSNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0420 /* #2485 'NSNotificationQueue' => 'Foundation.NSNotificationQueue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0520 /* #2486 'NSNumberFormatter' => 'Foundation.NSNumberFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0920 /* #2487 'NSOperationQueue' => 'Foundation.NSOperationQueue, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0B20 /* #2488 'NSOrthography' => 'Foundation.NSOrthography, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0D20 /* #2489 'NSPersonNameComponents' => 'Foundation.NSPersonNameComponents, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0E20 /* #2490 'NSPersonNameComponentsFormatter' => 'Foundation.NSPersonNameComponentsFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D0F20 /* #2491 'NSPipe' => 'Foundation.NSPipe, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1520 /* #2492 'NSPortMessage' => 'Foundation.NSPortMessage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1620 /* #2493 'NSPortNameServer' => 'Foundation.NSPortNameServer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6B20 /* #2494 'NSData' => 'Foundation.NSData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8B20 /* #2495 'NSMutableData' => 'Foundation.NSMutableData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2220 /* #2496 'NSPurgeableData' => 'Foundation.NSPurgeableData, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2320 /* #2497 'NSRecursiveLock' => 'Foundation.NSRecursiveLock, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2520 /* #2498 'NSRelativeDateTimeFormatter' => 'Foundation.NSRelativeDateTimeFormatter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2920 /* #2499 'NSScriptCommand' => 'Foundation.NSScriptCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3320 /* #2500 'NSStreamDelegate' => 'Foundation.NSStreamDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3920 /* #2501 'NSTextCheckingResult' => 'Foundation.NSTextCheckingResult, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3B20 /* #2502 'NSUnitConverter' => 'Foundation.NSUnitConverter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3C20 /* #2503 'NSUnitConverterLinear' => 'Foundation.NSUnitConverterLinear, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3D20 /* #2504 'NSUnitInformationStorage' => 'Foundation.NSUnitInformationStorage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3E20 /* #2505 'NSUnitTemperature' => 'Foundation.NSUnitTemperature, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3F20 /* #2506 'NSURLAuthenticationChallenge' => 'Foundation.NSUrlAuthenticationChallenge, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4320 /* #2507 'NSURLAuthenticationChallengeSender' => 'Foundation.NSURLAuthenticationChallengeSender, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4D20 /* #2508 'NSURLConnectionDelegate' => 'Foundation.NSUrlConnectionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4920 /* #2509 'NSURLConnectionDataDelegate' => 'Foundation.NSUrlConnectionDataDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5120 /* #2510 'NSURLConnectionDownloadDelegate' => 'Foundation.NSUrlConnectionDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5620 /* #2511 'NSUrlDownloadDelegate' => 'Foundation.NSUrlDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5A20 /* #2512 'NSURLQueryItem' => 'Foundation.NSUrlQueryItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6120 /* #2513 'NSURLSessionConfiguration' => 'Foundation.NSUrlSessionConfiguration, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6A20 /* #2514 'NSURLSessionDelegate' => 'Foundation.NSUrlSessionDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7A20 /* #2515 'NSURLSessionTaskDelegate' => 'Foundation.NSUrlSessionTaskDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6520 /* #2516 'NSURLSessionDataDelegate' => 'Foundation.NSUrlSessionDataDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7620 /* #2517 'NSURLSessionTask' => 'Foundation.NSUrlSessionTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6620 /* #2518 'NSURLSessionDataTask' => 'Foundation.NSUrlSessionDataTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6E20 /* #2519 'NSURLSessionDownloadDelegate' => 'Foundation.NSUrlSessionDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D6F20 /* #2520 'NSURLSessionDownloadTask' => 'Foundation.NSUrlSessionDownloadTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7320 /* #2521 'NSURLSessionStreamDelegate' => 'Foundation.NSUrlSessionStreamDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7B20 /* #2522 'NSURLSessionTaskMetrics' => 'Foundation.NSUrlSessionTaskMetrics, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7D20 /* #2523 'NSURLSessionTaskTransactionMetrics' => 'Foundation.NSUrlSessionTaskTransactionMetrics, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7E20 /* #2524 'NSURLSessionUploadTask' => 'Foundation.NSUrlSessionUploadTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8320 /* #2525 'Xamarin_Mac__Foundation_NSUrlSessionWebSocketDelegate' => 'Foundation.NSUrlSessionWebSocketDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8420 /* #2526 'NSURLSessionWebSocketMessage' => 'Foundation.NSUrlSessionWebSocketMessage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8D20 /* #2527 'NSUserActivityDelegate' => 'Foundation.NSUserActivityDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8F20 /* #2528 'NSUserNotification' => 'Foundation.NSUserNotification, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9020 /* #2529 'NSUserNotificationAction' => 'Foundation.NSUserNotificationAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9720 /* #2530 'NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenterDelegate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9820 /* #2531 'NSValueTransformer' => 'Foundation.NSValueTransformer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D9920 /* #2532 'NSXPCListenerEndpoint' => 'Foundation.NSXpcListenerEndpoint, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x520 /* #2533 'SNAudioFileAnalyzer' => 'SoundAnalysis.SNAudioFileAnalyzer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1420 /* #2534 'SFContentBlockerManager' => 'SafariServices.SFContentBlockerManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1820 /* #2535 'SFSafariApplication' => 'SafariServices.SFSafariApplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1920 /* #2536 'SFSafariExtension' => 'SafariServices.SFSafariExtension, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A20 /* #2537 'SFSafariExtensionHandler' => 'SafariServices.SFSafariExtensionHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2120 /* #2538 'SFSafariPage' => 'SafariServices.SFSafariPage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2420 /* #2539 'SFSafariTab' => 'SafariServices.SFSafariTab, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2620 /* #2540 'SFSafariWindow' => 'SafariServices.SFSafariWindow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4320 /* #2541 'QLThumbnailGenerator' => 'QuickLookThumbnailing.QLThumbnailGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DE820 /* #2542 'NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewController+_NCWidgetListViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8420 /* #2543 'NCWidgetListViewController' => 'NotificationCenter.NCWidgetListViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DE920 /* #2544 'NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewController+_NCWidgetSearchViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8F20 /* #2545 'NCWidgetSearchViewController' => 'NotificationCenter.NCWidgetSearchViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA320 /* #2546 'LPMetadataProvider' => 'LinkPresentation.LPMetadataProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA620 /* #2547 'LAContext' => 'LocalAuthentication.LAContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DEC20 /* #2548 'ExternalAccessory_EAAccessory__EAAccessoryDelegate' => 'ExternalAccessory.EAAccessory+_EAAccessoryDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xF220 /* #2549 'EAAccessory' => 'ExternalAccessory.EAAccessory, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF720 /* #2550 'EAAccessoryManager' => 'ExternalAccessory.EAAccessoryManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFC20 /* #2551 'DCDevice' => 'DeviceCheck.DCDevice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF320 /* #2552 'ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceView+_IKCameraDeviceViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12820 /* #2553 'IKCameraDeviceView' => 'ImageKit.IKCameraDeviceView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF420 /* #2554 'ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserView+_IKDeviceBrowserViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12F20 /* #2555 'IKDeviceBrowserView' => 'ImageKit.IKDeviceBrowserView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x13620 /* #2556 'IKFilterBrowserPanel' => 'ImageKit.IKFilterBrowserPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF620 /* #2557 'ImageKit_IKImageBrowserView__IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserView+_IKImageBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x14920 /* #2558 'IKImageBrowserView' => 'ImageKit.IKImageBrowserView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF720 /* #2559 'ImageKit_IKSaveOptions__IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptions+_IKSaveOptionsDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15620 /* #2560 'IKSaveOptions' => 'ImageKit.IKSaveOptions, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1DF820 /* #2561 'ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceView+_IKScannerDeviceViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15B20 /* #2562 'IKScannerDeviceView' => 'ImageKit.IKScannerDeviceView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16D20 /* #2563 'FIFinderSync' => 'FinderSync.FIFinderSync, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16E20 /* #2564 'FIFinderSyncController' => 'FinderSync.FIFinderSyncController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19C20 /* #2565 'ACAccountStore' => 'Accounts.ACAccountStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1FF20 /* #2566 'VNFaceLandmarkRegion2D' => 'Vision.VNFaceLandmarkRegion2D, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F20 /* #2567 'VNRecognizeAnimalsRequest' => 'Vision.VNRecognizeAnimalsRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2C520 /* #2568 'UNUserNotificationCenter' => 'UserNotifications.UNUserNotificationCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23D420 /* #2569 'StoreKit_SKRequest__SKRequestDelegate' => 'StoreKit.SKRequest+_SKRequestDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x23D320 /* #2570 'StoreKit_SKProductsRequest__SKProductsRequestDelegate' => 'StoreKit.SKProductsRequest+_SKProductsRequestDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2EE20 /* #2571 'SKProductsRequest' => 'StoreKit.SKProductsRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x2FF20 /* #2572 'SLRequest' => 'Social.SLRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23E120 /* #2573 'ScriptingBridge_SBApplication__SBApplicationDelegate' => 'ScriptingBridge.SBApplication+_SBApplicationDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x36A20 /* #2574 'SBApplication' => 'ScriptingBridge.SBApplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3D220 /* #2575 'PHLivePhotoEditingContext' => 'Photos.PHLivePhotoEditingContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x3EA20 /* #2576 'PHAssetResourceManager' => 'Photos.PHAssetResourceManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x40E20 /* #2577 'PHPhotoLibrary' => 'Photos.PHPhotoLibrary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F220 /* #2578 'PdfKit_PdfView__PdfViewDelegate' => 'PdfKit.PdfView+_PdfViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x42E20 /* #2579 'PDFView' => 'PdfKit.PdfView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x23F420 /* #2580 'PdfKit_PdfDocument__PdfDocumentDelegate' => 'PdfKit.PdfDocument+_PdfDocumentDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x45920 /* #2581 'PDFDocument' => 'PdfKit.PdfDocument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x46B20 /* #2582 'PDFThumbnailView' => 'PdfKit.PdfThumbnailView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D920 /* #2583 'NETunnelProvider' => 'NetworkExtension.NETunnelProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49520 /* #2584 'NEPacketTunnelProvider' => 'NetworkExtension.NEPacketTunnelProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49920 /* #2585 'NEVPNManager' => 'NetworkExtension.NEVpnManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49C20 /* #2586 'NEAppProxyFlow' => 'NetworkExtension.NEAppProxyFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x49F20 /* #2587 'NEAppProxyProvider' => 'NetworkExtension.NEAppProxyProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4DC20 /* #2588 'NETunnelProviderManager' => 'NetworkExtension.NETunnelProviderManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A020 /* #2589 'NEAppProxyProviderManager' => 'NetworkExtension.NEAppProxyProviderManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A120 /* #2590 'NEAppProxyTCPFlow' => 'NetworkExtension.NEAppProxyTcpFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A220 /* #2591 'NEAppProxyUDPFlow' => 'NetworkExtension.NEAppProxyUdpFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A520 /* #2592 'NEDNSProxyManager' => 'NetworkExtension.NEDnsProxyManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4A820 /* #2593 'NEDNSProxyProvider' => 'NetworkExtension.NEDnsProxyProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4AE20 /* #2594 'NEFilterDataProvider' => 'NetworkExtension.NEFilterDataProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4B120 /* #2595 'NEFilterManager' => 'NetworkExtension.NEFilterManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D020 /* #2596 'NEPacketTunnelFlow' => 'NetworkExtension.NEPacketTunnelFlow, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4D620 /* #2597 'NETransparentProxyManager' => 'NetworkExtension.NETransparentProxyManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F320 /* #2598 'NWTCPConnection' => 'NetworkExtension.NWTcpConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4F920 /* #2599 'NWUDPSession' => 'NetworkExtension.NWUdpSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4FD20 /* #2600 'NLEmbedding' => 'NaturalLanguage.NLEmbedding, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x4FE20 /* #2601 'NLLanguageRecognizer' => 'NaturalLanguage.NLLanguageRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x50920 /* #2602 'NLTagger' => 'NaturalLanguage.NLTagger, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x51620 /* #2603 'MCSession' => 'MultipeerConnectivity.MCSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x54720 /* #2604 'MDLMesh' => 'ModelIO.MDLMesh, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x6F220 /* #2605 'MPSNNGraph' => 'MetalPerformanceShaders.MPSNNGraph, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x74E20 /* #2606 'MTKTextureLoader' => 'MetalKit.MTKTextureLoader, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x84820 /* #2607 'MPSkipIntervalCommand' => 'MediaPlayer.MPSkipIntervalCommand, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87820 /* #2608 'MKDirections' => 'MapKit.MKDirections, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x87B20 /* #2609 'MKLocalSearch' => 'MapKit.MKLocalSearch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8B120 /* #2610 'MKMapSnapshotter' => 'MapKit.MKMapSnapshotter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x244F20 /* #2611 'MapKit_MKMapView__MKMapViewDelegate' => 'MapKit.MKMapView+_MKMapViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8B320 /* #2612 'MKMapView' => 'MapKit.MKMapView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x8D120 /* #2613 'MKPointOfInterestFilter' => 'MapKit.MKPointOfInterestFilter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x92B20 /* #2614 'INInteraction' => 'Intents.INInteraction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x97E20 /* #2615 'GLKTextureLoader' => 'GLKit.GLKTextureLoader, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA0020 /* #2616 'GCController' => 'GameController.GCController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA1520 /* #2617 'EKEventStore' => 'EventKit.EKEventStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xA3720 /* #2618 'CWInterface' => 'CoreWlan.CWInterface, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAD220 /* #2619 'CSSearchableIndex' => 'CoreSpotlight.CSSearchableIndex, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAED20 /* #2620 'CMPedometer' => 'CoreMotion.CMPedometer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x249F20 /* #2621 'CoreLocation_CLLocationManager__CLLocationManagerDelegate' => 'CoreLocation.CLLocationManager+_CLLocationManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAF320 /* #2622 'CLLocationManager' => 'CoreLocation.CLLocationManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xAFB20 /* #2623 'CLGeocoder' => 'CoreLocation.CLGeocoder, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24B820 /* #2624 'CoreAnimation_CAAnimation__CAAnimationDelegate' => 'CoreAnimation.CAAnimation+_CAAnimationDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xE0720 /* #2625 'CNContactStore' => 'Contacts.CNContactStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5920 /* #2626 'CKContainer' => 'CloudKit.CKContainer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xE5A20 /* #2627 'CKDatabase' => 'CloudKit.CKDatabase, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xF1520 /* #2628 'AUAudioUnit' => 'AudioUnit.AUAudioUnit, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x24F720 /* #2629 'SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsWorld+_SKPhysicsContactDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xFE320 /* #2630 'SKPhysicsWorld' => 'SpriteKit.SKPhysicsWorld, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0xFF320 /* #2631 'SKTextureAtlas' => 'SpriteKit.SKTextureAtlas, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101420 /* #2632 'SCNAction' => 'SceneKit.SCNAction, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x101820 /* #2633 'SCNAnimationEvent' => 'SceneKit.SCNAnimationEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x107120 /* #2634 'SCNLayer' => 'SceneKit.SCNLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x250520 /* #2635 'SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsWorld+_SCNPhysicsContactDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x10A620 /* #2636 'SCNPhysicsWorld' => 'SceneKit.SCNPhysicsWorld, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10B220 /* #2637 'SCNRenderer' => 'SceneKit.SCNRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x10D820 /* #2638 'SCNView' => 'SceneKit.SCNView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113020 /* #2639 'GKTurnBasedExchange' => 'GameKit.GKTurnBasedExchange, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x254220 /* #2640 'GameKit_GKMatch__GKMatchDelegate' => 'GameKit.GKMatch+_GKMatchDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x113320 /* #2641 'GKMatch' => 'GameKit.GKMatch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113520 /* #2642 'GKMatchmaker' => 'GameKit.GKMatchmaker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113620 /* #2643 'GKGameSession' => 'GameKit.GKGameSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113720 /* #2644 'GKAchievement' => 'GameKit.GKAchievement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113A20 /* #2645 'GKAchievementDescription' => 'GameKit.GKAchievementDescription, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256620 /* #2646 'GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterViewController+_GKGameCenterControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x256320 /* #2647 'GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewController+_GKAchievementViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x115B20 /* #2648 'GKGameCenterViewController' => 'GameKit.GKGameCenterViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x113B20 /* #2649 'GKAchievementViewController' => 'GameKit.GKAchievementViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256420 /* #2650 'GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandler+_GKChallengeEventHandlerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x114120 /* #2651 'GKChallengeEventHandler' => 'GameKit.GKChallengeEventHandler, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256520 /* #2652 'GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewController+_GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x115420 /* #2653 'GKFriendRequestComposeViewController' => 'GameKit.GKFriendRequestComposeViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116920 /* #2654 'GKLeaderboard' => 'GameKit.GKLeaderboard, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x116C20 /* #2655 'GKLeaderboardSet' => 'GameKit.GKLeaderboardSet, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x256E20 /* #2656 'GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewController+_GKLeaderboardViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x116E20 /* #2657 'GKLeaderboardViewController' => 'GameKit.GKLeaderboardViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119120 /* #2658 'GKPlayer' => 'GameKit.GKPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x117220 /* #2659 'GKLocalPlayer' => 'GameKit.GKLocalPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x257A20 /* #2660 'GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewController+_GKMatchmakerViewControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x118220 /* #2661 'GKMatchmakerViewController' => 'GameKit.GKMatchmakerViewController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x118E20 /* #2662 'GKNotificationBanner' => 'GameKit.GKNotificationBanner, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119320 /* #2663 'GKSavedGame' => 'GameKit.GKSavedGame, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x119820 /* #2664 'GKScore' => 'GameKit.GKScore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11AC20 /* #2665 'GKTurnBasedMatch' => 'GameKit.GKTurnBasedMatch, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x11CE20 /* #2666 'WKWebView' => 'WebKit.WKWebView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x259C20 /* #2667 'WebKit_DomNode_DomNodeEventProxy' => 'WebKit.DomNode+DomNodeEventProxy, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x259D20 /* #2668 'WebKit_DomNode_DomNodeEventProxy2' => 'WebKit.DomNode+DomNodeEventProxy2, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x259E20 /* #2669 'WebKit_WebView__WebFrameLoadDelegate' => 'WebKit.WebView+_WebFrameLoadDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x259F20 /* #2670 'WebKit_WebView__WebDownloadDelegate' => 'WebKit.WebView+_WebDownloadDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25A020 /* #2671 'WebKit_WebView__WebResourceLoadDelegate' => 'WebKit.WebView+_WebResourceLoadDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25A120 /* #2672 'WebKit_WebView__WebUIDelegate' => 'WebKit.WebView+_WebUIDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25A220 /* #2673 'WebKit_WebView__WebPolicyDelegate' => 'WebKit.WebView+_WebPolicyDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11E120 /* #2674 'WebView' => 'WebKit.WebView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x127720 /* #2675 'WebHistoryItem' => 'WebKit.WebHistoryItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B520 /* #2676 'WKContentRuleListStore' => 'WebKit.WKContentRuleListStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12B920 /* #2677 'WKHTTPCookieStore' => 'WebKit.WKHttpCookieStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12DE20 /* #2678 'WKWebsiteDataStore' => 'WebKit.WKWebsiteDataStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25AE20 /* #2679 'AppKit_NSApplication__NSApplicationDelegate' => 'AppKit.NSApplication+_NSApplicationDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12E520 /* #2680 'NSApplication' => 'AppKit.NSApplication, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12E820 /* #2681 'NSBrowser' => 'AppKit.NSBrowser, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B120 /* #2682 'AppKit_NSMatrix__NSMatrixDelegate' => 'AppKit.NSMatrix+_NSMatrixDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25B220 /* #2683 'AppKit_NSPathCell__NSPathCellDelegate' => 'AppKit.NSPathCell+_NSPathCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12EA20 /* #2684 'NSPathCell' => 'AppKit.NSPathCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B320 /* #2685 'AppKit_NSTableView__NSTableViewDelegate' => 'AppKit.NSTableView+_NSTableViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12ED20 /* #2686 'NSTableView' => 'AppKit.NSTableView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25B520 /* #2687 'AppKit_NSAlert__NSAlertDelegate' => 'AppKit.NSAlert+_NSAlertDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12F520 /* #2688 'NSAlert' => 'AppKit.NSAlert, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x12FC20 /* #2689 'NSColor' => 'AppKit.NSColor, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25DB20 /* #2690 'AppKit_NSTextField__NSTextFieldDelegate' => 'AppKit.NSTextField+_NSTextFieldDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25BB20 /* #2691 'AppKit_NSComboBox__NSComboBoxDelegate' => 'AppKit.NSComboBox+_NSComboBoxDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x12FD20 /* #2692 'NSComboBox' => 'AppKit.NSComboBox, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25BF20 /* #2693 '__NSDocumentDuplicateCallback' => 'AppKit.NSDocument+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130520 /* #2694 'NSDocument' => 'AppKit.NSDocument, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130620 /* #2695 'NSEvent' => 'AppKit.NSEvent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130720 /* #2696 'NSFont' => 'AppKit.NSFont, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25C420 /* #2697 '__NSGestureRecognizerToken' => 'AppKit.NSGestureRecognizer+Token, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25C520 /* #2698 '__NSGestureRecognizerParameterlessToken' => 'AppKit.NSGestureRecognizer+ParameterlessDispatch, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25C620 /* #2699 '__NSGestureRecognizerParametrizedToken' => 'AppKit.NSGestureRecognizer+ParametrizedDispatch, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25C720 /* #2700 'AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizer+_NSGestureRecognizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130820 /* #2701 'NSGestureRecognizer' => 'AppKit.NSGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25C820 /* #2702 '__NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130920 /* #2703 'NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25C920 /* #2704 '__NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130A20 /* #2705 'NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25CA20 /* #2706 '__NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130B20 /* #2707 'NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25CB20 /* #2708 '__NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130C20 /* #2709 'NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25CC20 /* #2710 '__NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer+Callback, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x130D20 /* #2711 'NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x130E20 /* #2712 'NSGradient' => 'AppKit.NSGradient, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25CE20 /* #2713 'AppKit_NSImage__NSImageDelegate' => 'AppKit.NSImage+_NSImageDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x131120 /* #2714 'NSImage' => 'AppKit.NSImage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131520 /* #2715 'NSMenuItem' => 'AppKit.NSMenuItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131920 /* #2716 'NSPopUpButton' => 'AppKit.NSPopUpButton, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131A20 /* #2717 'NSPopUpButtonCell' => 'AppKit.NSPopUpButtonCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131B20 /* #2718 'NSPredicateEditorRowTemplate' => 'AppKit.NSPredicateEditorRowTemplate, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x131E20 /* #2719 'NSScreen' => 'AppKit.NSScreen, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25D520 /* #2720 'AppKit_NSSharingService__NSSharingServiceDelegate' => 'AppKit.NSSharingService+_NSSharingServiceDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x132020 /* #2721 'NSSharingService' => 'AppKit.NSSharingService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25D620 /* #2722 'AppKit_NSSound__NSSoundDelegate' => 'AppKit.NSSound+_NSSoundDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x132220 /* #2723 'NSSound' => 'AppKit.NSSound, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x132420 /* #2724 'NSSpellChecker' => 'AppKit.NSSpellChecker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25DC20 /* #2725 'AppKit_NSTextStorage__NSTextStorageDelegate' => 'AppKit.NSTextStorage+_NSTextStorageDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x132B20 /* #2726 'NSTextStorage' => 'AppKit.NSTextStorage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25DE20 /* #2727 'AppKit_NSWindow__NSWindowDelegate' => 'AppKit.NSWindow+_NSWindowDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x133020 /* #2728 'NSWorkspace' => 'AppKit.NSWorkspace, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x147520 /* #2729 'NSAccessibilityElement' => 'AppKit.NSAccessibilityElement, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25E820 /* #2730 'AppKit_NSAnimation__NSAnimationDelegate' => 'AppKit.NSAnimation+_NSAnimationDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x151320 /* #2731 'NSColorPanel' => 'AppKit.NSColorPanel, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25EB20 /* #2732 'AppKit_NSDatePicker__NSDatePickerCellDelegate' => 'AppKit.NSDatePicker+_NSDatePickerCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x152E20 /* #2733 'NSDatePicker' => 'AppKit.NSDatePicker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25EC20 /* #2734 'AppKit_NSDatePickerCell__NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCell+_NSDatePickerCellDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x153020 /* #2735 'NSDatePickerCell' => 'AppKit.NSDatePickerCell, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25ED20 /* #2736 'AppKit_NSDrawer__NSDrawerDelegate' => 'AppKit.NSDrawer+_NSDrawerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x154A20 /* #2737 'NSDrawer' => 'AppKit.NSDrawer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x157A20 /* #2738 'NSHelpManager' => 'AppKit.NSHelpManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x159820 /* #2739 'NSMenu' => 'AppKit.NSMenu, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15B220 /* #2740 'NSOutlineView' => 'AppKit.NSOutlineView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25F320 /* #2741 'AppKit_NSPageController__NSPageControllerDelegate' => 'AppKit.NSPageController+_NSPageControllerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x15BB20 /* #2742 'NSPageController' => 'AppKit.NSPageController, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x15E120 /* #2743 'NSPopover' => 'AppKit.NSPopover, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25F520 /* #2744 'AppKit_NSRuleEditor__NSRuleEditorDelegate' => 'AppKit.NSRuleEditor+_NSRuleEditorDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x25F720 /* #2745 'AppKit_NSSavePanel__NSOpenSavePanelDelegate' => 'AppKit.NSSavePanel+_NSOpenSavePanelDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x160520 /* #2746 'NSScroller' => 'AppKit.NSScroller, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x160620 /* #2747 'NSScrollView' => 'AppKit.NSScrollView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FA20 /* #2748 'AppKit_NSSearchField__NSSearchFieldDelegate' => 'AppKit.NSSearchField+_NSSearchFieldDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x161D20 /* #2749 'NSSearchField' => 'AppKit.NSSearchField, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FB20 /* #2750 'AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePicker+_NSSharingServicePickerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x163620 /* #2751 'NSSharingServicePicker' => 'AppKit.NSSharingServicePicker, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x164420 /* #2752 'NSSliderAccessory' => 'AppKit.NSSliderAccessory, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x165620 /* #2753 'NSSplitView' => 'AppKit.NSSplitView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FE20 /* #2754 'AppKit_NSTabView__NSTabViewDelegate' => 'AppKit.NSTabView+_NSTabViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x168720 /* #2755 'NSTabView' => 'AppKit.NSTabView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x25FF20 /* #2756 'AppKit_NSText__NSTextDelegate' => 'AppKit.NSText+_NSTextDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x168F20 /* #2757 'NSText' => 'AppKit.NSText, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x169020 /* #2758 'NSTextAlternatives' => 'AppKit.NSTextAlternatives, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x16B620 /* #2759 'NSTextInputContext' => 'AppKit.NSTextInputContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260420 /* #2760 'AppKit_NSTextView__NSTextViewDelegate' => 'AppKit.NSTextView+_NSTextViewDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16C620 /* #2761 'NSTextView' => 'AppKit.NSTextView, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260620 /* #2762 'AppKit_NSToolbar__NSToolbarDelegate' => 'AppKit.NSToolbar+_NSToolbarDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16DA20 /* #2763 'NSToolbar' => 'AppKit.NSToolbar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x260820 /* #2764 'AppKit_NSTouchBar__NSTouchBarDelegate' => 'AppKit.NSTouchBar+_NSTouchBarDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x16E720 /* #2765 'NSTouchBar' => 'AppKit.NSTouchBar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x17D320 /* #2766 'MLMultiArray' => 'CoreML.MLMultiArray, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18AE20 /* #2767 'NSManagedObjectContext' => 'CoreData.NSManagedObjectContext, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x18C120 /* #2768 'NSPersistentStoreCoordinator' => 'CoreData.NSPersistentStoreCoordinator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266C20 /* #2769 'CoreBluetooth_CBCentralManager__CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManager+_CBCentralManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18D520 /* #2770 'CBCentralManager' => 'CoreBluetooth.CBCentralManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266D20 /* #2771 'CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManager+_CBPeripheralManagerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18D620 /* #2772 'CBPeripheralManager' => 'CoreBluetooth.CBPeripheralManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266E20 /* #2773 'CoreBluetooth_CBPeripheral__CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheral+_CBPeripheralDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x18D820 /* #2774 'CBPeripheral' => 'CoreBluetooth.CBPeripheral, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x266F20 /* #2775 'AVFoundation_AVCaptureFileOutput_recordingProxy' => 'AVFoundation.AVCaptureFileOutput+recordingProxy, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x193F20 /* #2776 'AVCaptureVideoPreviewLayer' => 'AVFoundation.AVCaptureVideoPreviewLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x194A20 /* #2777 'AVAudioUnitComponentManager' => 'AVFoundation.AVAudioUnitComponentManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195520 /* #2778 'AVPlayerItem' => 'AVFoundation.AVPlayerItem, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x195620 /* #2779 'AVPlayerItemVideoOutput' => 'AVFoundation.AVPlayerItemVideoOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x197D20 /* #2780 'AVAssetExportSession' => 'AVFoundation.AVAssetExportSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x199620 /* #2781 'AVAssetWriter' => 'AVFoundation.AVAssetWriter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19B220 /* #2782 'AVAudioEngine' => 'AVFoundation.AVAudioEngine, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19CC20 /* #2783 'AVAudioPlayerNode' => 'AVFoundation.AVAudioPlayerNode, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x19ED20 /* #2784 'AVAudioUnitComponent' => 'AVFoundation.AVAudioUnitComponent, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A0B20 /* #2785 'AVCaptureDevice' => 'AVFoundation.AVCaptureDevice, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2820 /* #2786 'AVCapturePhotoOutput' => 'AVFoundation.AVCapturePhotoOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2920 /* #2787 'AVCapturePhotoSettings' => 'AVFoundation.AVCapturePhotoSettings, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2E20 /* #2788 'AVCaptureSession' => 'AVFoundation.AVCaptureSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A2F20 /* #2789 'AVCaptureStillImageOutput' => 'AVFoundation.AVCaptureStillImageOutput, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A4C20 /* #2790 'AVContentKeySession' => 'AVFoundation.AVContentKeySession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A5F20 /* #2791 'AVFragmentedMovie' => 'AVFoundation.AVFragmentedMovie, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A6220 /* #2792 'AVFragmentedMovieTrack' => 'AVFoundation.AVFragmentedMovieTrack, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1A8220 /* #2793 'AVMIDIPlayer' => 'AVFoundation.AVMidiPlayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AC620 /* #2794 'AVPlayerMediaSelectionCriteria' => 'AVFoundation.AVPlayerMediaSelectionCriteria, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ACE20 /* #2795 'AVRouteDetector' => 'AVFoundation.AVRouteDetector, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1ACF20 /* #2796 'AVSampleBufferAudioRenderer' => 'AVFoundation.AVSampleBufferAudioRenderer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD020 /* #2797 'AVSampleBufferDisplayLayer' => 'AVFoundation.AVSampleBufferDisplayLayer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD120 /* #2798 'AVSampleBufferGenerator' => 'AVFoundation.AVSampleBufferGenerator, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1AD220 /* #2799 'AVSampleBufferRenderSynchronizer' => 'AVFoundation.AVSampleBufferRenderSynchronizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26B320 /* #2800 'AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate' => 'AVFoundation.AVSpeechSynthesizer+_AVSpeechSynthesizerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1ADF20 /* #2801 'AVSpeechSynthesizer' => 'AVFoundation.AVSpeechSynthesizer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1520 /* #2802 'ASAuthorizationAppleIDCredential' => 'AuthenticationServices.ASAuthorizationAppleIdCredential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B1620 /* #2803 'ASAuthorizationAppleIDProvider' => 'AuthenticationServices.ASAuthorizationAppleIdProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B2D20 /* #2804 'ASAuthorizationProviderExtensionAuthorizationRequest' => 'AuthenticationServices.ASAuthorizationProviderExtensionAuthorizationRequest, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B3320 /* #2805 'ASAuthorizationSingleSignOnCredential' => 'AuthenticationServices.ASAuthorizationSingleSignOnCredential, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26C520 /* #2806 'Foundation_NSUrlSessionHandler_WrappedNSInputStream' => 'Foundation.NSUrlSessionHandler+WrappedNSInputStream, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x26C920 /* #2807 'Foundation_NSNetService__NSNetServiceDelegate' => 'Foundation.NSNetService+_NSNetServiceDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B5E20 /* #2808 'NSNetService' => 'Foundation.NSNetService, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B5F20 /* #2809 'NSUserActivity' => 'Foundation.NSUserActivity, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6820 /* #2810 'NSCalendar' => 'Foundation.NSCalendar, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B6D20 /* #2811 'NSDictionary' => 'Foundation.NSDictionary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7920 /* #2812 'NSFileManager' => 'Foundation.NSFileManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7D20 /* #2813 'NSHost' => 'Foundation.NSHost, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B7F20 /* #2814 'NSHTTPCookieStorage' => 'Foundation.NSHttpCookieStorage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8020 /* #2815 'NSIndexPath' => 'Foundation.NSIndexPath, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26E520 /* #2816 'Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiver+_NSKeyedArchiverDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B8420 /* #2817 'NSKeyedArchiver' => 'Foundation.NSKeyedArchiver, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26E620 /* #2818 'Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiver+_NSKeyedUnarchiverDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B8620 /* #2819 'NSLocale' => 'Foundation.NSLocale, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1B8C20 /* #2820 'NSMutableDictionary' => 'Foundation.NSMutableDictionary, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26F120 /* #2821 'Foundation_NSStream__NSStreamDelegate' => 'Foundation.NSStream+_NSStreamDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1BB020 /* #2822 'NSThread' => 'Foundation.NSThread, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26F420 /* #2823 'Foundation_NSThread_ActionThread' => 'Foundation.NSThread+ActionThread, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1BB320 /* #2824 'NSUbiquitousKeyValueStore' => 'Foundation.NSUbiquitousKeyValueStore, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BB420 /* #2825 'NSUndoManager' => 'Foundation.NSUndoManager, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BCA20 /* #2826 'NSURL' => 'Foundation.NSUrl, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BCD20 /* #2827 'NSURLConnection' => 'Foundation.NSUrlConnection, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD520 /* #2828 'NSUserDefaults' => 'Foundation.NSUserDefaults, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1BD820 /* #2829 'NSItemProvider' => 'Foundation.NSItemProvider, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x270C20 /* #2830 '__NSObject_Disposer' => 'Foundation.NSObject+NSObject_Disposer, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x270D20 /* #2831 '__XamarinObjectObserver' => 'Foundation.NSObject+Observer, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1C6620 /* #2832 'NSProgress' => 'Foundation.NSProgress, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271020 /* #2833 'Foundation_NSCache__NSCacheDelegate' => 'Foundation.NSCache+_NSCacheDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1C8420 /* #2834 'NSCache' => 'Foundation.NSCache, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CB220 /* #2835 'NSFileHandle' => 'Foundation.NSFileHandle, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1CBB20 /* #2836 'NSFileVersion' => 'Foundation.NSFileVersion, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271820 /* #2837 'Foundation_NSMetadataQuery__NSMetadataQueryDelegate' => 'Foundation.NSMetadataQuery+_NSMetadataQueryDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1CE820 /* #2838 'NSMetadataQuery' => 'Foundation.NSMetadataQuery, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x271A20 /* #2839 'Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowser+_NSNetServiceBrowserDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1CF820 /* #2840 'NSNetServiceBrowser' => 'Foundation.NSNetServiceBrowser, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D1D20 /* #2841 'NSProcessInfo' => 'Foundation.NSProcessInfo, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D2C20 /* #2842 'NSSecureUnarchiveFromDataTransformer' => 'Foundation.NSSecureUnarchiveFromDataTransformer, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D3620 /* #2843 'NSTask' => 'Foundation.NSTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D4420 /* #2844 'NSURLCache' => 'Foundation.NSUrlCache, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5220 /* #2845 'NSURLCredentialStorage' => 'Foundation.NSUrlCredentialStorage, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D5C20 /* #2846 'NSURLSession' => 'Foundation.NSUrlSession, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D7420 /* #2847 'NSURLSessionStreamTask' => 'Foundation.NSUrlSessionStreamTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x1D8620 /* #2848 'NSURLSessionWebSocketTask' => 'Foundation.NSUrlSessionWebSocketTask, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x273A20 /* #2849 'Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenter+_NSUserNotificationCenterDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D9120 /* #2850 'NSUserNotificationCenter' => 'Foundation.NSUserNotificationCenter, Xamarin.Mac' */, (MTTypeFlags) (0) /* None */ },
		{ NULL, 0x26C020 /* #2851 'Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate' => 'Foundation.NSUrlSessionHandler+NSUrlSessionHandlerDelegate, Xamarin.Mac' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7B52 /* #2852 'Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1' => 'Xamarin.Forms.Platform.MacOS.VisualElementRenderer`1, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7752 /* #2853 'Xamarin_Forms_Platform_MacOS_ViewRenderer_2' => 'Xamarin.Forms.Platform.MacOS.ViewRenderer`2, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7652 /* #2854 'Xamarin_Forms_Platform_MacOS_ViewRenderer' => 'Xamarin.Forms.Platform.MacOS.ViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x550 /* #2855 'Xamarin_Forms_Maps_MacOS_MapRenderer' => 'Xamarin.Forms.Maps.MacOS.MapRenderer, Xamarin.Forms.Maps.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xB52 /* #2856 'Xamarin_Forms_Platform_macOS_Controls_FormsBoxView' => 'Xamarin.Forms.Platform.macOS.Controls.FormsBoxView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xC52 /* #2857 'Xamarin_Forms_Platform_macOS_Controls_FormsNSSlider' => 'Xamarin.Forms.Platform.macOS.Controls.FormsNSSlider, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1152 /* #2858 'Xamarin_Forms_Platform_MacOS_FormsNSDatePicker' => 'Xamarin.Forms.Platform.MacOS.FormsNSDatePicker, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1352 /* #2859 'Xamarin_Forms_Platform_MacOS_FormsApplicationDelegate' => 'Xamarin.Forms.Platform.MacOS.FormsApplicationDelegate, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1452 /* #2860 'Xamarin_Forms_Platform_MacOS_PlatformRenderer' => 'Xamarin.Forms.Platform.MacOS.PlatformRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1B52 /* #2861 'Xamarin_Forms_Platform_MacOS_FlippedClipView' => 'Xamarin.Forms.Platform.MacOS.FlippedClipView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1C52 /* #2862 'Xamarin_Forms_Platform_MacOS_PageRenderer' => 'Xamarin.Forms.Platform.MacOS.PageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1D52 /* #2863 'Xamarin_Forms_Platform_MacOS_DefaultRenderer' => 'Xamarin.Forms.Platform.MacOS.DefaultRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2552 /* #2864 'Xamarin_Forms_Platform_MacOS_BoxViewRenderer' => 'Xamarin.Forms.Platform.MacOS.BoxViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2652 /* #2865 'Xamarin_Forms_Platform_MacOS_ScrollViewRenderer' => 'Xamarin.Forms.Platform.MacOS.ScrollViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2752 /* #2866 'Xamarin_Forms_Platform_MacOS_ActivityIndicatorRenderer' => 'Xamarin.Forms.Platform.MacOS.ActivityIndicatorRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2852 /* #2867 'Xamarin_Forms_Platform_MacOS_DatePickerRenderer' => 'Xamarin.Forms.Platform.MacOS.DatePickerRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2B52 /* #2868 'Xamarin_Forms_Platform_MacOS_FrameRenderer' => 'Xamarin.Forms.Platform.MacOS.FrameRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2C52 /* #2869 'Xamarin_Forms_Platform_MacOS_FormsNSImageView' => 'Xamarin.Forms.Platform.MacOS.FormsNSImageView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2E52 /* #2870 'Xamarin_Forms_Platform_MacOS_OpenGLViewRenderer' => 'Xamarin.Forms.Platform.MacOS.OpenGLViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2F52 /* #2871 'Xamarin_Forms_Platform_MacOS_MacOSOpenGLView' => 'Xamarin.Forms.Platform.MacOS.MacOSOpenGLView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3052 /* #2872 'Xamarin_Forms_Platform_MacOS_PickerRenderer' => 'Xamarin.Forms.Platform.MacOS.PickerRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3152 /* #2873 'Xamarin_Forms_Platform_MacOS_ProgressBarRenderer' => 'Xamarin.Forms.Platform.MacOS.ProgressBarRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3252 /* #2874 'Xamarin_Forms_Platform_MacOS_SearchBarRenderer' => 'Xamarin.Forms.Platform.MacOS.SearchBarRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3352 /* #2875 'Xamarin_Forms_Platform_MacOS_SliderRenderer' => 'Xamarin.Forms.Platform.MacOS.SliderRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3452 /* #2876 'Xamarin_Forms_Platform_MacOS_StepperRenderer' => 'Xamarin.Forms.Platform.MacOS.StepperRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3552 /* #2877 'Xamarin_Forms_Platform_MacOS_CheckBoxRenderer' => 'Xamarin.Forms.Platform.MacOS.CheckBoxRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3652 /* #2878 'Xamarin_Forms_Platform_MacOS_SwitchRenderer' => 'Xamarin.Forms.Platform.MacOS.SwitchRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3752 /* #2879 'Xamarin_Forms_Platform_MacOS_TimePickerRenderer' => 'Xamarin.Forms.Platform.MacOS.TimePickerRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3A52 /* #2880 'Xamarin_Forms_Platform_MacOS_CellNSView' => 'Xamarin.Forms.Platform.MacOS.CellNSView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3B52 /* #2881 'Xamarin_Forms_Platform_MacOS_TrackingClickNSView' => 'Xamarin.Forms.Platform.MacOS.TrackingClickNSView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4452 /* #2882 'Xamarin_Forms_Platform_MacOS_ViewCellNSView' => 'Xamarin.Forms.Platform.MacOS.ViewCellNSView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4552 /* #2883 'Xamarin_Forms_Platform_MacOS_ListViewDataSource' => 'Xamarin.Forms.Platform.MacOS.ListViewDataSource, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4652 /* #2884 'Xamarin_Forms_Platform_MacOS_CustomNSTableHeaderView' => 'Xamarin.Forms.Platform.MacOS.CustomNSTableHeaderView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4D52 /* #2885 'Xamarin_Forms_Platform_MacOS_FormsPageControllerDelegate' => 'Xamarin.Forms.Platform.MacOS.FormsPageControllerDelegate, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4E52 /* #2886 'Xamarin_Forms_Platform_MacOS_NavigationChildPageWrapper' => 'Xamarin.Forms.Platform.MacOS.NavigationChildPageWrapper, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4F52 /* #2887 'Xamarin_Forms_Platform_MacOS_NativeViewPropertyListener' => 'Xamarin.Forms.Platform.MacOS.NativeViewPropertyListener, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5052 /* #2888 'Xamarin_Forms_Platform_MacOS_LayoutRenderer' => 'Xamarin.Forms.Platform.MacOS.LayoutRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5252 /* #2889 'Xamarin_Forms_Platform_MacOS_NSPageContainer' => 'Xamarin.Forms.Platform.MacOS.NSPageContainer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5352 /* #2890 'Xamarin_Forms_Platform_MacOS_PageControllerDelegate' => 'Xamarin.Forms.Platform.MacOS.PageControllerDelegate, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5752 /* #2891 'Xamarin_Forms_Platform_MacOS_TableViewRenderer' => 'Xamarin.Forms.Platform.MacOS.TableViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5952 /* #2892 'Xamarin_Forms_Platform_MacOS_TableViewDataSource' => 'Xamarin.Forms.Platform.MacOS.TableViewDataSource, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5A52 /* #2893 'Xamarin_Forms_Platform_MacOS_UnEvenTableViewModelRenderer' => 'Xamarin.Forms.Platform.MacOS.UnEvenTableViewModelRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5E52 /* #2894 'Xamarin_Forms_Platform_MacOS_VerticallyCenteredTextFieldCell' => 'Xamarin.Forms.Platform.MacOS.VerticallyCenteredTextFieldCell, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x6D52 /* #2895 'Xamarin_Forms_Platform_MacOS_NativeViewWrapperRenderer' => 'Xamarin.Forms.Platform.MacOS.NativeViewWrapperRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x7252 /* #2896 'Xamarin_Forms_Platform_MacOS_LabelRenderer' => 'Xamarin.Forms.Platform.MacOS.LabelRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1F52 /* #2897 'Xamarin_Forms_Platform_MacOS_ButtonRenderer' => 'Xamarin.Forms.Platform.MacOS.ButtonRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8F52 /* #2898 'Xamarin_Forms_Platform_MacOS_EntryRenderer_FormsNSTextField' => 'Xamarin.Forms.Platform.MacOS.EntryRenderer+FormsNSTextField, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2952 /* #2899 'Xamarin_Forms_Platform_MacOS_EntryRenderer' => 'Xamarin.Forms.Platform.MacOS.EntryRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2A52 /* #2900 'Xamarin_Forms_Platform_MacOS_EditorRenderer' => 'Xamarin.Forms.Platform.MacOS.EditorRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x2D52 /* #2901 'Xamarin_Forms_Platform_MacOS_ImageRenderer' => 'Xamarin.Forms.Platform.MacOS.ImageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9552 /* #2902 'Xamarin_Forms_Platform_MacOS_WebViewRenderer_FormsWebFrameDelegate' => 'Xamarin.Forms.Platform.MacOS.WebViewRenderer+FormsWebFrameDelegate, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3852 /* #2903 'Xamarin_Forms_Platform_MacOS_WebViewRenderer' => 'Xamarin.Forms.Platform.MacOS.WebViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9852 /* #2904 'Xamarin_Forms_Platform_MacOS_ListViewRenderer_FormsNSTableView' => 'Xamarin.Forms.Platform.MacOS.ListViewRenderer+FormsNSTableView, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x3952 /* #2905 'Xamarin_Forms_Platform_MacOS_ListViewRenderer' => 'Xamarin.Forms.Platform.MacOS.ListViewRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4752 /* #2906 'CarouselPageRenderer' => 'Xamarin.Forms.Platform.MacOS.CarouselPageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9D52 /* #2907 'Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer_ViewControllerWrapper' => 'Xamarin.Forms.Platform.MacOS.MasterDetailPageRenderer+ViewControllerWrapper, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4A52 /* #2908 'Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer' => 'Xamarin.Forms.Platform.MacOS.MasterDetailPageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4B52 /* #2909 'Xamarin_Forms_Platform_MacOS_TabbedPageRenderer' => 'Xamarin.Forms.Platform.MacOS.TabbedPageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x4C52 /* #2910 'Xamarin_Forms_Platform_MacOS_NavigationPageRenderer' => 'Xamarin.Forms.Platform.MacOS.NavigationPageRenderer, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xAD52 /* #2911 'Xamarin_Forms_Platform_MacOS_NativeToolbarTracker_ToolBarItemNSButton' => 'Xamarin.Forms.Platform.MacOS.NativeToolbarTracker+ToolBarItemNSButton, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x5C52 /* #2912 'Xamarin_Forms_Platform_MacOS_NativeToolbarTracker' => 'Xamarin.Forms.Platform.MacOS.NativeToolbarTracker, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0xCF52 /* #2913 'Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton_FormsNSButtonCell' => 'Xamarin.Forms.Platform.MacOS.ButtonRenderer+FormsNSButton+FormsNSButtonCell, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x8C52 /* #2914 'Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton' => 'Xamarin.Forms.Platform.MacOS.ButtonRenderer+FormsNSButton, Xamarin.Forms.Platform.macOS' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x1 /* #2915 'AppDelegate' => 'AnimatingViews.AppDelegate, AnimatingViews' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x9 /* #2916 'AnimatingViewsWindow' => 'AnimatingViews.AnimatingViewsWindow, AnimatingViews' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x11 /* #2917 'AnimatingViews_AnimatingViewsWindowController_MessageTypeDataSource' => 'AnimatingViews.AnimatingViewsWindowController+MessageTypeDataSource, AnimatingViews' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0x19 /* #2918 'AnimatingViewsWindowController' => 'AnimatingViews.AnimatingViewsWindowController, AnimatingViews' */, (MTTypeFlags) (3) /* CustomType, UserType */ },
		{ NULL, 0 },
	};

	static const MTManagedClassMap __xamarin_skipped_map [] = {
		{ 0x91220, 0x91320 /* 'Intents.INIntentResolutionResult`1' => 'Intents.INIntentResolutionResult' */ },
		{ 0x9A620, 0x9A520 /* 'GameplayKit.GKObstacleGraph`1' => 'GameplayKit.GKObstacleGraph' */ },
		{ 0x1B6320, 0x1B6220 /* 'Foundation.NSArray`1' => 'Foundation.NSArray' */ },
		{ 0x1B6E20, 0x1B6D20 /* 'Foundation.NSDictionary`2' => 'Foundation.NSDictionary' */ },
		{ 0x1B7020, 0x1CA920 /* 'Foundation.NSEnumerator`1' => 'Foundation.NSEnumerator' */ },
		{ 0x1B8920, 0x1B8820 /* 'Foundation.NSMutableArray`1' => 'Foundation.NSMutableArray' */ },
		{ 0x1B8D20, 0x1B8C20 /* 'Foundation.NSMutableDictionary`2' => 'Foundation.NSMutableDictionary' */ },
		{ 0x1B8E20, 0x1B9920 /* 'Foundation.NSMutableOrderedSet`1' => 'Foundation.NSMutableOrderedSet' */ },
		{ 0x1B9020, 0x1B8F20 /* 'Foundation.NSMutableSet`1' => 'Foundation.NSMutableSet' */ },
		{ 0x1B9A20, 0x1B9820 /* 'Foundation.NSOrderedSet`1' => 'Foundation.NSOrderedSet' */ },
		{ 0x1BAA20, 0x1BA920 /* 'Foundation.NSSet`1' => 'Foundation.NSSet' */ },
	};

	static const char *__xamarin_registration_assemblies []= {
		"DarkSkyCore", 
		"netstandard", 
		"mscorlib", 
		"System.Core", 
		"System", 
		"Mono.Security", 
		"System.Xml", 
		"System.Numerics", 
		"System.Data", 
		"System.Transactions", 
		"System.Data.DataSetExtensions", 
		"System.Drawing.Common", 
		"System.IO.Compression", 
		"System.IO.Compression.FileSystem", 
		"System.ComponentModel.Composition", 
		"System.Net.Http", 
		"Xamarin.Mac", 
		"System.Runtime.Serialization", 
		"System.ServiceModel.Internals", 
		"System.Web.Services", 
		"System.Xml.Linq", 
		"Newtonsoft.Json", 
		"NodaTime", 
		"OpenWeatherMap", 
		"System.Runtime", 
		"System.Threading.Tasks", 
		"System.Xml.XmlSerializer", 
		"System.Xml.ReaderWriter", 
		"System.IO", 
		"System.Diagnostics.Debug", 
		"System.Net.Primitives", 
		"System.Globalization", 
		"System.Linq", 
		"System.Runtime.Extensions", 
		"System.Collections", 
		"Xamarin.Essentials", 
		"System.Numerics.Vectors", 
		"Xamarin.Forms.Core", 
		"Xamarin.Forms.Platform", 
		"Xamarin.Forms.Maps", 
		"Xamarin.Forms.Maps.macOS", 
		"Xamarin.Forms.Platform.macOS", 
		"Xamarin.Forms.Xaml", 
		"Microsoft.Win32.Primitives", 
		"Microsoft.Win32.Registry.AccessControl", 
		"Microsoft.Win32.Registry", 
		"System.AppContext", 
		"System.Buffers", 
		"System.Collections.Concurrent", 
		"System.Collections.NonGeneric", 
		"System.Collections.Specialized", 
		"System.ComponentModel.Annotations", 
		"System.ComponentModel.DataAnnotations", 
		"System.ComponentModel", 
		"System.ComponentModel.EventBasedAsync", 
		"System.ComponentModel.Primitives", 
		"System.ComponentModel.TypeConverter", 
		"System.Console", 
		"System.Data.Common", 
		"System.Data.SqlClient", 
		"System.Diagnostics.Contracts", 
		"System.Diagnostics.FileVersionInfo", 
		"System.Diagnostics.Process", 
		"System.Diagnostics.StackTrace", 
		"System.Diagnostics.TextWriterTraceListener", 
		"System.Diagnostics.Tools", 
		"System.Diagnostics.TraceEvent", 
		"System.Diagnostics.TraceSource", 
		"System.Diagnostics.Tracing", 
		"System.Drawing.Primitives", 
		"System.Dynamic.Runtime", 
		"System.Globalization.Calendars", 
		"System.Globalization.Extensions", 
		"System.IO.Compression.ZipFile", 
		"System.IO.FileSystem.AccessControl", 
		"System.IO.FileSystem", 
		"System.IO.FileSystem.DriveInfo", 
		"System.IO.FileSystem.Primitives", 
		"System.IO.FileSystem.Watcher", 
		"System.IO.IsolatedStorage", 
		"System.IO.MemoryMappedFiles", 
		"System.IO.Pipes", 
		"System.IO.UnmanagedMemoryStream", 
		"System.Linq.Expressions", 
		"System.Linq.Parallel", 
		"System.Linq.Queryable", 
		"System.Memory", 
		"System.Net.AuthenticationManager", 
		"System.Net.Cache", 
		"System.Net.HttpListener", 
		"System.Net.Mail", 
		"System.Net.NameResolution", 
		"System.Net.NetworkInformation", 
		"System.Net.Ping", 
		"System.Net.Requests", 
		"System.Net.Security", 
		"System.Net.ServicePoint", 
		"System.Net.Sockets", 
		"System.Net.Utilities", 
		"System.Net.WebHeaderCollection", 
		"System.Net.WebSockets.Client", 
		"System.Net.WebSockets", 
		"System.ObjectModel", 
		"System.Reflection.DispatchProxy", 
		"System.Reflection", 
		"System.Reflection.Emit", 
		"System.Reflection.Emit.ILGeneration", 
		"System.Reflection.Emit.Lightweight", 
		"System.Reflection.Extensions", 
		"System.Reflection.Primitives", 
		"System.Reflection.TypeExtensions", 
		"System.Resources.Reader", 
		"System.Resources.ReaderWriter", 
		"System.Resources.ResourceManager", 
		"System.Resources.Writer", 
		"System.Runtime.CompilerServices.VisualC", 
		"System.Runtime.Handles", 
		"System.Runtime.InteropServices", 
		"System.Runtime.InteropServices.RuntimeInformation", 
		"System.Runtime.InteropServices.WindowsRuntime", 
		"System.Runtime.Loader", 
		"System.Runtime.Numerics", 
		"System.Runtime.Serialization.Formatters", 
		"System.Runtime.Serialization.Json", 
		"System.Runtime.Serialization.Primitives", 
		"System.Runtime.Serialization.Xml", 
		"System.Security.AccessControl", 
		"System.Security.Claims", 
		"System.Security.Cryptography.Algorithms", 
		"System.Security.Cryptography.Cng", 
		"System.Security.Cryptography.Csp", 
		"System.Security.Cryptography.DeriveBytes", 
		"System.Security.Cryptography.Encoding", 
		"System.Security.Cryptography.Encryption.Aes", 
		"System.Security.Cryptography.Encryption", 
		"System.Security.Cryptography.Encryption.ECDiffieHellman", 
		"System.Security.Cryptography.Encryption.ECDsa", 
		"System.Security.Cryptography.Hashing.Algorithms", 
		"System.Security.Cryptography.Hashing", 
		"System.Security.Cryptography.OpenSsl", 
		"System.Security.Cryptography.Pkcs", 
		"System.Security", 
		"System.Security.Cryptography.Primitives", 
		"System.Security.Cryptography.ProtectedData", 
		"System.Security.Cryptography.RandomNumberGenerator", 
		"System.Security.Cryptography.RSA", 
		"System.Security.Cryptography.X509Certificates", 
		"System.Security.Principal", 
		"System.Security.Principal.Windows", 
		"System.Security.SecureString", 
		"System.ServiceModel.Duplex", 
		"System.ServiceModel", 
		"System.IdentityModel", 
		"System.ServiceModel.Http", 
		"System.ServiceModel.NetTcp", 
		"System.ServiceModel.Primitives", 
		"System.ServiceModel.Security", 
		"System.ServiceProcess.ServiceController", 
		"System.Text.Encoding.CodePages", 
		"System.Text.Encoding", 
		"System.Text.Encoding.Extensions", 
		"System.Text.RegularExpressions", 
		"System.Threading.AccessControl", 
		"System.Threading", 
		"System.Threading.Overlapped", 
		"System.Threading.Tasks.Extensions", 
		"System.Threading.Tasks.Parallel", 
		"System.Threading.Thread", 
		"System.Threading.ThreadPool", 
		"System.Threading.Timer", 
		"System.ValueTuple", 
		"System.Xml.XDocument", 
		"System.Xml.XmlDocument", 
		"System.Xml.XPath", 
		"System.Xml.XPath.XDocument", 
		"System.Xml.XPath.XmlDocument", 
		"System.Xml.Xsl.Primitives", 
		"AnimatingViews"
	};

	static const struct MTFullTokenReference __xamarin_token_references [] = {
		{ /* #1 = 0x1 */ "AnimatingViews", 0x1, 0x2000003 },
		{ /* #2 = 0x3 */ "AnimatingViews", 0x1, 0x6000004 },
		{ /* #3 = 0x5 */ "AnimatingViews", 0x1, 0x6000005 },
		{ /* #4 = 0x7 */ "AnimatingViews", 0x1, 0x6000003 },
		{ /* #5 = 0x9 */ "AnimatingViews", 0x1, 0x2000004 },
		{ /* #6 = 0xB */ "AnimatingViews", 0x1, 0x6000008 },
		{ /* #7 = 0xD */ "AnimatingViews", 0x1, 0x6000009 },
		{ /* #8 = 0xF */ "AnimatingViews", 0x1, 0x6000007 },
		{ /* #9 = 0x11 */ "AnimatingViews", 0x1, 0x2000008 },
		{ /* #10 = 0x13 */ "AnimatingViews", 0x1, 0x600003E },
		{ /* #11 = 0x15 */ "AnimatingViews", 0x1, 0x600003F },
		{ /* #12 = 0x17 */ "AnimatingViews", 0x1, 0x6000040 },
		{ /* #13 = 0x19 */ "AnimatingViews", 0x1, 0x2000005 },
		{ /* #14 = 0x1B */ "AnimatingViews", 0x1, 0x6000020 },
		{ /* #15 = 0x1D */ "AnimatingViews", 0x1, 0x6000021 },
		{ /* #16 = 0x1F */ "AnimatingViews", 0x1, 0x6000022 },
		{ /* #17 = 0x21 */ "AnimatingViews", 0x1, 0x6000023 },
		{ /* #18 = 0x23 */ "AnimatingViews", 0x1, 0x6000024 },
		{ /* #19 = 0x25 */ "AnimatingViews", 0x1, 0x6000025 },
		{ /* #20 = 0x27 */ "AnimatingViews", 0x1, 0x6000026 },
		{ /* #21 = 0x29 */ "AnimatingViews", 0x1, 0x6000027 },
		{ /* #22 = 0x2B */ "AnimatingViews", 0x1, 0x6000028 },
		{ /* #23 = 0x2D */ "AnimatingViews", 0x1, 0x6000029 },
		{ /* #24 = 0x2F */ "AnimatingViews", 0x1, 0x600002A },
		{ /* #25 = 0x31 */ "AnimatingViews", 0x1, 0x600002B },
		{ /* #26 = 0x33 */ "AnimatingViews", 0x1, 0x600002C },
		{ /* #27 = 0x35 */ "AnimatingViews", 0x1, 0x600002D },
		{ /* #28 = 0x37 */ "AnimatingViews", 0x1, 0x600002E },
		{ /* #29 = 0x39 */ "AnimatingViews", 0x1, 0x600002F },
		{ /* #30 = 0x3B */ "AnimatingViews", 0x1, 0x6000030 },
		{ /* #31 = 0x3D */ "AnimatingViews", 0x1, 0x6000031 },
		{ /* #32 = 0x3F */ "AnimatingViews", 0x1, 0x600000B },
		{ /* #33 = 0x41 */ "AnimatingViews", 0x1, 0x6000032 },
		{ /* #34 = 0x43 */ "AnimatingViews", 0x1, 0x6000033 },
		{ /* #35 = 0x45 */ "AnimatingViews", 0x1, 0x600000E },
		{ /* #36 = 0x47 */ "AnimatingViews", 0x1, 0x600000F },

	};

	static const MTProtocolWrapperMap __xamarin_protocol_wrapper_map [] = {
		{ 0xC20 /* SoundAnalysis.ISNRequest */, 0xD20 /* SNRequestWrapper */ },
		{ 0xE20 /* SoundAnalysis.ISNResult */, 0xF20 /* SNResultWrapper */ },
		{ 0x1020 /* SoundAnalysis.ISNResultsObserving */, 0x1220 /* SNResultsObservingWrapper */ },
		{ 0x1D20 /* SafariServices.ISFSafariExtensionHandling */, 0x1F20 /* SFSafariExtensionHandlingWrapper */ },
		{ 0x2E20 /* Speech.ISFSpeechRecognitionTaskDelegate */, 0x3020 /* SFSpeechRecognitionTaskDelegateWrapper */ },
		{ 0x3620 /* Speech.ISFSpeechRecognizerDelegate */, 0x3820 /* SFSpeechRecognizerDelegateWrapper */ },
		{ 0x4F20 /* PushKit.IPKPushRegistryDelegate */, 0x5120 /* PKPushRegistryDelegateWrapper */ },
		{ 0x5520 /* PhotosUI.IPHContentEditingController */, 0x5620 /* PHContentEditingControllerWrapper */ },
		{ 0x5920 /* PhotosUI.IPHLivePhotoViewDelegate */, 0x5B20 /* PHLivePhotoViewDelegateWrapper */ },
		{ 0x6320 /* PhotosUI.IPHProjectExtensionController */, 0x6520 /* PHProjectExtensionControllerWrapper */ },
		{ 0x6F20 /* PhotosUI.IPHProjectTypeDescriptionDataSource */, 0x7120 /* PHProjectTypeDescriptionDataSourceWrapper */ },
		{ 0x7320 /* PhotosUI.IPHProjectTypeDescriptionInvalidator */, 0x7420 /* PHProjectTypeDescriptionInvalidatorWrapper */ },
		{ 0x7520 /* FileProvider.INSFileProviderChangeObserver */, 0x7620 /* NSFileProviderChangeObserverWrapper */ },
		{ 0x7720 /* FileProvider.INSFileProviderEnumerationObserver */, 0x7820 /* NSFileProviderEnumerationObserverWrapper */ },
		{ 0x7920 /* FileProvider.INSFileProviderEnumerator */, 0x7B20 /* NSFileProviderEnumeratorWrapper */ },
		{ 0x7C20 /* FileProvider.INSFileProviderItem */, 0x7E20 /* NSFileProviderItemWrapper */ },
		{ 0x8020 /* FileProvider.INSFileProviderItemFlags */, 0x8120 /* NSFileProviderItemFlagsWrapper */ },
		{ 0x8720 /* NotificationCenter.INCWidgetListViewDelegate */, 0x8920 /* NCWidgetListViewDelegateWrapper */ },
		{ 0x8B20 /* NotificationCenter.INCWidgetProviding */, 0x8D20 /* NCWidgetProvidingWrapper */ },
		{ 0x9220 /* NotificationCenter.INCWidgetSearchViewDelegate */, 0x9320 /* NCWidgetSearchViewDelegateWrapper */ },
		{ 0xAF20 /* ImageCaptureCore.IICCameraDeviceDelegate */, 0xB120 /* ICCameraDeviceDelegateWrapper */ },
		{ 0xB320 /* ImageCaptureCore.IICCameraDeviceDownloadDelegate */, 0xB520 /* ICCameraDeviceDownloadDelegateWrapper */ },
		{ 0xBD20 /* ImageCaptureCore.IICDeviceBrowserDelegate */, 0xBF20 /* ICDeviceBrowserDelegateWrapper */ },
		{ 0xC220 /* ImageCaptureCore.IICDeviceDelegate */, 0xC420 /* ICDeviceDelegateWrapper */ },
		{ 0xD020 /* ImageCaptureCore.IICScannerDeviceDelegate */, 0xD220 /* ICScannerDeviceDelegateWrapper */ },
		{ 0xF320 /* ExternalAccessory.IEAAccessoryDelegate */, 0xF520 /* EAAccessoryDelegateWrapper */ },
		{ 0x10120 /* ContactsUI.ICNContactPickerDelegate */, 0x10320 /* CNContactPickerDelegateWrapper */ },
		{ 0x10820 /* CoreAudioKit.IAUCustomViewPersistentData */, 0x10920 /* AUCustomViewPersistentDataWrapper */ },
		{ 0x12B20 /* ImageKit.IIKCameraDeviceViewDelegate */, 0x12D20 /* IKCameraDeviceViewDelegateWrapper */ },
		{ 0x13220 /* ImageKit.IIKDeviceBrowserViewDelegate */, 0x13420 /* IKDeviceBrowserViewDelegateWrapper */ },
		{ 0x13820 /* ImageKit.IIKFilterCustomUIProvider */, 0x13920 /* IKFilterCustomUIProviderWrapper */ },
		{ 0x14E20 /* ImageKit.IIKImageEditPanelDataSource */, 0x15020 /* IKImageEditPanelDataSourceWrapper */ },
		{ 0x16020 /* ImageKit.IIKScannerDeviceViewDelegate */, 0x16220 /* IKScannerDeviceViewDelegateWrapper */ },
		{ 0x16520 /* ImageKit.IIKSlideshowDataSource */, 0x16720 /* IKSlideshowDataSourceWrapper */ },
		{ 0x16F20 /* FinderSync.IFIFinderSyncProtocol */, 0x17120 /* FIFinderSyncProtocolWrapper */ },
		{ 0x22820 /* Vision.IVNFaceObservationAccepting */, 0x22920 /* VNFaceObservationAcceptingWrapper */ },
		{ 0x24A20 /* Vision.IVNRequestProgressProviding */, 0x24B20 /* VNRequestProgressProvidingWrapper */ },
		{ 0x24D20 /* Vision.IVNRequestRevisionProviding */, 0x24E20 /* VNRequestRevisionProvidingWrapper */ },
		{ 0x29720 /* VideoSubscriberAccount.IVSAccountManagerDelegate */, 0x29920 /* VSAccountManagerDelegateWrapper */ },
		{ 0x2C620 /* UserNotifications.IUNUserNotificationCenterDelegate */, 0x2C820 /* UNUserNotificationCenterDelegateWrapper */ },
		{ 0x2E120 /* StoreKit.ISKPaymentQueueDelegate */, 0x2E320 /* SKPaymentQueueDelegateWrapper */ },
		{ 0x2E620 /* StoreKit.ISKPaymentTransactionObserver */, 0x2E720 /* SKPaymentTransactionObserverWrapper */ },
		{ 0x2F020 /* StoreKit.ISKProductsRequestDelegate */, 0x2F120 /* SKProductsRequestDelegateWrapper */ },
		{ 0x2F720 /* StoreKit.ISKRequestDelegate */, 0x2F920 /* SKRequestDelegateWrapper */ },
		{ 0x36D20 /* ScriptingBridge.ISBApplicationDelegate */, 0x36E20 /* SBApplicationDelegateWrapper */ },
		{ 0x37420 /* QuickLookUI.IQLPreviewingController */, 0x37620 /* QLPreviewingControllerWrapper */ },
		{ 0x37720 /* QuickLookUI.IQLPreviewItem */, 0x37920 /* QLPreviewItemWrapper */ },
		{ 0x37C20 /* QuickLookUI.IQLPreviewPanelDataSource */, 0x37D20 /* QLPreviewPanelDataSourceWrapper */ },
		{ 0x37F20 /* QuickLookUI.IQLPreviewPanelDelegate */, 0x38120 /* QLPreviewPanelDelegateWrapper */ },
		{ 0x40620 /* Photos.IPHLivePhotoFrame */, 0x40720 /* PHLivePhotoFrameWrapper */ },
		{ 0x41020 /* Photos.IPHPhotoLibraryAvailabilityObserver */, 0x41120 /* PHPhotoLibraryAvailabilityObserverWrapper */ },
		{ 0x41220 /* Photos.IPHPhotoLibraryChangeObserver */, 0x41320 /* PHPhotoLibraryChangeObserverWrapper */ },
		{ 0x45C20 /* PdfKit.IPdfDocumentDelegate */, 0x45E20 /* PdfDocumentDelegateWrapper */ },
		{ 0x46E20 /* PdfKit.IPdfViewDelegate */, 0x47020 /* PdfViewDelegateWrapper */ },
		{ 0x4F420 /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */, 0x4F620 /* NWTcpConnectionAuthenticationDelegateWrapper */ },
		{ 0x51720 /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */, 0x51920 /* MCAdvertiserAssistantDelegateWrapper */ },
		{ 0x51C20 /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */, 0x51E20 /* MCBrowserViewControllerDelegateWrapper */ },
		{ 0x52420 /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */, 0x52620 /* MCNearbyServiceAdvertiserDelegateWrapper */ },
		{ 0x52920 /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */, 0x52B20 /* MCNearbyServiceBrowserDelegateWrapper */ },
		{ 0x52D20 /* MultipeerConnectivity.IMCSessionDelegate */, 0x52F20 /* MCSessionDelegateWrapper */ },
		{ 0x55D20 /* ModelIO.IMDLAssetResolver */, 0x55E20 /* MDLAssetResolverWrapper */ },
		{ 0x56320 /* ModelIO.IMDLComponent */, 0x56420 /* MDLComponentWrapper */ },
		{ 0x56620 /* ModelIO.IMDLJointAnimation */, 0x56720 /* MDLJointAnimationWrapper */ },
		{ 0x56A20 /* ModelIO.IMDLLightProbeIrradianceDataSource */, 0x56C20 /* MDLLightProbeIrradianceDataSourceWrapper */ },
		{ 0x57320 /* ModelIO.IMDLMeshBuffer */, 0x57520 /* MDLMeshBufferWrapper */ },
		{ 0x57620 /* ModelIO.IMDLMeshBufferAllocator */, 0x57720 /* MDLMeshBufferAllocatorWrapper */ },
		{ 0x57B20 /* ModelIO.IMDLMeshBufferZone */, 0x57D20 /* MDLMeshBufferZoneWrapper */ },
		{ 0x57F20 /* ModelIO.IMDLNamed */, 0x58020 /* MDLNamedWrapper */ },
		{ 0x58420 /* ModelIO.IMDLObjectContainerComponent */, 0x58620 /* MDLObjectContainerComponentWrapper */ },
		{ 0x59620 /* ModelIO.IMDLTransformComponent */, 0x59720 /* MDLTransformComponentWrapper */ },
		{ 0x59920 /* ModelIO.IMDLTransformOp */, 0x59A20 /* MDLTransformOpWrapper */ },
		{ 0x60020 /* MetalPerformanceShaders.IMPSCnnBatchNormalizationDataSource */, 0x60220 /* MPSCnnBatchNormalizationDataSourceWrapper */ },
		{ 0x60B20 /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */, 0x60D20 /* MPSCnnConvolutionDataSourceWrapper */ },
		{ 0x62C20 /* MetalPerformanceShaders.IMPSCnnInstanceNormalizationDataSource */, 0x62E20 /* MPSCnnInstanceNormalizationDataSourceWrapper */ },
		{ 0x68E20 /* MetalPerformanceShaders.IMPSDeviceProvider */, 0x68F20 /* MPSDeviceProviderWrapper */ },
		{ 0x69120 /* MetalPerformanceShaders.IMPSHandle */, 0x69220 /* MPSHandleWrapper */ },
		{ 0x69520 /* MetalPerformanceShaders.IMPSImageAllocator */, 0x69720 /* MPSImageAllocatorWrapper */ },
		{ 0x6B820 /* MetalPerformanceShaders.IMPSImageSizeEncodingState */, 0x6B920 /* MPSImageSizeEncodingStateWrapper */ },
		{ 0x6BF20 /* MetalPerformanceShaders.IMPSImageTransformProvider */, 0x6C020 /* MPSImageTransformProviderWrapper */ },
		{ 0x6FF20 /* MetalPerformanceShaders.IMPSNNPadding */, 0x70120 /* MPSNNPaddingWrapper */ },
		{ 0x73120 /* MetalPerformanceShaders.IMPSNNTrainableNode */, 0x73220 /* MPSNNTrainableNodeWrapper */ },
		{ 0x75620 /* MetalKit.IMTKViewDelegate */, 0x75720 /* MTKViewDelegateWrapper */ },
		{ 0x78320 /* Metal.IMTLArgumentEncoder */, 0x78420 /* MTLArgumentEncoderWrapper */ },
		{ 0x78D20 /* Metal.IMTLBlitCommandEncoder */, 0x78F20 /* MTLBlitCommandEncoderWrapper */ },
		{ 0x79120 /* Metal.IMTLBuffer */, 0x79320 /* MTLBufferWrapper */ },
		{ 0x79A20 /* Metal.IMTLCaptureScope */, 0x79B20 /* MTLCaptureScopeWrapper */ },
		{ 0x79E20 /* Metal.IMTLCommandBuffer */, 0x7A020 /* MTLCommandBufferWrapper */ },
		{ 0x7A420 /* Metal.IMTLCommandEncoder */, 0x7A520 /* MTLCommandEncoderWrapper */ },
		{ 0x7A620 /* Metal.IMTLCommandQueue */, 0x7A720 /* MTLCommandQueueWrapper */ },
		{ 0x7AC20 /* Metal.IMTLComputeCommandEncoder */, 0x7AD20 /* MTLComputeCommandEncoderWrapper */ },
		{ 0x7B020 /* Metal.IMTLComputePipelineState */, 0x7B220 /* MTLComputePipelineStateWrapper */ },
		{ 0x7B320 /* Metal.IMTLCounter */, 0x7B420 /* MTLCounterWrapper */ },
		{ 0x7B620 /* Metal.IMTLCounterSampleBuffer */, 0x7B720 /* MTLCounterSampleBufferWrapper */ },
		{ 0x7BC20 /* Metal.IMTLCounterSet */, 0x7BD20 /* MTLCounterSetWrapper */ },
		{ 0x7C420 /* Metal.IMTLDepthStencilState */, 0x7C520 /* MTLDepthStencilStateWrapper */ },
		{ 0x7C620 /* Metal.IMTLDevice */, 0x7C720 /* MTLDeviceWrapper */ },
		{ 0x7CA20 /* Metal.IMTLDrawable */, 0x7CB20 /* MTLDrawableWrapper */ },
		{ 0x7CD20 /* Metal.IMTLEvent */, 0x7CE20 /* MTLEventWrapper */ },
		{ 0x7D020 /* Metal.IMTLFence */, 0x7D120 /* MTLFenceWrapper */ },
		{ 0x7D220 /* Metal.IMTLFunction */, 0x7D420 /* MTLFunctionWrapper */ },
		{ 0x7DA20 /* Metal.IMTLHeap */, 0x7DC20 /* MTLHeapWrapper */ },
		{ 0x7E020 /* Metal.IMTLIndirectCommandBuffer */, 0x7E120 /* MTLIndirectCommandBufferWrapper */ },
		{ 0x7E420 /* Metal.IMTLIndirectRenderCommand */, 0x7E520 /* MTLIndirectRenderCommandWrapper */ },
		{ 0x7E720 /* Metal.IMTLLibrary */, 0x7E920 /* MTLLibraryWrapper */ },
		{ 0x7F020 /* Metal.IMTLParallelRenderCommandEncoder */, 0x7F220 /* MTLParallelRenderCommandEncoderWrapper */ },
		{ 0x7FC20 /* Metal.IMTLRenderCommandEncoder */, 0x7FE20 /* MTLRenderCommandEncoderWrapper */ },
		{ 0x80820 /* Metal.IMTLRenderPipelineState */, 0x80A20 /* MTLRenderPipelineStateWrapper */ },
		{ 0x80C20 /* Metal.IMTLResource */, 0x80E20 /* MTLResourceWrapper */ },
		{ 0x81620 /* Metal.IMTLSamplerState */, 0x81720 /* MTLSamplerStateWrapper */ },
		{ 0x81820 /* Metal.IMTLSharedEvent */, 0x81920 /* MTLSharedEventWrapper */ },
		{ 0x82920 /* Metal.IMTLTexture */, 0x82B20 /* MTLTextureWrapper */ },
		{ 0x88A20 /* MapKit.IMKAnnotation */, 0x88C20 /* MKAnnotationWrapper */ },
		{ 0x8A020 /* MapKit.IMKGeoJsonObject */, 0x8A120 /* MKGeoJsonObjectWrapper */ },
		{ 0x8A320 /* MapKit.IMKLocalSearchCompleterDelegate */, 0x8A520 /* MKLocalSearchCompleterDelegateWrapper */ },
		{ 0x8BC20 /* MapKit.IMKMapViewDelegate */, 0x8BE20 /* MKMapViewDelegateWrapper */ },
		{ 0x8C420 /* MapKit.IMKOverlay */, 0x8C620 /* MKOverlayWrapper */ },
		{ 0x8EA20 /* JavaScriptCore.IJSExport */, 0x8EB20 /* JSExportWrapper */ },
		{ 0x91F20 /* Intents.IINCallsDomainHandling */, 0x92020 /* INCallsDomainHandlingWrapper */ },
		{ 0x93E20 /* Intents.IINSearchCallHistoryIntentHandling */, 0x94020 /* INSearchCallHistoryIntentHandlingWrapper */ },
		{ 0x94420 /* Intents.IINSearchForMessagesIntentHandling */, 0x94620 /* INSearchForMessagesIntentHandlingWrapper */ },
		{ 0x94A20 /* Intents.IINSendMessageIntentHandling */, 0x94C20 /* INSendMessageIntentHandlingWrapper */ },
		{ 0x95220 /* Intents.IINSpeakable */, 0x95420 /* INSpeakableWrapper */ },
		{ 0x95720 /* Intents.IINStartAudioCallIntentHandling */, 0x95920 /* INStartAudioCallIntentHandlingWrapper */ },
		{ 0x95D20 /* Intents.IINStartVideoCallIntentHandling */, 0x95F20 /* INStartVideoCallIntentHandlingWrapper */ },
		{ 0x99720 /* GLKit.IGLKNamedEffect */, 0x99820 /* GLKNamedEffectWrapper */ },
		{ 0x9B220 /* GameplayKit.IGKAgentDelegate */, 0x9B420 /* GKAgentDelegateWrapper */ },
		{ 0x9C020 /* GameplayKit.IGKGameModel */, 0x9C220 /* GKGameModelWrapper */ },
		{ 0x9C320 /* GameplayKit.IGKGameModelPlayer */, 0x9C520 /* GKGameModelPlayerWrapper */ },
		{ 0x9C620 /* GameplayKit.IGKGameModelUpdate */, 0x9C720 /* GKGameModelUpdateWrapper */ },
		{ 0x9DF20 /* GameplayKit.IGKRandom */, 0x9E020 /* GKRandomWrapper */ },
		{ 0x9E920 /* GameplayKit.IGKSceneRootNodeType */, 0x9EA20 /* GKSceneRootNodeTypeWrapper */ },
		{ 0x9F020 /* GameplayKit.IGKStrategist */, 0x9F120 /* GKStrategistWrapper */ },
		{ 0xA3D20 /* CoreWlan.ICWEventDelegate */, 0xA3F20 /* CWEventDelegateWrapper */ },
		{ 0xAD420 /* CoreSpotlight.ICSSearchableIndexDelegate */, 0xAD620 /* CSSearchableIndexDelegateWrapper */ },
		{ 0xB0320 /* CoreLocation.ICLLocationManagerDelegate */, 0xB0520 /* CLLocationManagerDelegateWrapper */ },
		{ 0xB2420 /* CoreImage.ICIAccordionFoldTransitionProtocol */, 0xB2520 /* CIAccordionFoldTransitionProtocolWrapper */ },
		{ 0xB2820 /* CoreImage.ICIAffineClampProtocol */, 0xB2920 /* CIAffineClampProtocolWrapper */ },
		{ 0xB2C20 /* CoreImage.ICIAffineTileProtocol */, 0xB2D20 /* CIAffineTileProtocolWrapper */ },
		{ 0xB3820 /* CoreImage.ICIAttributedTextImageGeneratorProtocol */, 0xB3920 /* CIAttributedTextImageGeneratorProtocolWrapper */ },
		{ 0xB3C20 /* CoreImage.ICIAztecCodeGeneratorProtocol */, 0xB3D20 /* CIAztecCodeGeneratorProtocolWrapper */ },
		{ 0xB4020 /* CoreImage.ICIBarcodeGeneratorProtocol */, 0xB4120 /* CIBarcodeGeneratorProtocolWrapper */ },
		{ 0xB4320 /* CoreImage.ICIBarsSwipeTransitionProtocol */, 0xB4420 /* CIBarsSwipeTransitionProtocolWrapper */ },
		{ 0xB4620 /* CoreImage.ICIBicubicScaleTransformProtocol */, 0xB4720 /* CIBicubicScaleTransformProtocolWrapper */ },
		{ 0xB4D20 /* CoreImage.ICIBlendWithMaskProtocol */, 0xB4E20 /* CIBlendWithMaskProtocolWrapper */ },
		{ 0xB5120 /* CoreImage.ICIBloomProtocol */, 0xB5220 /* CIBloomProtocolWrapper */ },
		{ 0xB5420 /* CoreImage.ICIBokehBlurProtocol */, 0xB5520 /* CIBokehBlurProtocolWrapper */ },
		{ 0xB5720 /* CoreImage.ICIBoxBlurProtocol */, 0xB5820 /* CIBoxBlurProtocolWrapper */ },
		{ 0xB5D20 /* CoreImage.ICICheckerboardGeneratorProtocol */, 0xB5E20 /* CICheckerboardGeneratorProtocolWrapper */ },
		{ 0xB6120 /* CoreImage.ICICircularScreenProtocol */, 0xB6220 /* CICircularScreenProtocolWrapper */ },
		{ 0xB6620 /* CoreImage.ICICmykHalftoneProtocol */, 0xB6720 /* CICmykHalftoneProtocolWrapper */ },
		{ 0xB6920 /* CoreImage.ICICode128BarcodeGeneratorProtocol */, 0xB6A20 /* CICode128BarcodeGeneratorProtocolWrapper */ },
		{ 0xB6F20 /* CoreImage.ICIColorClampProtocol */, 0xB7020 /* CIColorClampProtocolWrapper */ },
		{ 0xB7220 /* CoreImage.ICIColorControlsProtocol */, 0xB7320 /* CIColorControlsProtocolWrapper */ },
		{ 0xB7520 /* CoreImage.ICIColorCrossPolynomialProtocol */, 0xB7620 /* CIColorCrossPolynomialProtocolWrapper */ },
		{ 0xB7820 /* CoreImage.ICIColorCubeProtocol */, 0xB7920 /* CIColorCubeProtocolWrapper */ },
		{ 0xB7B20 /* CoreImage.ICIColorCubesMixedWithMaskProtocol */, 0xB7C20 /* CIColorCubesMixedWithMaskProtocolWrapper */ },
		{ 0xB7E20 /* CoreImage.ICIColorCubeWithColorSpaceProtocol */, 0xB7F20 /* CIColorCubeWithColorSpaceProtocolWrapper */ },
		{ 0xB8120 /* CoreImage.ICIColorCurvesProtocol */, 0xB8220 /* CIColorCurvesProtocolWrapper */ },
		{ 0xB8520 /* CoreImage.ICIColorInvertProtocol */, 0xB8620 /* CIColorInvertProtocolWrapper */ },
		{ 0xB8920 /* CoreImage.ICIColorMapProtocol */, 0xB8A20 /* CIColorMapProtocolWrapper */ },
		{ 0xB8C20 /* CoreImage.ICIColorMatrixProtocol */, 0xB8D20 /* CIColorMatrixProtocolWrapper */ },
		{ 0xB8F20 /* CoreImage.ICIColorMonochromeProtocol */, 0xB9020 /* CIColorMonochromeProtocolWrapper */ },
		{ 0xB9220 /* CoreImage.ICIColorPolynomialProtocol */, 0xB9320 /* CIColorPolynomialProtocolWrapper */ },
		{ 0xB9520 /* CoreImage.ICIColorPosterizeProtocol */, 0xB9620 /* CIColorPosterizeProtocolWrapper */ },
		{ 0xB9920 /* CoreImage.ICIComicEffectProtocol */, 0xB9A20 /* CIComicEffectProtocolWrapper */ },
		{ 0xB9B20 /* CoreImage.ICICompositeOperationProtocol */, 0xB9C20 /* CICompositeOperationProtocolWrapper */ },
		{ 0xBA820 /* CoreImage.ICIConvolutionProtocol */, 0xBA920 /* CIConvolutionProtocolWrapper */ },
		{ 0xBAB20 /* CoreImage.ICICopyMachineTransitionProtocol */, 0xBAC20 /* CICopyMachineTransitionProtocolWrapper */ },
		{ 0xBAE20 /* CoreImage.ICICoreMLModelProtocol */, 0xBAF20 /* CICoreMLModelProtocolWrapper */ },
		{ 0xBB220 /* CoreImage.ICICrystallizeProtocol */, 0xBB320 /* CICrystallizeProtocolWrapper */ },
		{ 0xBB920 /* CoreImage.ICIDepthOfFieldProtocol */, 0xBBA20 /* CIDepthOfFieldProtocolWrapper */ },
		{ 0xBBC20 /* CoreImage.ICIDepthToDisparityProtocol */, 0xBBD20 /* CIDepthToDisparityProtocolWrapper */ },
		{ 0xBC020 /* CoreImage.ICIDiscBlurProtocol */, 0xBC120 /* CIDiscBlurProtocolWrapper */ },
		{ 0xBC320 /* CoreImage.ICIDisintegrateWithMaskTransitionProtocol */, 0xBC420 /* CIDisintegrateWithMaskTransitionProtocolWrapper */ },
		{ 0xBC620 /* CoreImage.ICIDisparityToDepthProtocol */, 0xBC720 /* CIDisparityToDepthProtocolWrapper */ },
		{ 0xBCA20 /* CoreImage.ICIDissolveTransitionProtocol */, 0xBCB20 /* CIDissolveTransitionProtocolWrapper */ },
		{ 0xBCE20 /* CoreImage.ICIDitherProtocol */, 0xBCF20 /* CIDitherProtocolWrapper */ },
		{ 0xBD220 /* CoreImage.ICIDocumentEnhancerProtocol */, 0xBD320 /* CIDocumentEnhancerProtocolWrapper */ },
		{ 0xBD520 /* CoreImage.ICIDotScreenProtocol */, 0xBD620 /* CIDotScreenProtocolWrapper */ },
		{ 0xBD920 /* CoreImage.ICIEdgePreserveUpsampleProtocol */, 0xBDA20 /* CIEdgePreserveUpsampleProtocolWrapper */ },
		{ 0xBDC20 /* CoreImage.ICIEdgesProtocol */, 0xBDD20 /* CIEdgesProtocolWrapper */ },
		{ 0xBDF20 /* CoreImage.ICIEdgeWorkProtocol */, 0xBE020 /* CIEdgeWorkProtocolWrapper */ },
		{ 0xBE220 /* CoreImage.ICIEightfoldReflectedTileProtocol */, 0xBE320 /* CIEightfoldReflectedTileProtocolWrapper */ },
		{ 0xBE620 /* CoreImage.ICIExposureAdjustProtocol */, 0xBE720 /* CIExposureAdjustProtocolWrapper */ },
		{ 0xBEB20 /* CoreImage.ICIFalseColorProtocol */, 0xBEC20 /* CIFalseColorProtocolWrapper */ },
		{ 0xBF120 /* CoreImage.ICIFilterConstructor */, 0xBF220 /* CIFilterConstructorWrapper */ },
		{ 0xBF620 /* CoreImage.ICIFilterProtocol */, 0xBF720 /* CIFilterProtocolWrapper */ },
		{ 0xBFA20 /* CoreImage.ICIFlashTransitionProtocol */, 0xBFB20 /* CIFlashTransitionProtocolWrapper */ },
		{ 0xBFC20 /* CoreImage.ICIFourCoordinateGeometryFilterProtocol */, 0xBFD20 /* CIFourCoordinateGeometryFilterProtocolWrapper */ },
		{ 0xBFF20 /* CoreImage.ICIFourfoldReflectedTileProtocol */, 0xC0020 /* CIFourfoldReflectedTileProtocolWrapper */ },
		{ 0xC0220 /* CoreImage.ICIFourfoldRotatedTileProtocol */, 0xC0320 /* CIFourfoldRotatedTileProtocolWrapper */ },
		{ 0xC0520 /* CoreImage.ICIFourfoldTranslatedTileProtocol */, 0xC0620 /* CIFourfoldTranslatedTileProtocolWrapper */ },
		{ 0xC0820 /* CoreImage.ICIGaborGradientsProtocol */, 0xC0920 /* CIGaborGradientsProtocolWrapper */ },
		{ 0xC0B20 /* CoreImage.ICIGammaAdjustProtocol */, 0xC0C20 /* CIGammaAdjustProtocolWrapper */ },
		{ 0xC0E20 /* CoreImage.ICIGaussianBlurProtocol */, 0xC0F20 /* CIGaussianBlurProtocolWrapper */ },
		{ 0xC1120 /* CoreImage.ICIGaussianGradientProtocol */, 0xC1220 /* CIGaussianGradientProtocolWrapper */ },
		{ 0xC1620 /* CoreImage.ICIGlideReflectedTileProtocol */, 0xC1720 /* CIGlideReflectedTileProtocolWrapper */ },
		{ 0xC1920 /* CoreImage.ICIGloomProtocol */, 0xC1A20 /* CIGloomProtocolWrapper */ },
		{ 0xC1E20 /* CoreImage.ICIHatchedScreenProtocol */, 0xC1F20 /* CIHatchedScreenProtocolWrapper */ },
		{ 0xC2120 /* CoreImage.ICIHeightFieldFromMaskProtocol */, 0xC2220 /* CIHeightFieldFromMaskProtocolWrapper */ },
		{ 0xC2420 /* CoreImage.ICIHexagonalPixellateProtocol */, 0xC2520 /* CIHexagonalPixellateProtocolWrapper */ },
		{ 0xC2720 /* CoreImage.ICIHighlightShadowAdjustProtocol */, 0xC2820 /* CIHighlightShadowAdjustProtocolWrapper */ },
		{ 0xC2C20 /* CoreImage.ICIHueAdjustProtocol */, 0xC2D20 /* CIHueAdjustProtocolWrapper */ },
		{ 0xC3020 /* CoreImage.ICIHueSaturationValueGradientProtocol */, 0xC3120 /* CIHueSaturationValueGradientProtocolWrapper */ },
		{ 0xC3520 /* CoreImage.ICIImageProcessorInput */, 0xC3720 /* CIImageProcessorInputWrapper */ },
		{ 0xC3920 /* CoreImage.ICIImageProcessorOutput */, 0xC3B20 /* CIImageProcessorOutputWrapper */ },
		{ 0xC4320 /* CoreImage.ICIKaleidoscopeProtocol */, 0xC4420 /* CIKaleidoscopeProtocolWrapper */ },
		{ 0xC4820 /* CoreImage.ICIKeystoneCorrectionCombinedProtocol */, 0xC4920 /* CIKeystoneCorrectionCombinedProtocolWrapper */ },
		{ 0xC4B20 /* CoreImage.ICIKeystoneCorrectionHorizontalProtocol */, 0xC4C20 /* CIKeystoneCorrectionHorizontalProtocolWrapper */ },
		{ 0xC4E20 /* CoreImage.ICIKeystoneCorrectionVerticalProtocol */, 0xC4F20 /* CIKeystoneCorrectionVerticalProtocolWrapper */ },
		{ 0xC5220 /* CoreImage.ICILabDeltaEProtocol */, 0xC5320 /* CILabDeltaEProtocolWrapper */ },
		{ 0xC5520 /* CoreImage.ICILanczosScaleTransformProtocol */, 0xC5620 /* CILanczosScaleTransformProtocolWrapper */ },
		{ 0xC5820 /* CoreImage.ICILenticularHaloGeneratorProtocol */, 0xC5920 /* CILenticularHaloGeneratorProtocolWrapper */ },
		{ 0xC6020 /* CoreImage.ICILinearGradientProtocol */, 0xC6120 /* CILinearGradientProtocolWrapper */ },
		{ 0xC6320 /* CoreImage.ICILinearToSrgbToneCurveProtocol */, 0xC6420 /* CILinearToSrgbToneCurveProtocolWrapper */ },
		{ 0xC6620 /* CoreImage.ICILineOverlayProtocol */, 0xC6720 /* CILineOverlayProtocolWrapper */ },
		{ 0xC6920 /* CoreImage.ICILineScreenProtocol */, 0xC6A20 /* CILineScreenProtocolWrapper */ },
		{ 0xC6D20 /* CoreImage.ICIMaskedVariableBlurProtocol */, 0xC6E20 /* CIMaskedVariableBlurProtocolWrapper */ },
		{ 0xC7020 /* CoreImage.ICIMaskToAlphaProtocol */, 0xC7120 /* CIMaskToAlphaProtocolWrapper */ },
		{ 0xC7320 /* CoreImage.ICIMaximumComponentProtocol */, 0xC7420 /* CIMaximumComponentProtocolWrapper */ },
		{ 0xC7720 /* CoreImage.ICIMedianProtocol */, 0xC7820 /* CIMedianProtocolWrapper */ },
		{ 0xC7A20 /* CoreImage.ICIMeshGeneratorProtocol */, 0xC7B20 /* CIMeshGeneratorProtocolWrapper */ },
		{ 0xC7D20 /* CoreImage.ICIMinimumComponentProtocol */, 0xC7E20 /* CIMinimumComponentProtocolWrapper */ },
		{ 0xC8120 /* CoreImage.ICIMixProtocol */, 0xC8220 /* CIMixProtocolWrapper */ },
		{ 0xC8420 /* CoreImage.ICIModTransitionProtocol */, 0xC8520 /* CIModTransitionProtocolWrapper */ },
		{ 0xC8820 /* CoreImage.ICIMorphologyGradientProtocol */, 0xC8920 /* CIMorphologyGradientProtocolWrapper */ },
		{ 0xC8B20 /* CoreImage.ICIMorphologyMaximumProtocol */, 0xC8C20 /* CIMorphologyMaximumProtocolWrapper */ },
		{ 0xC8E20 /* CoreImage.ICIMorphologyMinimumProtocol */, 0xC8F20 /* CIMorphologyMinimumProtocolWrapper */ },
		{ 0xC9220 /* CoreImage.ICIMorphologyRectangleMaximumProtocol */, 0xC9320 /* CIMorphologyRectangleMaximumProtocolWrapper */ },
		{ 0xC9520 /* CoreImage.ICIMorphologyRectangleMinimumProtocol */, 0xC9620 /* CIMorphologyRectangleMinimumProtocolWrapper */ },
		{ 0xC9820 /* CoreImage.ICIMotionBlurProtocol */, 0xC9920 /* CIMotionBlurProtocolWrapper */ },
		{ 0xC9F20 /* CoreImage.ICINoiseReductionProtocol */, 0xCA020 /* CINoiseReductionProtocolWrapper */ },
		{ 0xCA220 /* CoreImage.ICIOpTileProtocol */, 0xCA320 /* CIOpTileProtocolWrapper */ },
		{ 0xCA620 /* CoreImage.ICIPageCurlTransitionProtocol */, 0xCA720 /* CIPageCurlTransitionProtocolWrapper */ },
		{ 0xCA920 /* CoreImage.ICIPageCurlWithShadowTransitionProtocol */, 0xCAA20 /* CIPageCurlWithShadowTransitionProtocolWrapper */ },
		{ 0xCAC20 /* CoreImage.ICIPaletteCentroidProtocol */, 0xCAD20 /* CIPaletteCentroidProtocolWrapper */ },
		{ 0xCAF20 /* CoreImage.ICIPalettizeProtocol */, 0xCB020 /* CIPalettizeProtocolWrapper */ },
		{ 0xCB220 /* CoreImage.ICIParallelogramTileProtocol */, 0xCB320 /* CIParallelogramTileProtocolWrapper */ },
		{ 0xCB520 /* CoreImage.ICIPdf417BarcodeGeneratorProtocol */, 0xCB620 /* CIPdf417BarcodeGeneratorProtocolWrapper */ },
		{ 0xCB920 /* CoreImage.ICIPerspectiveCorrectionProtocol */, 0xCBA20 /* CIPerspectiveCorrectionProtocolWrapper */ },
		{ 0xCBC20 /* CoreImage.ICIPerspectiveRotateProtocol */, 0xCBD20 /* CIPerspectiveRotateProtocolWrapper */ },
		{ 0xCBF20 /* CoreImage.ICIPerspectiveTileProtocol */, 0xCC020 /* CIPerspectiveTileProtocolWrapper */ },
		{ 0xCC220 /* CoreImage.ICIPerspectiveTransformProtocol */, 0xCC320 /* CIPerspectiveTransformProtocolWrapper */ },
		{ 0xCC520 /* CoreImage.ICIPerspectiveTransformWithExtentProtocol */, 0xCC620 /* CIPerspectiveTransformWithExtentProtocolWrapper */ },
		{ 0xCCE20 /* CoreImage.ICIPhotoEffectProtocol */, 0xCCF20 /* CIPhotoEffectProtocolWrapper */ },
		{ 0xCD520 /* CoreImage.ICIPixellateProtocol */, 0xCD620 /* CIPixellateProtocolWrapper */ },
		{ 0xCD920 /* CoreImage.ICIPointillizeProtocol */, 0xCDA20 /* CIPointillizeProtocolWrapper */ },
		{ 0xCDE20 /* CoreImage.ICIQRCodeGeneratorProtocol */, 0xCDF20 /* CIQRCodeGeneratorProtocolWrapper */ },
		{ 0xCE120 /* CoreImage.ICIRadialGradientProtocol */, 0xCE220 /* CIRadialGradientProtocolWrapper */ },
		{ 0xCE420 /* CoreImage.ICIRandomGeneratorProtocol */, 0xCE520 /* CIRandomGeneratorProtocolWrapper */ },
		{ 0xCEE20 /* CoreImage.ICIRippleTransitionProtocol */, 0xCEF20 /* CIRippleTransitionProtocolWrapper */ },
		{ 0xCF120 /* CoreImage.ICIRoundedRectangleGeneratorProtocol */, 0xCF220 /* CIRoundedRectangleGeneratorProtocolWrapper */ },
		{ 0xCF520 /* CoreImage.ICISaliencyMapProtocol */, 0xCF620 /* CISaliencyMapProtocolWrapper */ },
		{ 0xCFC20 /* CoreImage.ICISepiaToneProtocol */, 0xCFD20 /* CISepiaToneProtocolWrapper */ },
		{ 0xCFF20 /* CoreImage.ICIShadedMaterialProtocol */, 0xD0020 /* CIShadedMaterialProtocolWrapper */ },
		{ 0xD0220 /* CoreImage.ICISharpenLuminanceProtocol */, 0xD0320 /* CISharpenLuminanceProtocolWrapper */ },
		{ 0xD0520 /* CoreImage.ICISixfoldReflectedTileProtocol */, 0xD0620 /* CISixfoldReflectedTileProtocolWrapper */ },
		{ 0xD0820 /* CoreImage.ICISixfoldRotatedTileProtocol */, 0xD0920 /* CISixfoldRotatedTileProtocolWrapper */ },
		{ 0xD0B20 /* CoreImage.ICISmoothLinearGradientProtocol */, 0xD0C20 /* CISmoothLinearGradientProtocolWrapper */ },
		{ 0xD1320 /* CoreImage.ICISpotColorProtocol */, 0xD1420 /* CISpotColorProtocolWrapper */ },
		{ 0xD1620 /* CoreImage.ICISpotLightProtocol */, 0xD1720 /* CISpotLightProtocolWrapper */ },
		{ 0xD1920 /* CoreImage.ICISrgbToneCurveToLinearProtocol */, 0xD1A20 /* CISrgbToneCurveToLinearProtocolWrapper */ },
		{ 0xD1C20 /* CoreImage.ICIStarShineGeneratorProtocol */, 0xD1D20 /* CIStarShineGeneratorProtocolWrapper */ },
		{ 0xD1F20 /* CoreImage.ICIStraightenProtocol */, 0xD2020 /* CIStraightenProtocolWrapper */ },
		{ 0xD2320 /* CoreImage.ICIStripesGeneratorProtocol */, 0xD2420 /* CIStripesGeneratorProtocolWrapper */ },
		{ 0xD2720 /* CoreImage.ICISunbeamsGeneratorProtocol */, 0xD2820 /* CISunbeamsGeneratorProtocolWrapper */ },
		{ 0xD2A20 /* CoreImage.ICISwipeTransitionProtocol */, 0xD2B20 /* CISwipeTransitionProtocolWrapper */ },
		{ 0xD2D20 /* CoreImage.ICITemperatureAndTintProtocol */, 0xD2E20 /* CITemperatureAndTintProtocolWrapper */ },
		{ 0xD3120 /* CoreImage.ICITextImageGeneratorProtocol */, 0xD3220 /* CITextImageGeneratorProtocolWrapper */ },
		{ 0xD3420 /* CoreImage.ICIThermalProtocol */, 0xD3520 /* CIThermalProtocolWrapper */ },
		{ 0xD3820 /* CoreImage.ICIToneCurveProtocol */, 0xD3920 /* CIToneCurveProtocolWrapper */ },
		{ 0xD3C20 /* CoreImage.ICITransitionFilterProtocol */, 0xD3D20 /* CITransitionFilterProtocolWrapper */ },
		{ 0xD3F20 /* CoreImage.ICITriangleKaleidoscopeProtocol */, 0xD4020 /* CITriangleKaleidoscopeProtocolWrapper */ },
		{ 0xD4220 /* CoreImage.ICITriangleTileProtocol */, 0xD4320 /* CITriangleTileProtocolWrapper */ },
		{ 0xD4520 /* CoreImage.ICITwelvefoldReflectedTileProtocol */, 0xD4620 /* CITwelvefoldReflectedTileProtocolWrapper */ },
		{ 0xD4A20 /* CoreImage.ICIUnsharpMaskProtocol */, 0xD4B20 /* CIUnsharpMaskProtocolWrapper */ },
		{ 0xD4D20 /* CoreImage.ICIVibranceProtocol */, 0xD4E20 /* CIVibranceProtocolWrapper */ },
		{ 0xD5120 /* CoreImage.ICIVignetteEffectProtocol */, 0xD5220 /* CIVignetteEffectProtocolWrapper */ },
		{ 0xD5320 /* CoreImage.ICIVignetteProtocol */, 0xD5420 /* CIVignetteProtocolWrapper */ },
		{ 0xD5820 /* CoreImage.ICIWhitePointAdjustProtocol */, 0xD5920 /* CIWhitePointAdjustProtocolWrapper */ },
		{ 0xD5B20 /* CoreImage.ICIXRayProtocol */, 0xD5C20 /* CIXRayProtocolWrapper */ },
		{ 0xD5E20 /* CoreImage.ICIZoomBlurProtocol */, 0xD5F20 /* CIZoomBlurProtocolWrapper */ },
		{ 0xDD420 /* CoreAnimation.ICAAction */, 0xDD520 /* CAActionWrapper */ },
		{ 0xDD720 /* CoreAnimation.ICAAnimationDelegate */, 0xDD920 /* CAAnimationDelegateWrapper */ },
		{ 0xDE820 /* CoreAnimation.ICALayerDelegate */, 0xDEA20 /* CALayerDelegateWrapper */ },
		{ 0xDEB20 /* CoreAnimation.ICAMediaTiming */, 0xDEC20 /* CAMediaTimingWrapper */ },
		{ 0xDEE20 /* CoreAnimation.ICAMetalDrawable */, 0xDEF20 /* CAMetalDrawableWrapper */ },
		{ 0xE1820 /* Contacts.ICNChangeHistoryEventVisitor */, 0xE1A20 /* CNChangeHistoryEventVisitorWrapper */ },
		{ 0xE3820 /* Contacts.ICNKeyDescriptor */, 0xE3920 /* CNKeyDescriptorWrapper */ },
		{ 0xE8720 /* CloudKit.ICKRecordValue */, 0xE8820 /* CKRecordValueWrapper */ },
		{ 0xF1920 /* AudioUnit.IAUAudioUnitFactory */, 0xF1A20 /* AUAudioUnitFactoryWrapper */ },
		{ 0xFD920 /* SpriteKit.ISKPhysicsContactDelegate */, 0xFDB20 /* SKPhysicsContactDelegateWrapper */ },
		{ 0xFEB20 /* SpriteKit.ISKSceneDelegate */, 0xFED20 /* SKSceneDelegateWrapper */ },
		{ 0x100320 /* SpriteKit.ISKViewDelegate */, 0x100520 /* SKViewDelegateWrapper */ },
		{ 0x100720 /* SpriteKit.ISKWarpable */, 0x100820 /* SKWarpableWrapper */ },
		{ 0x103120 /* SceneKit.ISCNActionable */, 0x103320 /* SCNActionableWrapper */ },
		{ 0x103620 /* SceneKit.ISCNAnimatable */, 0x103820 /* SCNAnimatableWrapper */ },
		{ 0x103C20 /* SceneKit.ISCNAnimationProtocol */, 0x103D20 /* SCNAnimationProtocolWrapper */ },
		{ 0x104220 /* SceneKit.ISCNAvoidOccluderConstraintDelegate */, 0x104420 /* SCNAvoidOccluderConstraintDelegateWrapper */ },
		{ 0x104920 /* SceneKit.ISCNBoundingVolume */, 0x104A20 /* SCNBoundingVolumeWrapper */ },
		{ 0x104E20 /* SceneKit.ISCNBufferStream */, 0x104F20 /* SCNBufferStreamWrapper */ },
		{ 0x105120 /* SceneKit.ISCNCameraControlConfiguration */, 0x105220 /* SCNCameraControlConfigurationWrapper */ },
		{ 0x105420 /* SceneKit.ISCNCameraControllerDelegate */, 0x105620 /* SCNCameraControllerDelegateWrapper */ },
		{ 0x108120 /* SceneKit.ISCNNodeRendererDelegate */, 0x108320 /* SCNNodeRendererDelegateWrapper */ },
		{ 0x109720 /* SceneKit.ISCNPhysicsContactDelegate */, 0x109920 /* SCNPhysicsContactDelegateWrapper */ },
		{ 0x10AA20 /* SceneKit.ISCNProgramDelegate */, 0x10AC20 /* SCNProgramDelegateWrapper */ },
		{ 0x10B720 /* SceneKit.ISCNSceneExportDelegate */, 0x10B920 /* SCNSceneExportDelegateWrapper */ },
		{ 0x10BB20 /* SceneKit.ISCNSceneRenderer */, 0x10BC20 /* SCNSceneRendererWrapper */ },
		{ 0x10BD20 /* SceneKit.ISCNSceneRendererDelegate */, 0x10BF20 /* SCNSceneRendererDelegateWrapper */ },
		{ 0x10C520 /* SceneKit.ISCNShadable */, 0x10C720 /* SCNShadableWrapper */ },
		{ 0x10CE20 /* SceneKit.ISCNTechniqueSupport */, 0x10CF20 /* SCNTechniqueSupportWrapper */ },
		{ 0x113C20 /* GameKit.IGKAchievementViewControllerDelegate */, 0x113D20 /* GKAchievementViewControllerDelegateWrapper */ },
		{ 0x114220 /* GameKit.IGKChallengeEventHandlerDelegate */, 0x114420 /* GKChallengeEventHandlerDelegateWrapper */ },
		{ 0x114620 /* GameKit.IGKChallengeListener */, 0x114820 /* GKChallengeListenerWrapper */ },
		{ 0x114C20 /* GameKit.IGKChallengesViewControllerDelegate */, 0x114D20 /* GKChallengesViewControllerDelegateWrapper */ },
		{ 0x115520 /* GameKit.IGKFriendRequestComposeViewControllerDelegate */, 0x115620 /* GKFriendRequestComposeViewControllerDelegateWrapper */ },
		{ 0x115820 /* GameKit.IGKGameCenterControllerDelegate */, 0x115920 /* GKGameCenterControllerDelegateWrapper */ },
		{ 0x115F20 /* GameKit.IGKGameSessionEventListener */, 0x116120 /* GKGameSessionEventListenerWrapper */ },
		{ 0x116420 /* GameKit.IGKInviteEventListener */, 0x116620 /* GKInviteEventListenerWrapper */ },
		{ 0x116F20 /* GameKit.IGKLeaderboardViewControllerDelegate */, 0x117020 /* GKLeaderboardViewControllerDelegateWrapper */ },
		{ 0x117420 /* GameKit.IGKLocalPlayerListener */, 0x117520 /* GKLocalPlayerListenerWrapper */ },
		{ 0x117E20 /* GameKit.IGKMatchDelegate */, 0x118020 /* GKMatchDelegateWrapper */ },
		{ 0x118820 /* GameKit.IGKMatchmakerViewControllerDelegate */, 0x118A20 /* GKMatchmakerViewControllerDelegateWrapper */ },
		{ 0x119420 /* GameKit.IGKSavedGameListener */, 0x119620 /* GKSavedGameListenerWrapper */ },
		{ 0x119C20 /* GameKit.IGKSessionDelegate */, 0x119E20 /* GKSessionDelegateWrapper */ },
		{ 0x11A320 /* GameKit.IGKTurnBasedEventHandlerDelegate */, 0x11A520 /* GKTurnBasedEventHandlerDelegateWrapper */ },
		{ 0x11A720 /* GameKit.IGKTurnBasedEventListener */, 0x11A920 /* GKTurnBasedEventListenerWrapper */ },
		{ 0x11AE20 /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */, 0x11AF20 /* GKTurnBasedMatchmakerViewControllerDelegateWrapper */ },
		{ 0x11B520 /* GameKit.IGKViewController */, 0x11B620 /* GKViewControllerWrapper */ },
		{ 0x120420 /* WebKit.IDomEventListener */, 0x120520 /* DomEventListenerWrapper */ },
		{ 0x120720 /* WebKit.IDomEventTarget */, 0x120820 /* DomEventTargetWrapper */ },
		{ 0x124420 /* WebKit.IDomNodeFilter */, 0x124520 /* DomNodeFilterWrapper */ },
		{ 0x126920 /* WebKit.IWebDocumentRepresentation */, 0x126A20 /* WebDocumentRepresentationWrapper */ },
		{ 0x126D20 /* WebKit.IWebDownloadDelegate */, 0x126F20 /* WebDownloadDelegateWrapper */ },
		{ 0x127120 /* WebKit.IWebFrameLoadDelegate */, 0x127320 /* WebFrameLoadDelegateWrapper */ },
		{ 0x127820 /* WebKit.IWebOpenPanelResultListener */, 0x127A20 /* WebOpenPanelResultListenerWrapper */ },
		{ 0x127C20 /* WebKit.IWebPolicyDecisionListener */, 0x127E20 /* WebPolicyDecisionListenerWrapper */ },
		{ 0x128020 /* WebKit.IWebPolicyDelegate */, 0x128220 /* WebPolicyDelegateWrapper */ },
		{ 0x128520 /* WebKit.IWebResourceLoadDelegate */, 0x128720 /* WebResourceLoadDelegateWrapper */ },
		{ 0x128A20 /* WebKit.IWebUIDelegate */, 0x128C20 /* WebUIDelegateWrapper */ },
		{ 0x12BA20 /* WebKit.IWKHttpCookieStoreObserver */, 0x12BC20 /* WKHttpCookieStoreObserverWrapper */ },
		{ 0x12C020 /* WebKit.IWKNavigationDelegate */, 0x12C220 /* WKNavigationDelegateWrapper */ },
		{ 0x12CB20 /* WebKit.IWKScriptMessageHandler */, 0x12CC20 /* WKScriptMessageHandlerWrapper */ },
		{ 0x12D120 /* WebKit.IWKUIDelegate */, 0x12D320 /* WKUIDelegateWrapper */ },
		{ 0x12D520 /* WebKit.IWKUrlSchemeHandler */, 0x12D620 /* WKUrlSchemeHandlerWrapper */ },
		{ 0x12D720 /* WebKit.IWKUrlSchemeTask */, 0x12D820 /* WKUrlSchemeTaskWrapper */ },
		{ 0x146220 /* AppKit.INSAccessibility */, 0x146420 /* NSAccessibilityWrapper */ },
		{ 0x146820 /* AppKit.INSAccessibilityButton */, 0x146920 /* NSAccessibilityButtonWrapper */ },
		{ 0x146A20 /* AppKit.INSAccessibilityCheckBox */, 0x146B20 /* NSAccessibilityCheckBoxWrapper */ },
		{ 0x146C20 /* AppKit.INSAccessibilityContainsTransientUI */, 0x146D20 /* NSAccessibilityContainsTransientUIWrapper */ },
		{ 0x147120 /* AppKit.INSAccessibilityCustomRotorItemSearchDelegate */, 0x147220 /* NSAccessibilityCustomRotorItemSearchDelegateWrapper */ },
		{ 0x147620 /* AppKit.INSAccessibilityElementLoading */, 0x147820 /* NSAccessibilityElementLoadingWrapper */ },
		{ 0x147920 /* AppKit.INSAccessibilityElementProtocol */, 0x147B20 /* NSAccessibilityElementProtocolWrapper */ },
		{ 0x147D20 /* AppKit.INSAccessibilityGroup */, 0x147E20 /* NSAccessibilityGroupWrapper */ },
		{ 0x147F20 /* AppKit.INSAccessibilityImage */, 0x148020 /* NSAccessibilityImageWrapper */ },
		{ 0x148120 /* AppKit.INSAccessibilityLayoutArea */, 0x148220 /* NSAccessibilityLayoutAreaWrapper */ },
		{ 0x148320 /* AppKit.INSAccessibilityLayoutItem */, 0x148520 /* NSAccessibilityLayoutItemWrapper */ },
		{ 0x148620 /* AppKit.INSAccessibilityList */, 0x148720 /* NSAccessibilityListWrapper */ },
		{ 0x148820 /* AppKit.INSAccessibilityNavigableStaticText */, 0x148920 /* NSAccessibilityNavigableStaticTextWrapper */ },
		{ 0x148C20 /* AppKit.INSAccessibilityOutline */, 0x148D20 /* NSAccessibilityOutlineWrapper */ },
		{ 0x148E20 /* AppKit.INSAccessibilityProgressIndicator */, 0x148F20 /* NSAccessibilityProgressIndicatorWrapper */ },
		{ 0x149020 /* AppKit.INSAccessibilityRadioButton */, 0x149120 /* NSAccessibilityRadioButtonWrapper */ },
		{ 0x149320 /* AppKit.INSAccessibilityRow */, 0x149520 /* NSAccessibilityRowWrapper */ },
		{ 0x149620 /* AppKit.INSAccessibilitySlider */, 0x149720 /* NSAccessibilitySliderWrapper */ },
		{ 0x149820 /* AppKit.INSAccessibilityStaticText */, 0x149A20 /* NSAccessibilityStaticTextWrapper */ },
		{ 0x149B20 /* AppKit.INSAccessibilityStepper */, 0x149D20 /* NSAccessibilityStepperWrapper */ },
		{ 0x149F20 /* AppKit.INSAccessibilitySwitch */, 0x14A120 /* NSAccessibilitySwitchWrapper */ },
		{ 0x14A220 /* AppKit.INSAccessibilityTable */, 0x14A420 /* NSAccessibilityTableWrapper */ },
		{ 0x14A520 /* AppKit.INSAlertDelegate */, 0x14A720 /* NSAlertDelegateWrapper */ },
		{ 0x14AA20 /* AppKit.INSAlignmentFeedbackToken */, 0x14AB20 /* NSAlignmentFeedbackTokenWrapper */ },
		{ 0x14B020 /* AppKit.INSAnimationDelegate */, 0x14B220 /* NSAnimationDelegateWrapper */ },
		{ 0x14B520 /* AppKit.INSAppearanceCustomization */, 0x14B720 /* NSAppearanceCustomizationWrapper */ },
		{ 0x14C320 /* AppKit.INSApplicationDelegate */, 0x14C520 /* NSApplicationDelegateWrapper */ },
		{ 0x14CA20 /* AppKit.INSBrowserDelegate */, 0x14CC20 /* NSBrowserDelegateWrapper */ },
		{ 0x14D220 /* AppKit.INSCandidateListTouchBarItemDelegate */, 0x14D420 /* NSCandidateListTouchBarItemDelegateWrapper */ },
		{ 0x14D820 /* AppKit.INSCloudSharingServiceDelegate */, 0x14DA20 /* NSCloudSharingServiceDelegateWrapper */ },
		{ 0x14DC20 /* AppKit.INSCloudSharingValidation */, 0x14DD20 /* NSCloudSharingValidationWrapper */ },
		{ 0x14E120 /* AppKit.INSCollectionLayoutContainer */, 0x14E220 /* NSCollectionLayoutContainerWrapper */ },
		{ 0x14E620 /* AppKit.INSCollectionLayoutEnvironment */, 0x14E720 /* NSCollectionLayoutEnvironmentWrapper */ },
		{ 0x14F020 /* AppKit.INSCollectionLayoutVisibleItem */, 0x14F120 /* NSCollectionLayoutVisibleItemWrapper */ },
		{ 0x14F420 /* AppKit.INSCollectionViewDataSource */, 0x14F620 /* NSCollectionViewDataSourceWrapper */ },
		{ 0x14F820 /* AppKit.INSCollectionViewDelegate */, 0x14F920 /* NSCollectionViewDelegateWrapper */ },
		{ 0x14FA20 /* AppKit.INSCollectionViewDelegateFlowLayout */, 0x14FC20 /* NSCollectionViewDelegateFlowLayoutWrapper */ },
		{ 0x14FE20 /* AppKit.INSCollectionViewElement */, 0x150020 /* NSCollectionViewElementWrapper */ },
		{ 0x150820 /* AppKit.INSCollectionViewPrefetching */, 0x150A20 /* NSCollectionViewPrefetchingWrapper */ },
		{ 0x150B20 /* AppKit.INSCollectionViewSectionHeaderView */, 0x150D20 /* NSCollectionViewSectionHeaderViewWrapper */ },
		{ 0x151020 /* AppKit.INSColorChanging */, 0x151120 /* NSColorChangingWrapper */ },
		{ 0x151820 /* AppKit.INSComboBoxCellDataSource */, 0x151A20 /* NSComboBoxCellDataSourceWrapper */ },
		{ 0x151C20 /* AppKit.INSComboBoxDataSource */, 0x151E20 /* NSComboBoxDataSourceWrapper */ },
		{ 0x152020 /* AppKit.INSComboBoxDelegate */, 0x152220 /* NSComboBoxDelegateWrapper */ },
		{ 0x152620 /* AppKit.INSControlTextEditingDelegate */, 0x152820 /* NSControlTextEditingDelegateWrapper */ },
		{ 0x153120 /* AppKit.INSDatePickerCellDelegate */, 0x153320 /* NSDatePickerCellDelegateWrapper */ },
		{ 0x153A20 /* AppKit.INSDockTilePlugIn */, 0x153B20 /* NSDockTilePlugInWrapper */ },
		{ 0x153E20 /* AppKit.INSDraggingDestination */, 0x154020 /* NSDraggingDestinationWrapper */ },
		{ 0x154320 /* AppKit.INSDraggingInfo */, 0x154520 /* NSDraggingInfoWrapper */ },
		{ 0x154620 /* AppKit.INSDraggingSource */, 0x154820 /* NSDraggingSourceWrapper */ },
		{ 0x154B20 /* AppKit.INSDrawerDelegate */, 0x154D20 /* NSDrawerDelegateWrapper */ },
		{ 0x154F20 /* AppKit.INSEditor */, 0x155020 /* NSEditorWrapper */ },
		{ 0x155120 /* AppKit.INSEditorRegistration */, 0x155320 /* NSEditorRegistrationWrapper */ },
		{ 0x155820 /* AppKit.INSFilePromiseProviderDelegate */, 0x155A20 /* NSFilePromiseProviderDelegateWrapper */ },
		{ 0x155E20 /* AppKit.INSFontChanging */, 0x156020 /* NSFontChangingWrapper */ },
		{ 0x156B20 /* AppKit.INSGestureRecognizerDelegate */, 0x156D20 /* NSGestureRecognizerDelegateWrapper */ },
		{ 0x157720 /* AppKit.INSHapticFeedbackPerformer */, 0x157820 /* NSHapticFeedbackPerformerWrapper */ },
		{ 0x157F20 /* AppKit.INSImageDelegate */, 0x158120 /* NSImageDelegateWrapper */ },
		{ 0x158E20 /* AppKit.INSLayoutManagerDelegate */, 0x159020 /* NSLayoutManagerDelegateWrapper */ },
		{ 0x159520 /* AppKit.INSMatrixDelegate */, 0x159620 /* NSMatrixDelegateWrapper */ },
		{ 0x159920 /* AppKit.INSMenuDelegate */, 0x159B20 /* NSMenuDelegateWrapper */ },
		{ 0x159E20 /* AppKit.INSMenuItemValidation */, 0x159F20 /* NSMenuItemValidationWrapper */ },
		{ 0x15AE20 /* AppKit.INSOpenSavePanelDelegate */, 0x15B020 /* NSOpenSavePanelDelegateWrapper */ },
		{ 0x15B320 /* AppKit.INSOutlineViewDataSource */, 0x15B520 /* NSOutlineViewDataSourceWrapper */ },
		{ 0x15B720 /* AppKit.INSOutlineViewDelegate */, 0x15B920 /* NSOutlineViewDelegateWrapper */ },
		{ 0x15BE20 /* AppKit.INSPageControllerDelegate */, 0x15C020 /* NSPageControllerDelegateWrapper */ },
		{ 0x15C520 /* AppKit.INSPasteboardItemDataProvider */, 0x15C620 /* NSPasteboardItemDataProviderWrapper */ },
		{ 0x15C820 /* AppKit.INSPasteboardReading */, 0x15C920 /* NSPasteboardReadingWrapper */ },
		{ 0x15CB20 /* AppKit.INSPasteboardTypeOwner */, 0x15CD20 /* NSPasteboardTypeOwnerWrapper */ },
		{ 0x15CE20 /* AppKit.INSPasteboardWriting */, 0x15D020 /* NSPasteboardWritingWrapper */ },
		{ 0x15D420 /* AppKit.INSPathCellDelegate */, 0x15D620 /* NSPathCellDelegateWrapper */ },
		{ 0x15D920 /* AppKit.INSPathControlDelegate */, 0x15DB20 /* NSPathControlDelegateWrapper */ },
		{ 0x15E220 /* AppKit.INSPopoverDelegate */, 0x15E420 /* NSPopoverDelegateWrapper */ },
		{ 0x15EC20 /* AppKit.INSPrintPanelAccessorizing */, 0x15ED20 /* NSPrintPanelAccessorizingWrapper */ },
		{ 0x15F720 /* AppKit.INSRuleEditorDelegate */, 0x15F920 /* NSRuleEditorDelegateWrapper */ },
		{ 0x160920 /* AppKit.INSScrubberDataSource */, 0x160A20 /* NSScrubberDataSourceWrapper */ },
		{ 0x160C20 /* AppKit.INSScrubberDelegate */, 0x160E20 /* NSScrubberDelegateWrapper */ },
		{ 0x161120 /* AppKit.INSScrubberFlowLayoutDelegate */, 0x161320 /* NSScrubberFlowLayoutDelegateWrapper */ },
		{ 0x161F20 /* AppKit.INSSearchFieldDelegate */, 0x162120 /* NSSearchFieldDelegateWrapper */ },
		{ 0x162720 /* AppKit.INSSeguePerforming */, 0x162920 /* NSSeguePerformingWrapper */ },
		{ 0x162B20 /* AppKit.INSServicesMenuRequestor */, 0x162D20 /* NSServicesMenuRequestorWrapper */ },
		{ 0x163120 /* AppKit.INSSharingServiceDelegate */, 0x163320 /* NSSharingServiceDelegateWrapper */ },
		{ 0x163820 /* AppKit.INSSharingServicePickerDelegate */, 0x163A20 /* NSSharingServicePickerDelegateWrapper */ },
		{ 0x163D20 /* AppKit.INSSharingServicePickerToolbarItemDelegate */, 0x163E20 /* NSSharingServicePickerToolbarItemDelegateWrapper */ },
		{ 0x164120 /* AppKit.INSSharingServicePickerTouchBarItemDelegate */, 0x164220 /* NSSharingServicePickerTouchBarItemDelegateWrapper */ },
		{ 0x164820 /* AppKit.INSSoundDelegate */, 0x164A20 /* NSSoundDelegateWrapper */ },
		{ 0x164D20 /* AppKit.INSSpeechRecognizerDelegate */, 0x164F20 /* NSSpeechRecognizerDelegateWrapper */ },
		{ 0x165120 /* AppKit.INSSpeechSynthesizerDelegate */, 0x165320 /* NSSpeechSynthesizerDelegateWrapper */ },
		{ 0x165820 /* AppKit.INSSplitViewDelegate */, 0x165A20 /* NSSplitViewDelegateWrapper */ },
		{ 0x165D20 /* AppKit.INSSpringLoadingDestination */, 0x165F20 /* NSSpringLoadingDestinationWrapper */ },
		{ 0x166220 /* AppKit.INSStackViewDelegate */, 0x166420 /* NSStackViewDelegateWrapper */ },
		{ 0x166720 /* AppKit.INSStandardKeyBindingResponding */, 0x166920 /* NSStandardKeyBindingRespondingWrapper */ },
		{ 0x167D20 /* AppKit.INSTableViewDataSource */, 0x167F20 /* NSTableViewDataSourceWrapper */ },
		{ 0x168120 /* AppKit.INSTableViewDelegate */, 0x168320 /* NSTableViewDelegateWrapper */ },
		{ 0x168A20 /* AppKit.INSTabViewDelegate */, 0x168C20 /* NSTabViewDelegateWrapper */ },
		{ 0x169320 /* AppKit.INSTextAttachmentContainer */, 0x169420 /* NSTextAttachmentContainerWrapper */ },
		{ 0x169720 /* AppKit.INSTextCheckingClient */, 0x169820 /* NSTextCheckingClientWrapper */ },
		{ 0x169C20 /* AppKit.INSTextDelegate */, 0x169E20 /* NSTextDelegateWrapper */ },
		{ 0x16A320 /* AppKit.INSTextFieldDelegate */, 0x16A520 /* NSTextFieldDelegateWrapper */ },
		{ 0x16A820 /* AppKit.INSTextFinderBarContainer */, 0x16AA20 /* NSTextFinderBarContainerWrapper */ },
		{ 0x16AC20 /* AppKit.INSTextFinderClient */, 0x16AD20 /* NSTextFinderClientWrapper */ },
		{ 0x16B020 /* AppKit.INSTextInput */, 0x16B120 /* NSTextInputWrapper */ },
		{ 0x16B220 /* AppKit.INSTextInputClient */, 0x16B420 /* NSTextInputClientWrapper */ },
		{ 0x16B720 /* AppKit.INSTextInputTraits */, 0x16B920 /* NSTextInputTraitsWrapper */ },
		{ 0x16C020 /* AppKit.INSTextStorageDelegate */, 0x16C220 /* NSTextStorageDelegateWrapper */ },
		{ 0x16CB20 /* AppKit.INSTextViewDelegate */, 0x16CD20 /* NSTextViewDelegateWrapper */ },
		{ 0x16D220 /* AppKit.INSTokenFieldCellDelegate */, 0x16D420 /* NSTokenFieldCellDelegateWrapper */ },
		{ 0x16D620 /* AppKit.INSTokenFieldDelegate */, 0x16D820 /* NSTokenFieldDelegateWrapper */ },
		{ 0x16DB20 /* AppKit.INSToolbarDelegate */, 0x16DD20 /* NSToolbarDelegateWrapper */ },
		{ 0x16E220 /* AppKit.INSToolbarItemValidation */, 0x16E320 /* NSToolbarItemValidationWrapper */ },
		{ 0x16E820 /* AppKit.INSTouchBarDelegate */, 0x16EA20 /* NSTouchBarDelegateWrapper */ },
		{ 0x16EF20 /* AppKit.INSTouchBarProvider */, 0x16F020 /* NSTouchBarProviderWrapper */ },
		{ 0x16F520 /* AppKit.INSUserInterfaceCompression */, 0x16F620 /* NSUserInterfaceCompressionWrapper */ },
		{ 0x16F820 /* AppKit.INSUserInterfaceItemIdentification */, 0x16FA20 /* NSUserInterfaceItemIdentificationWrapper */ },
		{ 0x16FB20 /* AppKit.INSUserInterfaceValidations */, 0x16FC20 /* NSUserInterfaceValidationsWrapper */ },
		{ 0x16FD20 /* AppKit.INSValidatedUserInterfaceItem */, 0x16FE20 /* NSValidatedUserInterfaceItemWrapper */ },
		{ 0x170320 /* AppKit.INSViewControllerPresentationAnimator */, 0x170420 /* NSViewControllerPresentationAnimatorWrapper */ },
		{ 0x170620 /* AppKit.INSViewToolTipOwner */, 0x170720 /* NSViewToolTipOwnerWrapper */ },
		{ 0x170C20 /* AppKit.INSWindowDelegate */, 0x170E20 /* NSWindowDelegateWrapper */ },
		{ 0x171020 /* AppKit.INSWindowRestoration */, 0x171120 /* NSWindowRestorationWrapper */ },
		{ 0x17D620 /* CoreML.IMLBatchProvider */, 0x17D720 /* MLBatchProviderWrapper */ },
		{ 0x17D920 /* CoreML.IMLCustomLayer */, 0x17DB20 /* MLCustomLayerWrapper */ },
		{ 0x17DC20 /* CoreML.IMLCustomModel */, 0x17DE20 /* MLCustomModelWrapper */ },
		{ 0x17E220 /* CoreML.IMLFeatureProvider */, 0x17E320 /* MLFeatureProviderWrapper */ },
		{ 0x180420 /* CoreML.IMLWritable */, 0x180520 /* MLWritableWrapper */ },
		{ 0x18A820 /* CoreData.INSFetchRequestResult */, 0x18A920 /* NSFetchRequestResultWrapper */ },
		{ 0x18EB20 /* CoreBluetooth.ICBCentralManagerDelegate */, 0x18ED20 /* CBCentralManagerDelegateWrapper */ },
		{ 0x190520 /* CoreBluetooth.ICBPeripheralDelegate */, 0x190720 /* CBPeripheralDelegateWrapper */ },
		{ 0x191120 /* CoreBluetooth.ICBPeripheralManagerDelegate */, 0x191320 /* CBPeripheralManagerDelegateWrapper */ },
		{ 0x191C20 /* AVKit.IAVCaptureViewDelegate */, 0x191D20 /* AVCaptureViewDelegateWrapper */ },
		{ 0x192220 /* AVKit.IAVPictureInPictureControllerDelegate */, 0x192420 /* AVPictureInPictureControllerDelegateWrapper */ },
		{ 0x192820 /* AVKit.IAVPlayerViewPictureInPictureDelegate */, 0x192A20 /* AVPlayerViewPictureInPictureDelegateWrapper */ },
		{ 0x192F20 /* AVKit.IAVRoutePickerViewDelegate */, 0x193120 /* AVRoutePickerViewDelegateWrapper */ },
		{ 0x198B20 /* AVFoundation.IAVAssetResourceLoaderDelegate */, 0x198D20 /* AVAssetResourceLoaderDelegateWrapper */ },
		{ 0x19A020 /* AVFoundation.IAVAsynchronousKeyValueLoading */, 0x19A120 /* AVAsynchronousKeyValueLoadingWrapper */ },
		{ 0x19A420 /* AVFoundation.IAVAudio3DMixing */, 0x19A620 /* AVAudio3DMixingWrapper */ },
		{ 0x19C020 /* AVFoundation.IAVAudioMixing */, 0x19C220 /* AVAudioMixingWrapper */ },
		{ 0x19C820 /* AVFoundation.IAVAudioPlayerDelegate */, 0x19CA20 /* AVAudioPlayerDelegateWrapper */ },
		{ 0x19D020 /* AVFoundation.IAVAudioRecorderDelegate */, 0x19D220 /* AVAudioRecorderDelegateWrapper */ },
		{ 0x19E720 /* AVFoundation.IAVAudioStereoMixing */, 0x19E820 /* AVAudioStereoMixingWrapper */ },
		{ 0x1A0420 /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */, 0x1A0520 /* AVCaptureAudioDataOutputSampleBufferDelegateWrapper */ },
		{ 0x1A1420 /* AVFoundation.IAVCaptureFileOutputDelegate */, 0x1A1620 /* AVCaptureFileOutputDelegateWrapper */ },
		{ 0x1A1820 /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */, 0x1A1A20 /* AVCaptureFileOutputRecordingDelegateWrapper */ },
		{ 0x1A2420 /* AVFoundation.IAVCapturePhotoCaptureDelegate */, 0x1A2620 /* AVCapturePhotoCaptureDelegateWrapper */ },
		{ 0x1A3320 /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */, 0x1A3520 /* AVCaptureVideoDataOutputSampleBufferDelegateWrapper */ },
		{ 0x1A4620 /* AVFoundation.IAVContentKeyRecipient */, 0x1A4720 /* AVContentKeyRecipientWrapper */ },
		{ 0x1A4E20 /* AVFoundation.IAVContentKeySessionDelegate */, 0x1A5020 /* AVContentKeySessionDelegateWrapper */ },
		{ 0x1A6320 /* AVFoundation.IAVFragmentMinding */, 0x1A6520 /* AVFragmentMindingWrapper */ },
		{ 0x1AAA20 /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */, 0x1AAC20 /* AVPlayerItemLegibleOutputPushDelegateWrapper */ },
		{ 0x1AB020 /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */, 0x1AB120 /* AVPlayerItemMetadataCollectorPushDelegateWrapper */ },
		{ 0x1AB420 /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */, 0x1AB620 /* AVPlayerItemMetadataOutputPushDelegateWrapper */ },
		{ 0x1AB920 /* AVFoundation.IAVPlayerItemOutputPullDelegate */, 0x1ABB20 /* AVPlayerItemOutputPullDelegateWrapper */ },
		{ 0x1ABD20 /* AVFoundation.IAVPlayerItemOutputPushDelegate */, 0x1ABF20 /* AVPlayerItemOutputPushDelegateWrapper */ },
		{ 0x1ACA20 /* AVFoundation.IAVQueuedSampleBufferRendering */, 0x1ACB20 /* AVQueuedSampleBufferRenderingWrapper */ },
		{ 0x1AE220 /* AVFoundation.IAVSpeechSynthesizerDelegate */, 0x1AE420 /* AVSpeechSynthesizerDelegateWrapper */ },
		{ 0x1AF120 /* AVFoundation.IAVVideoCompositing */, 0x1AF320 /* AVVideoCompositingWrapper */ },
		{ 0x1AFB20 /* AVFoundation.IAVVideoCompositionValidationHandling */, 0x1AFD20 /* AVVideoCompositionValidationHandlingWrapper */ },
		{ 0x1B1A20 /* AuthenticationServices.IASAuthorizationControllerDelegate */, 0x1B1C20 /* ASAuthorizationControllerDelegateWrapper */ },
		{ 0x1B1E20 /* AuthenticationServices.IASAuthorizationControllerPresentationContextProviding */, 0x1B1F20 /* ASAuthorizationControllerPresentationContextProvidingWrapper */ },
		{ 0x1B2020 /* AuthenticationServices.IASAuthorizationCredential */, 0x1B2120 /* ASAuthorizationCredentialWrapper */ },
		{ 0x1B2920 /* AuthenticationServices.IASAuthorizationProvider */, 0x1B2A20 /* ASAuthorizationProviderWrapper */ },
		{ 0x1B2E20 /* AuthenticationServices.IASAuthorizationProviderExtensionAuthorizationRequestHandler */, 0x1B3020 /* ASAuthorizationProviderExtensionAuthorizationRequestHandlerWrapper */ },
		{ 0x1B3820 /* AuthenticationServices.IASWebAuthenticationPresentationContextProviding */, 0x1B3920 /* ASWebAuthenticationPresentationContextProvidingWrapper */ },
		{ 0x1B3E20 /* AuthenticationServices.IASWebAuthenticationSessionRequestDelegate */, 0x1B4020 /* ASWebAuthenticationSessionRequestDelegateWrapper */ },
		{ 0x1B4220 /* AuthenticationServices.IASWebAuthenticationSessionWebBrowserSessionHandling */, 0x1B4320 /* ASWebAuthenticationSessionWebBrowserSessionHandlingWrapper */ },
		{ 0x1C8620 /* Foundation.INSCacheDelegate */, 0x1C8820 /* NSCacheDelegateWrapper */ },
		{ 0x1C8D20 /* Foundation.INSCoding */, 0x1C8E20 /* NSCodingWrapper */ },
		{ 0x1C9520 /* Foundation.INSConnectionDelegate */, 0x1C9720 /* NSConnectionDelegateWrapper */ },
		{ 0x1C9920 /* Foundation.INSCopying */, 0x1C9A20 /* NSCopyingWrapper */ },
		{ 0x1CA320 /* Foundation.INSDiscardableContent */, 0x1CA420 /* NSDiscardableContentWrapper */ },
		{ 0x1CAD20 /* Foundation.INSExtensionRequestHandling */, 0x1CAE20 /* NSExtensionRequestHandlingWrapper */ },
		{ 0x1CB420 /* Foundation.INSFileManagerDelegate */, 0x1CB520 /* NSFileManagerDelegateWrapper */ },
		{ 0x1CB620 /* Foundation.INSFilePresenter */, 0x1CB820 /* NSFilePresenterWrapper */ },
		{ 0x1CC320 /* Foundation.INSItemProviderReading */, 0x1CC420 /* NSItemProviderReadingWrapper */ },
		{ 0x1CC520 /* Foundation.INSItemProviderWriting */, 0x1CC720 /* NSItemProviderWritingWrapper */ },
		{ 0x1CCA20 /* Foundation.INSKeyedArchiverDelegate */, 0x1CCC20 /* NSKeyedArchiverDelegateWrapper */ },
		{ 0x1CCE20 /* Foundation.INSKeyedUnarchiverDelegate */, 0x1CD020 /* NSKeyedUnarchiverDelegateWrapper */ },
		{ 0x1CDE20 /* Foundation.INSLocking */, 0x1CDF20 /* NSLockingWrapper */ },
		{ 0x1CE120 /* Foundation.INSMachPortDelegate */, 0x1CE320 /* NSMachPortDelegateWrapper */ },
		{ 0x1CEA20 /* Foundation.INSMetadataQueryDelegate */, 0x1CEC20 /* NSMetadataQueryDelegateWrapper */ },
		{ 0x1CF120 /* Foundation.INSMutableCopying */, 0x1CF220 /* NSMutableCopyingWrapper */ },
		{ 0x1CFB20 /* Foundation.INSNetServiceBrowserDelegate */, 0x1CFD20 /* NSNetServiceBrowserDelegateWrapper */ },
		{ 0x1CFF20 /* Foundation.INSNetServiceDelegate */, 0x1D0120 /* NSNetServiceDelegateWrapper */ },
		{ 0x1D0620 /* Foundation.INSObjectProtocol */, 0x1D0820 /* NSObjectProtocolWrapper */ },
		{ 0x1D1120 /* Foundation.INSPortDelegate */, 0x1D1320 /* NSPortDelegateWrapper */ },
		{ 0x1D1F20 /* Foundation.INSProgressReporting */, 0x1D2120 /* NSProgressReportingWrapper */ },
		{ 0x1D2A20 /* Foundation.INSSecureCoding */, 0x1D2B20 /* NSSecureCodingWrapper */ },
		{ 0x1D3020 /* Foundation.INSStreamDelegate */, 0x1D3220 /* NSStreamDelegateWrapper */ },
		{ 0x1D4020 /* Foundation.INSURLAuthenticationChallengeSender */, 0x1D4220 /* NSURLAuthenticationChallengeSenderWrapper */ },
		{ 0x1D4620 /* Foundation.INSUrlConnectionDataDelegate */, 0x1D4820 /* NSUrlConnectionDataDelegateWrapper */ },
		{ 0x1D4A20 /* Foundation.INSUrlConnectionDelegate */, 0x1D4C20 /* NSUrlConnectionDelegateWrapper */ },
		{ 0x1D4E20 /* Foundation.INSUrlConnectionDownloadDelegate */, 0x1D5020 /* NSUrlConnectionDownloadDelegateWrapper */ },
		{ 0x1D5320 /* Foundation.INSUrlDownloadDelegate */, 0x1D5520 /* NSUrlDownloadDelegateWrapper */ },
		{ 0x1D5820 /* Foundation.INSUrlProtocolClient */, 0x1D5920 /* NSUrlProtocolClientWrapper */ },
		{ 0x1D6220 /* Foundation.INSUrlSessionDataDelegate */, 0x1D6420 /* NSUrlSessionDataDelegateWrapper */ },
		{ 0x1D6720 /* Foundation.INSUrlSessionDelegate */, 0x1D6920 /* NSUrlSessionDelegateWrapper */ },
		{ 0x1D6B20 /* Foundation.INSUrlSessionDownloadDelegate */, 0x1D6D20 /* NSUrlSessionDownloadDelegateWrapper */ },
		{ 0x1D7020 /* Foundation.INSUrlSessionStreamDelegate */, 0x1D7220 /* NSUrlSessionStreamDelegateWrapper */ },
		{ 0x1D7720 /* Foundation.INSUrlSessionTaskDelegate */, 0x1D7920 /* NSUrlSessionTaskDelegateWrapper */ },
		{ 0x1D8020 /* Foundation.INSUrlSessionWebSocketDelegate */, 0x1D8220 /* NSUrlSessionWebSocketDelegateWrapper */ },
		{ 0x1D8A20 /* Foundation.INSUserActivityDelegate */, 0x1D8C20 /* NSUserActivityDelegateWrapper */ },
		{ 0x1D9420 /* Foundation.INSUserNotificationCenterDelegate */, 0x1D9620 /* NSUserNotificationCenterDelegateWrapper */ },
	};

	static struct MTRegistrationMap __xamarin_registration_map = {
		__xamarin_registration_assemblies,
		__xamarin_class_map,
		__xamarin_token_references,
		__xamarin_skipped_map,
		__xamarin_protocol_wrapper_map,
		{ NULL, NULL },
		178,
		2919,
		36,
		11,
		548,
		0
	};

void xamarin_create_classes () {
	__xamarin_class_map [0].handle = objc_getClass ("NSObject");
	__xamarin_class_map [1].handle = objc_getClass ("SNAudioStreamAnalyzer");
	__xamarin_class_map [2].handle = objc_getClass ("SNClassification");
	__xamarin_class_map [3].handle = objc_getClass ("SNClassificationResult");
	__xamarin_class_map [4].handle = objc_getClass ("SNClassifySoundRequest");
	__xamarin_class_map [5].handle = objc_getClass ("SFContentBlockerState");
	__xamarin_class_map [6].handle = objc_getClass ("NSResponder");
	__xamarin_class_map [7].handle = objc_getClass ("NSViewController");
	__xamarin_class_map [8].handle = objc_getClass ("SFSafariExtensionViewController");
	__xamarin_class_map [9].handle = objc_getClass ("SFSafariPageProperties");
	__xamarin_class_map [10].handle = objc_getClass ("SFSafariToolbarItem");
	__xamarin_class_map [11].handle = objc_getClass ("SFUniversalLink");
	__xamarin_class_map [12].handle = objc_getClass ("SFAcousticFeature");
	__xamarin_class_map [13].handle = objc_getClass ("SFSpeechRecognitionRequest");
	__xamarin_class_map [14].handle = objc_getClass ("SFSpeechAudioBufferRecognitionRequest");
	__xamarin_class_map [15].handle = objc_getClass ("SFSpeechRecognitionResult");
	__xamarin_class_map [16].handle = objc_getClass ("SFSpeechRecognitionTask");
	__xamarin_class_map [17].handle = objc_getClass ("SFSpeechRecognitionTaskDelegate");
	__xamarin_class_map [18].handle = objc_getClass ("SFSpeechRecognizer");
	__xamarin_class_map [19].handle = objc_getClass ("SFSpeechRecognizerDelegate");
	__xamarin_class_map [20].handle = objc_getClass ("SFSpeechURLRecognitionRequest");
	__xamarin_class_map [21].handle = objc_getClass ("SFTranscription");
	__xamarin_class_map [22].handle = objc_getClass ("SFTranscriptionSegment");
	__xamarin_class_map [23].handle = objc_getClass ("SFVoiceAnalytics");
	__xamarin_class_map [24].handle = objc_getClass ("QLFileThumbnailRequest");
	__xamarin_class_map [25].handle = objc_getClass ("QLThumbnailGenerationRequest");
	__xamarin_class_map [26].handle = objc_getClass ("QLThumbnailProvider");
	__xamarin_class_map [27].handle = objc_getClass ("QLThumbnailReply");
	__xamarin_class_map [28].handle = objc_getClass ("QLThumbnailRepresentation");
	__xamarin_class_map [29].handle = objc_getClass ("QCComposition");
	__xamarin_class_map [30].handle = objc_getClass ("CALayer");
	__xamarin_class_map [31].handle = objc_getClass ("CAOpenGLLayer");
	__xamarin_class_map [32].handle = objc_getClass ("QCCompositionLayer");
	__xamarin_class_map [33].handle = objc_getClass ("QCCompositionRepository");
	__xamarin_class_map [34].handle = objc_getClass ("PKPushCredentials");
	__xamarin_class_map [35].handle = objc_getClass ("PKPushPayload");
	__xamarin_class_map [36].handle = objc_getClass ("PKPushRegistry");
	__xamarin_class_map [37].handle = objc_getClass ("PKPushRegistryDelegate");
	__xamarin_class_map [38].handle = objc_getClass ("PKDrawing");
	__xamarin_class_map [39].handle = objc_getClass ("NSView");
	__xamarin_class_map [40].handle = objc_getClass ("PHLivePhotoView");
	__xamarin_class_map [41].handle = objc_getClass ("PHLivePhotoViewDelegate");
	__xamarin_class_map [42].handle = objc_getClass ("PHProjectElement");
	__xamarin_class_map [43].handle = objc_getClass ("PHProjectAssetElement");
	__xamarin_class_map [44].handle = objc_getClass ("NSExtensionContext");
	__xamarin_class_map [45].handle = objc_getClass ("PHProjectExtensionContext");
	__xamarin_class_map [46].handle = objc_getClass ("PHProjectInfo");
	__xamarin_class_map [47].handle = objc_getClass ("PHProjectJournalEntryElement");
	__xamarin_class_map [48].handle = objc_getClass ("PHProjectMapElement");
	__xamarin_class_map [49].handle = objc_getClass ("PHProjectRegionOfInterest");
	__xamarin_class_map [50].handle = objc_getClass ("PHProjectSection");
	__xamarin_class_map [51].handle = objc_getClass ("PHProjectSectionContent");
	__xamarin_class_map [52].handle = objc_getClass ("PHProjectTextElement");
	__xamarin_class_map [53].handle = objc_getClass ("PHProjectTypeDescription");
	__xamarin_class_map [54].handle = objc_getClass ("PHProjectTypeDescriptionDataSource");
	__xamarin_class_map [55].handle = objc_getClass ("NCWidgetController");
	__xamarin_class_map [56].handle = objc_getClass ("NCWidgetListViewDelegate");
	__xamarin_class_map [57].handle = objc_getClass ("NCWidgetProviding");
	__xamarin_class_map [58].handle = objc_getClass ("NCWidgetSearchViewDelegate");
	__xamarin_class_map [59].handle = objc_getClass ("MLMediaGroup");
	__xamarin_class_map [60].handle = objc_getClass ("MLMediaLibrary");
	__xamarin_class_map [61].handle = objc_getClass ("MLMediaObject");
	__xamarin_class_map [62].handle = objc_getClass ("MLMediaSource");
	__xamarin_class_map [63].handle = objc_getClass ("LPLinkMetadata");
	__xamarin_class_map [64].handle = objc_getClass ("LPLinkView");
	__xamarin_class_map [65].handle = objc_getClass ("ICDevice");
	__xamarin_class_map [66].handle = objc_getClass ("ICCameraDevice");
	__xamarin_class_map [67].handle = objc_getClass ("Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDelegate");
	__xamarin_class_map [68].handle = objc_getClass ("Xamarin_Mac__ImageCaptureCore_ICCameraDeviceDownloadDelegate");
	__xamarin_class_map [69].handle = objc_getClass ("ICCameraItem");
	__xamarin_class_map [70].handle = objc_getClass ("ICCameraFile");
	__xamarin_class_map [71].handle = objc_getClass ("ICCameraFolder");
	__xamarin_class_map [72].handle = objc_getClass ("ICDeviceBrowser");
	__xamarin_class_map [73].handle = objc_getClass ("Xamarin_Mac__ImageCaptureCore_ICDeviceBrowserDelegate");
	__xamarin_class_map [74].handle = objc_getClass ("Xamarin_Mac__ImageCaptureCore_ICDeviceDelegate");
	__xamarin_class_map [75].handle = objc_getClass ("ICScannerBandData");
	__xamarin_class_map [76].handle = objc_getClass ("ICScannerDevice");
	__xamarin_class_map [77].handle = objc_getClass ("Xamarin_Mac__ImageCaptureCore_ICScannerDeviceDelegate");
	__xamarin_class_map [78].handle = objc_getClass ("ICScannerFeature");
	__xamarin_class_map [79].handle = objc_getClass ("ICScannerFeatureBoolean");
	__xamarin_class_map [80].handle = objc_getClass ("ICScannerFeatureEnumeration");
	__xamarin_class_map [81].handle = objc_getClass ("ICScannerFeatureRange");
	__xamarin_class_map [82].handle = objc_getClass ("ICScannerFeatureTemplate");
	__xamarin_class_map [83].handle = objc_getClass ("ICScannerFunctionalUnit");
	__xamarin_class_map [84].handle = objc_getClass ("ICScannerFunctionalUnitDocumentFeeder");
	__xamarin_class_map [85].handle = objc_getClass ("ICScannerFunctionalUnitFlatbed");
	__xamarin_class_map [86].handle = objc_getClass ("ICScannerFunctionalUnitNegativeTransparency");
	__xamarin_class_map [87].handle = objc_getClass ("ICScannerFunctionalUnitPositiveTransparency");
	__xamarin_class_map [88].handle = objc_getClass ("FPUIActionExtensionContext");
	__xamarin_class_map [89].handle = objc_getClass ("FPUIActionExtensionViewController");
	__xamarin_class_map [90].handle = objc_getClass ("EPDeveloperTool");
	__xamarin_class_map [91].handle = objc_getClass ("EPExecutionPolicy");
	__xamarin_class_map [92].handle = objc_getClass ("EAAccessoryDelegate");
	__xamarin_class_map [93].handle = objc_getClass ("EASession");
	__xamarin_class_map [94].handle = objc_getClass ("CNContactPicker");
	__xamarin_class_map [95].handle = objc_getClass ("CNContactPickerDelegate");
	__xamarin_class_map [96].handle = objc_getClass ("CNContactViewController");
	__xamarin_class_map [97].handle = objc_getClass ("AUAudioUnitViewConfiguration");
	__xamarin_class_map [98].handle = objc_getClass ("AUGenericView");
	__xamarin_class_map [99].handle = objc_getClass ("AUPannerView");
	__xamarin_class_map [100].handle = objc_getClass ("AUViewController");
	__xamarin_class_map [101].handle = objc_getClass ("NSWindowController");
	__xamarin_class_map [102].handle = objc_getClass ("CABTLEMIDIWindowController");
	__xamarin_class_map [103].handle = objc_getClass ("CAInterDeviceAudioViewController");
	__xamarin_class_map [104].handle = objc_getClass ("CANetworkBrowserWindowController");
	__xamarin_class_map [105].handle = objc_getClass ("ASIdentifierManager");
	__xamarin_class_map [106].handle = objc_getClass ("IKCameraDeviceViewDelegate");
	__xamarin_class_map [107].handle = objc_getClass ("IKDeviceBrowserViewDelegate");
	__xamarin_class_map [108].handle = objc_getClass ("IKFilterBrowserView");
	__xamarin_class_map [109].handle = objc_getClass ("IKFilterCustomUIProvider");
	__xamarin_class_map [110].handle = objc_getClass ("IKFilterUIView");
	__xamarin_class_map [111].handle = objc_getClass ("IKImageBrowserCell");
	__xamarin_class_map [112].handle = objc_getClass ("IKImageBrowserDataSource");
	__xamarin_class_map [113].handle = objc_getClass ("IKImageBrowserDelegate");
	__xamarin_class_map [114].handle = objc_getClass ("IKImageBrowserItem");
	__xamarin_class_map [115].handle = objc_getClass ("NSWindow");
	__xamarin_class_map [116].handle = objc_getClass ("NSPanel");
	__xamarin_class_map [117].handle = objc_getClass ("IKImageEditPanel");
	__xamarin_class_map [118].handle = objc_getClass ("IKImageEditPanelDataSource");
	__xamarin_class_map [119].handle = objc_getClass ("IKImageView");
	__xamarin_class_map [120].handle = objc_getClass ("IKPictureTaker");
	__xamarin_class_map [121].handle = objc_getClass ("IKSaveOptionsDelegate");
	__xamarin_class_map [122].handle = objc_getClass ("IKScannerDeviceViewDelegate");
	__xamarin_class_map [123].handle = objc_getClass ("IKSlideshow");
	__xamarin_class_map [124].handle = objc_getClass ("IKSlideshowDataSource");
	__xamarin_class_map [125].handle = objc_getClass ("MIDICIProfile");
	__xamarin_class_map [126].handle = objc_getClass ("MIDICIProfileState");
	__xamarin_class_map [127].handle = objc_getClass ("MIDICISession");
	__xamarin_class_map [128].handle = objc_getClass ("ACAccount");
	__xamarin_class_map [129].handle = objc_getClass ("ACAccountCredential");
	__xamarin_class_map [130].handle = objc_getClass ("ACAccountType");
	__xamarin_class_map [131].handle = objc_getClass ("VNRequest");
	__xamarin_class_map [132].handle = objc_getClass ("VNImageBasedRequest");
	__xamarin_class_map [133].handle = objc_getClass ("VNDetectBarcodesRequest");
	__xamarin_class_map [134].handle = objc_getClass ("VNObservation");
	__xamarin_class_map [135].handle = objc_getClass ("VNFeaturePrintObservation");
	__xamarin_class_map [136].handle = objc_getClass ("VNDetectedObjectObservation");
	__xamarin_class_map [137].handle = objc_getClass ("VNRectangleObservation");
	__xamarin_class_map [138].handle = objc_getClass ("VNBarcodeObservation");
	__xamarin_class_map [139].handle = objc_getClass ("VNClassificationObservation");
	__xamarin_class_map [140].handle = objc_getClass ("VNClassifyImageRequest");
	__xamarin_class_map [141].handle = objc_getClass ("VNCoreMLFeatureValueObservation");
	__xamarin_class_map [142].handle = objc_getClass ("VNCoreMLModel");
	__xamarin_class_map [143].handle = objc_getClass ("VNCoreMLRequest");
	__xamarin_class_map [144].handle = objc_getClass ("VNDetectFaceCaptureQualityRequest");
	__xamarin_class_map [145].handle = objc_getClass ("VNDetectFaceLandmarksRequest");
	__xamarin_class_map [146].handle = objc_getClass ("VNDetectFaceRectanglesRequest");
	__xamarin_class_map [147].handle = objc_getClass ("VNDetectHorizonRequest");
	__xamarin_class_map [148].handle = objc_getClass ("VNDetectHumanRectanglesRequest");
	__xamarin_class_map [149].handle = objc_getClass ("VNDetectRectanglesRequest");
	__xamarin_class_map [150].handle = objc_getClass ("VNDetectTextRectanglesRequest");
	__xamarin_class_map [151].handle = objc_getClass ("VNFaceLandmarkRegion");
	__xamarin_class_map [152].handle = objc_getClass ("VNFaceLandmarks");
	__xamarin_class_map [153].handle = objc_getClass ("VNFaceLandmarks2D");
	__xamarin_class_map [154].handle = objc_getClass ("VNFaceObservation");
	__xamarin_class_map [155].handle = objc_getClass ("VNGenerateAttentionBasedSaliencyImageRequest");
	__xamarin_class_map [156].handle = objc_getClass ("VNGenerateImageFeaturePrintRequest");
	__xamarin_class_map [157].handle = objc_getClass ("VNGenerateObjectnessBasedSaliencyImageRequest");
	__xamarin_class_map [158].handle = objc_getClass ("VNTargetedImageRequest");
	__xamarin_class_map [159].handle = objc_getClass ("VNImageRegistrationRequest");
	__xamarin_class_map [160].handle = objc_getClass ("VNHomographicImageRegistrationRequest");
	__xamarin_class_map [161].handle = objc_getClass ("VNHorizonObservation");
	__xamarin_class_map [162].handle = objc_getClass ("VNImageAlignmentObservation");
	__xamarin_class_map [163].handle = objc_getClass ("VNImageHomographicAlignmentObservation");
	__xamarin_class_map [164].handle = objc_getClass ("VNImageRequestHandler");
	__xamarin_class_map [165].handle = objc_getClass ("VNImageTranslationAlignmentObservation");
	__xamarin_class_map [166].handle = objc_getClass ("VNPixelBufferObservation");
	__xamarin_class_map [167].handle = objc_getClass ("VNRecognizedObjectObservation");
	__xamarin_class_map [168].handle = objc_getClass ("VNRecognizedText");
	__xamarin_class_map [169].handle = objc_getClass ("VNRecognizedTextObservation");
	__xamarin_class_map [170].handle = objc_getClass ("VNRecognizeTextRequest");
	__xamarin_class_map [171].handle = objc_getClass ("VNSaliencyImageObservation");
	__xamarin_class_map [172].handle = objc_getClass ("VNSequenceRequestHandler");
	__xamarin_class_map [173].handle = objc_getClass ("VNTextObservation");
	__xamarin_class_map [174].handle = objc_getClass ("VNTrackingRequest");
	__xamarin_class_map [175].handle = objc_getClass ("VNTrackObjectRequest");
	__xamarin_class_map [176].handle = objc_getClass ("VNTrackRectangleRequest");
	__xamarin_class_map [177].handle = objc_getClass ("VNTranslationalImageRegistrationRequest");
	__xamarin_class_map [178].handle = objc_getClass ("VSAccountMetadataRequest");
	__xamarin_class_map [179].handle = objc_getClass ("VSAccountManager");
	__xamarin_class_map [180].handle = objc_getClass ("VSAccountManagerDelegate");
	__xamarin_class_map [181].handle = objc_getClass ("VSAccountManagerResult");
	__xamarin_class_map [182].handle = objc_getClass ("VSAccountMetadata");
	__xamarin_class_map [183].handle = objc_getClass ("VSAccountProviderResponse");
	__xamarin_class_map [184].handle = objc_getClass ("VSSubscription");
	__xamarin_class_map [185].handle = objc_getClass ("VSSubscriptionRegistrationCenter");
	__xamarin_class_map [186].handle = objc_getClass ("UNNotificationAttachment");
	__xamarin_class_map [187].handle = objc_getClass ("UNNotificationTrigger");
	__xamarin_class_map [188].handle = objc_getClass ("UNCalendarNotificationTrigger");
	__xamarin_class_map [189].handle = objc_getClass ("UNNotificationContent");
	__xamarin_class_map [190].handle = objc_getClass ("UNMutableNotificationContent");
	__xamarin_class_map [191].handle = objc_getClass ("UNNotification");
	__xamarin_class_map [192].handle = objc_getClass ("UNNotificationAction");
	__xamarin_class_map [193].handle = objc_getClass ("UNNotificationCategory");
	__xamarin_class_map [194].handle = objc_getClass ("UNNotificationRequest");
	__xamarin_class_map [195].handle = objc_getClass ("UNNotificationResponse");
	__xamarin_class_map [196].handle = objc_getClass ("UNNotificationServiceExtension");
	__xamarin_class_map [197].handle = objc_getClass ("UNNotificationSettings");
	__xamarin_class_map [198].handle = objc_getClass ("UNNotificationSound");
	__xamarin_class_map [199].handle = objc_getClass ("UNPushNotificationTrigger");
	__xamarin_class_map [200].handle = objc_getClass ("UNTextInputNotificationAction");
	__xamarin_class_map [201].handle = objc_getClass ("UNTextInputNotificationResponse");
	__xamarin_class_map [202].handle = objc_getClass ("UNTimeIntervalNotificationTrigger");
	__xamarin_class_map [203].handle = objc_getClass ("UNUserNotificationCenterDelegate");
	__xamarin_class_map [204].handle = objc_getClass ("SKRequest");
	__xamarin_class_map [205].handle = objc_getClass ("SKReceiptRefreshRequest");
	__xamarin_class_map [206].handle = objc_getClass ("SKPayment");
	__xamarin_class_map [207].handle = objc_getClass ("SKPaymentTransactionObserver");
	__xamarin_class_map [208].handle = objc_getClass ("SKArcadeService");
	__xamarin_class_map [209].handle = objc_getClass ("SKDownload");
	__xamarin_class_map [210].handle = objc_getClass ("SKMutablePayment");
	__xamarin_class_map [211].handle = objc_getClass ("SKPaymentDiscount");
	__xamarin_class_map [212].handle = objc_getClass ("SKPaymentQueue");
	__xamarin_class_map [213].handle = objc_getClass ("Xamarin_Mac__StoreKit_SKPaymentQueueDelegate");
	__xamarin_class_map [214].handle = objc_getClass ("SKPaymentTransaction");
	__xamarin_class_map [215].handle = objc_getClass ("SKProduct");
	__xamarin_class_map [216].handle = objc_getClass ("SKProductDiscount");
	__xamarin_class_map [217].handle = objc_getClass ("SKRequestDelegate");
	__xamarin_class_map [218].handle = objc_getClass ("SKProductsRequestDelegate");
	__xamarin_class_map [219].handle = objc_getClass ("SKProductsResponse");
	__xamarin_class_map [220].handle = objc_getClass ("SKProductSubscriptionPeriod");
	__xamarin_class_map [221].handle = objc_getClass ("SKStorefront");
	__xamarin_class_map [222].handle = objc_getClass ("SKStoreReviewController");
	__xamarin_class_map [223].handle = objc_getClass ("SLComposeServiceViewController");
	__xamarin_class_map [224].handle = objc_getClass ("SBApplicationDelegate");
	__xamarin_class_map [225].handle = objc_getClass ("NSArray");
	__xamarin_class_map [226].handle = objc_getClass ("NSMutableArray");
	__xamarin_class_map [227].handle = objc_getClass ("SBElementArray");
	__xamarin_class_map [228].handle = objc_getClass ("SBObject");
	__xamarin_class_map [229].handle = objc_getClass ("QLPreviewPanel");
	__xamarin_class_map [230].handle = objc_getClass ("QLPreviewItem");
	__xamarin_class_map [231].handle = objc_getClass ("QLPreviewPanelDataSource");
	__xamarin_class_map [232].handle = objc_getClass ("QLPreviewPanelDelegate");
	__xamarin_class_map [233].handle = objc_getClass ("QLPreviewView");
	__xamarin_class_map [234].handle = objc_getClass ("PHObject");
	__xamarin_class_map [235].handle = objc_getClass ("PHCollection");
	__xamarin_class_map [236].handle = objc_getClass ("PHAssetCollection");
	__xamarin_class_map [237].handle = objc_getClass ("PHCollectionList");
	__xamarin_class_map [238].handle = objc_getClass ("PHContentEditingInput");
	__xamarin_class_map [239].handle = objc_getClass ("PHImageManager");
	__xamarin_class_map [240].handle = objc_getClass ("PHLivePhoto");
	__xamarin_class_map [241].handle = objc_getClass ("PHChangeRequest");
	__xamarin_class_map [242].handle = objc_getClass ("PHAdjustmentData");
	__xamarin_class_map [243].handle = objc_getClass ("PHAsset");
	__xamarin_class_map [244].handle = objc_getClass ("PHAssetChangeRequest");
	__xamarin_class_map [245].handle = objc_getClass ("PHAssetCollectionChangeRequest");
	__xamarin_class_map [246].handle = objc_getClass ("PHAssetCreationRequest");
	__xamarin_class_map [247].handle = objc_getClass ("PHAssetResource");
	__xamarin_class_map [248].handle = objc_getClass ("PHAssetResourceCreationOptions");
	__xamarin_class_map [249].handle = objc_getClass ("PHAssetResourceRequestOptions");
	__xamarin_class_map [250].handle = objc_getClass ("PHCachingImageManager");
	__xamarin_class_map [251].handle = objc_getClass ("PHChange");
	__xamarin_class_map [252].handle = objc_getClass ("PHCloudIdentifier");
	__xamarin_class_map [253].handle = objc_getClass ("PHCollectionListChangeRequest");
	__xamarin_class_map [254].handle = objc_getClass ("PHContentEditingInputRequestOptions");
	__xamarin_class_map [255].handle = objc_getClass ("PHContentEditingOutput");
	__xamarin_class_map [256].handle = objc_getClass ("PHFetchOptions");
	__xamarin_class_map [257].handle = objc_getClass ("PHFetchResult");
	__xamarin_class_map [258].handle = objc_getClass ("PHFetchResultChangeDetails");
	__xamarin_class_map [259].handle = objc_getClass ("PHImageRequestOptions");
	__xamarin_class_map [260].handle = objc_getClass ("PHLivePhotoRequestOptions");
	__xamarin_class_map [261].handle = objc_getClass ("PHObjectChangeDetails");
	__xamarin_class_map [262].handle = objc_getClass ("PHObjectPlaceholder");
	__xamarin_class_map [263].handle = objc_getClass ("PHPhotoLibraryChangeObserver");
	__xamarin_class_map [264].handle = objc_getClass ("PHProject");
	__xamarin_class_map [265].handle = objc_getClass ("PHProjectChangeRequest");
	__xamarin_class_map [266].handle = objc_getClass ("PHVideoRequestOptions");
	__xamarin_class_map [267].handle = objc_getClass ("PDFBorder");
	__xamarin_class_map [268].handle = objc_getClass ("PDFAnnotation");
	__xamarin_class_map [269].handle = objc_getClass ("PDFAnnotationMarkup");
	__xamarin_class_map [270].handle = objc_getClass ("PDFAction");
	__xamarin_class_map [271].handle = objc_getClass ("PDFActionGoTo");
	__xamarin_class_map [272].handle = objc_getClass ("PDFActionNamed");
	__xamarin_class_map [273].handle = objc_getClass ("PDFActionRemoteGoTo");
	__xamarin_class_map [274].handle = objc_getClass ("PDFActionResetForm");
	__xamarin_class_map [275].handle = objc_getClass ("PDFActionURL");
	__xamarin_class_map [276].handle = objc_getClass ("PDFAnnotationButtonWidget");
	__xamarin_class_map [277].handle = objc_getClass ("PDFAnnotationChoiceWidget");
	__xamarin_class_map [278].handle = objc_getClass ("PDFAnnotationCircle");
	__xamarin_class_map [279].handle = objc_getClass ("PDFAnnotationFreeText");
	__xamarin_class_map [280].handle = objc_getClass ("PDFAnnotationInk");
	__xamarin_class_map [281].handle = objc_getClass ("PDFAnnotationLine");
	__xamarin_class_map [282].handle = objc_getClass ("PDFAnnotationLink");
	__xamarin_class_map [283].handle = objc_getClass ("PDFAnnotationPopup");
	__xamarin_class_map [284].handle = objc_getClass ("PDFAnnotationSquare");
	__xamarin_class_map [285].handle = objc_getClass ("PDFAnnotationStamp");
	__xamarin_class_map [286].handle = objc_getClass ("PDFAnnotationText");
	__xamarin_class_map [287].handle = objc_getClass ("PDFAnnotationTextWidget");
	__xamarin_class_map [288].handle = objc_getClass ("PDFAppearanceCharacteristics");
	__xamarin_class_map [289].handle = objc_getClass ("PDFDestination");
	__xamarin_class_map [290].handle = objc_getClass ("PDFDocumentDelegate");
	__xamarin_class_map [291].handle = objc_getClass ("PDFOutline");
	__xamarin_class_map [292].handle = objc_getClass ("PDFPage");
	__xamarin_class_map [293].handle = objc_getClass ("PDFSelection");
	__xamarin_class_map [294].handle = objc_getClass ("PDFViewDelegate");
	__xamarin_class_map [295].handle = objc_getClass ("NETunnelNetworkSettings");
	__xamarin_class_map [296].handle = objc_getClass ("NEPacketTunnelNetworkSettings");
	__xamarin_class_map [297].handle = objc_getClass ("NWPath");
	__xamarin_class_map [298].handle = objc_getClass ("NWEndpoint");
	__xamarin_class_map [299].handle = objc_getClass ("NWHostEndpoint");
	__xamarin_class_map [300].handle = objc_getClass ("NWTCPConnectionAuthenticationDelegate");
	__xamarin_class_map [301].handle = objc_getClass ("NEAppRule");
	__xamarin_class_map [302].handle = objc_getClass ("NEVPNProtocol");
	__xamarin_class_map [303].handle = objc_getClass ("NEDNSProxyProviderProtocol");
	__xamarin_class_map [304].handle = objc_getClass ("NEDNSSettings");
	__xamarin_class_map [305].handle = objc_getClass ("NEEvaluateConnectionRule");
	__xamarin_class_map [306].handle = objc_getClass ("NEFilterVerdict");
	__xamarin_class_map [307].handle = objc_getClass ("NEFilterDataVerdict");
	__xamarin_class_map [308].handle = objc_getClass ("NEFilterFlow");
	__xamarin_class_map [309].handle = objc_getClass ("NEFilterNewFlowVerdict");
	__xamarin_class_map [310].handle = objc_getClass ("NEFilterPacketContext");
	__xamarin_class_map [311].handle = objc_getClass ("NEProvider");
	__xamarin_class_map [312].handle = objc_getClass ("NEFilterProvider");
	__xamarin_class_map [313].handle = objc_getClass ("NEFilterPacketProvider");
	__xamarin_class_map [314].handle = objc_getClass ("NEFilterProviderConfiguration");
	__xamarin_class_map [315].handle = objc_getClass ("NEFilterReport");
	__xamarin_class_map [316].handle = objc_getClass ("NEFilterRule");
	__xamarin_class_map [317].handle = objc_getClass ("NEFilterSettings");
	__xamarin_class_map [318].handle = objc_getClass ("NEFilterSocketFlow");
	__xamarin_class_map [319].handle = objc_getClass ("NEFlowMetaData");
	__xamarin_class_map [320].handle = objc_getClass ("NEIPv4Route");
	__xamarin_class_map [321].handle = objc_getClass ("NEIPv4Settings");
	__xamarin_class_map [322].handle = objc_getClass ("NEIPv6Route");
	__xamarin_class_map [323].handle = objc_getClass ("NEIPv6Settings");
	__xamarin_class_map [324].handle = objc_getClass ("NENetworkRule");
	__xamarin_class_map [325].handle = objc_getClass ("NEOnDemandRule");
	__xamarin_class_map [326].handle = objc_getClass ("NEOnDemandRuleConnect");
	__xamarin_class_map [327].handle = objc_getClass ("NEOnDemandRuleDisconnect");
	__xamarin_class_map [328].handle = objc_getClass ("NEOnDemandRuleEvaluateConnection");
	__xamarin_class_map [329].handle = objc_getClass ("NEOnDemandRuleIgnore");
	__xamarin_class_map [330].handle = objc_getClass ("NEPacket");
	__xamarin_class_map [331].handle = objc_getClass ("NEProxyServer");
	__xamarin_class_map [332].handle = objc_getClass ("NEProxySettings");
	__xamarin_class_map [333].handle = objc_getClass ("NETransparentProxyNetworkSettings");
	__xamarin_class_map [334].handle = objc_getClass ("NETunnelProviderProtocol");
	__xamarin_class_map [335].handle = objc_getClass ("NEVPNConnection");
	__xamarin_class_map [336].handle = objc_getClass ("NETunnelProviderSession");
	__xamarin_class_map [337].handle = objc_getClass ("NEVPNIKEv2SecurityAssociationParameters");
	__xamarin_class_map [338].handle = objc_getClass ("NEVPNProtocolIPSec");
	__xamarin_class_map [339].handle = objc_getClass ("NEVPNProtocolIKEv2");
	__xamarin_class_map [340].handle = objc_getClass ("NWBonjourServiceEndpoint");
	__xamarin_class_map [341].handle = objc_getClass ("NWTLSParameters");
	__xamarin_class_map [342].handle = objc_getClass ("NLGazetteer");
	__xamarin_class_map [343].handle = objc_getClass ("NLModel");
	__xamarin_class_map [344].handle = objc_getClass ("NLModelConfiguration");
	__xamarin_class_map [345].handle = objc_getClass ("NLTokenizer");
	__xamarin_class_map [346].handle = objc_getClass ("MCPeerID");
	__xamarin_class_map [347].handle = objc_getClass ("MCAdvertiserAssistant");
	__xamarin_class_map [348].handle = objc_getClass ("MCAdvertiserAssistantDelegate");
	__xamarin_class_map [349].handle = objc_getClass ("MCBrowserViewController");
	__xamarin_class_map [350].handle = objc_getClass ("MCBrowserViewControllerDelegate");
	__xamarin_class_map [351].handle = objc_getClass ("MCNearbyServiceAdvertiser");
	__xamarin_class_map [352].handle = objc_getClass ("MCNearbyServiceAdvertiserDelegate");
	__xamarin_class_map [353].handle = objc_getClass ("MCNearbyServiceBrowser");
	__xamarin_class_map [354].handle = objc_getClass ("MCNearbyServiceBrowserDelegate");
	__xamarin_class_map [355].handle = objc_getClass ("MCSessionDelegate");
	__xamarin_class_map [356].handle = objc_getClass ("MDLAnimatedValue");
	__xamarin_class_map [357].handle = objc_getClass ("MDLAnimatedQuaternion");
	__xamarin_class_map [358].handle = objc_getClass ("MDLAnimatedScalarArray");
	__xamarin_class_map [359].handle = objc_getClass ("MDLAnimatedVector3Array");
	__xamarin_class_map [360].handle = objc_getClass ("MDLAnimatedQuaternionArray");
	__xamarin_class_map [361].handle = objc_getClass ("MDLAnimatedScalar");
	__xamarin_class_map [362].handle = objc_getClass ("MDLAnimatedVector2");
	__xamarin_class_map [363].handle = objc_getClass ("MDLAnimatedVector3");
	__xamarin_class_map [364].handle = objc_getClass ("MDLAnimatedVector4");
	__xamarin_class_map [365].handle = objc_getClass ("MDLAnimatedMatrix4x4");
	__xamarin_class_map [366].handle = objc_getClass ("MDLMatrix4x4Array");
	__xamarin_class_map [367].handle = objc_getClass ("MDLAsset");
	__xamarin_class_map [368].handle = objc_getClass ("MDLTexture");
	__xamarin_class_map [369].handle = objc_getClass ("MDLNoiseTexture");
	__xamarin_class_map [370].handle = objc_getClass ("MDLTransform");
	__xamarin_class_map [371].handle = objc_getClass ("MDLVertexDescriptor");
	__xamarin_class_map [372].handle = objc_getClass ("MDLAnimationBindComponent");
	__xamarin_class_map [373].handle = objc_getClass ("MDLObject");
	__xamarin_class_map [374].handle = objc_getClass ("MDLLight");
	__xamarin_class_map [375].handle = objc_getClass ("MDLPhysicallyPlausibleLight");
	__xamarin_class_map [376].handle = objc_getClass ("MDLAreaLight");
	__xamarin_class_map [377].handle = objc_getClass ("MDLBundleAssetResolver");
	__xamarin_class_map [378].handle = objc_getClass ("MDLCamera");
	__xamarin_class_map [379].handle = objc_getClass ("MDLCheckerboardTexture");
	__xamarin_class_map [380].handle = objc_getClass ("MDLColorSwatchTexture");
	__xamarin_class_map [381].handle = objc_getClass ("MDLLightProbe");
	__xamarin_class_map [382].handle = objc_getClass ("MDLLightProbeIrradianceDataSource");
	__xamarin_class_map [383].handle = objc_getClass ("MDLMaterial");
	__xamarin_class_map [384].handle = objc_getClass ("MDLMaterialProperty");
	__xamarin_class_map [385].handle = objc_getClass ("MDLMaterialPropertyConnection");
	__xamarin_class_map [386].handle = objc_getClass ("MDLMaterialPropertyNode");
	__xamarin_class_map [387].handle = objc_getClass ("MDLMaterialPropertyGraph");
	__xamarin_class_map [388].handle = objc_getClass ("MDLMeshBufferData");
	__xamarin_class_map [389].handle = objc_getClass ("MDLMeshBufferDataAllocator");
	__xamarin_class_map [390].handle = objc_getClass ("MDLMeshBufferMap");
	__xamarin_class_map [391].handle = objc_getClass ("MDLMeshBufferZoneDefault");
	__xamarin_class_map [392].handle = objc_getClass ("MDLNormalMapTexture");
	__xamarin_class_map [393].handle = objc_getClass ("MDLObjectContainer");
	__xamarin_class_map [394].handle = objc_getClass ("MDLPackedJointAnimation");
	__xamarin_class_map [395].handle = objc_getClass ("MDLPathAssetResolver");
	__xamarin_class_map [396].handle = objc_getClass ("MDLPhotometricLight");
	__xamarin_class_map [397].handle = objc_getClass ("MDLScatteringFunction");
	__xamarin_class_map [398].handle = objc_getClass ("MDLPhysicallyPlausibleScatteringFunction");
	__xamarin_class_map [399].handle = objc_getClass ("MDLRelativeAssetResolver");
	__xamarin_class_map [400].handle = objc_getClass ("MDLSkeleton");
	__xamarin_class_map [401].handle = objc_getClass ("MDLSkyCubeTexture");
	__xamarin_class_map [402].handle = objc_getClass ("MDLStereoscopicCamera");
	__xamarin_class_map [403].handle = objc_getClass ("MDLSubmesh");
	__xamarin_class_map [404].handle = objc_getClass ("MDLSubmeshTopology");
	__xamarin_class_map [405].handle = objc_getClass ("MDLTextureFilter");
	__xamarin_class_map [406].handle = objc_getClass ("MDLTextureSampler");
	__xamarin_class_map [407].handle = objc_getClass ("MDLTransformMatrixOp");
	__xamarin_class_map [408].handle = objc_getClass ("MDLTransformOrientOp");
	__xamarin_class_map [409].handle = objc_getClass ("MDLTransformRotateOp");
	__xamarin_class_map [410].handle = objc_getClass ("MDLTransformRotateXOp");
	__xamarin_class_map [411].handle = objc_getClass ("MDLTransformRotateYOp");
	__xamarin_class_map [412].handle = objc_getClass ("MDLTransformRotateZOp");
	__xamarin_class_map [413].handle = objc_getClass ("MDLTransformScaleOp");
	__xamarin_class_map [414].handle = objc_getClass ("MDLTransformStack");
	__xamarin_class_map [415].handle = objc_getClass ("MDLTransformTranslateOp");
	__xamarin_class_map [416].handle = objc_getClass ("MDLURLTexture");
	__xamarin_class_map [417].handle = objc_getClass ("MDLVertexAttribute");
	__xamarin_class_map [418].handle = objc_getClass ("MDLVertexAttributeData");
	__xamarin_class_map [419].handle = objc_getClass ("MDLVertexBufferLayout");
	__xamarin_class_map [420].handle = objc_getClass ("MDLVoxelArray");
	__xamarin_class_map [421].handle = objc_getClass ("MPSNNFilterNode");
	__xamarin_class_map [422].handle = objc_getClass ("MPSCNNConvolutionNode");
	__xamarin_class_map [423].handle = objc_getClass ("MPSCNNConvolutionTransposeNode");
	__xamarin_class_map [424].handle = objc_getClass ("MPSKernel");
	__xamarin_class_map [425].handle = objc_getClass ("MPSUnaryImageKernel");
	__xamarin_class_map [426].handle = objc_getClass ("MPSImageScale");
	__xamarin_class_map [427].handle = objc_getClass ("MPSCNNConvolutionDescriptor");
	__xamarin_class_map [428].handle = objc_getClass ("MPSCNNKernel");
	__xamarin_class_map [429].handle = objc_getClass ("MPSCNNNeuron");
	__xamarin_class_map [430].handle = objc_getClass ("MPSCNNNeuronPReLU");
	__xamarin_class_map [431].handle = objc_getClass ("MPSCNNBinaryConvolution");
	__xamarin_class_map [432].handle = objc_getClass ("MPSCNNBinaryFullyConnected");
	__xamarin_class_map [433].handle = objc_getClass ("MPSStateResourceList");
	__xamarin_class_map [434].handle = objc_getClass ("MPSImageDilate");
	__xamarin_class_map [435].handle = objc_getClass ("MPSImageErode");
	__xamarin_class_map [436].handle = objc_getClass ("MPSImageThresholdBinary");
	__xamarin_class_map [437].handle = objc_getClass ("MPSImageThresholdBinaryInverse");
	__xamarin_class_map [438].handle = objc_getClass ("MPSImageThresholdTruncate");
	__xamarin_class_map [439].handle = objc_getClass ("MPSImageThresholdToZero");
	__xamarin_class_map [440].handle = objc_getClass ("MPSImageThresholdToZeroInverse");
	__xamarin_class_map [441].handle = objc_getClass ("MPSImageSobel");
	__xamarin_class_map [442].handle = objc_getClass ("MPSCNNConvolution");
	__xamarin_class_map [443].handle = objc_getClass ("MPSCNNFullyConnected");
	__xamarin_class_map [444].handle = objc_getClass ("MPSImageConversion");
	__xamarin_class_map [445].handle = objc_getClass ("MPSImagePyramid");
	__xamarin_class_map [446].handle = objc_getClass ("MPSImageGaussianPyramid");
	__xamarin_class_map [447].handle = objc_getClass ("MPSImageLaplacianPyramid");
	__xamarin_class_map [448].handle = objc_getClass ("MPSImageLaplacianPyramidSubtract");
	__xamarin_class_map [449].handle = objc_getClass ("MPSImageLaplacianPyramidAdd");
	__xamarin_class_map [450].handle = objc_getClass ("MPSCNNBinaryConvolutionNode");
	__xamarin_class_map [451].handle = objc_getClass ("MPSCNNBinaryFullyConnectedNode");
	__xamarin_class_map [452].handle = objc_getClass ("MPSAccelerationStructureGroup");
	__xamarin_class_map [453].handle = objc_getClass ("MPSBinaryImageKernel");
	__xamarin_class_map [454].handle = objc_getClass ("MPSCNNBinaryKernel");
	__xamarin_class_map [455].handle = objc_getClass ("MPSCNNArithmetic");
	__xamarin_class_map [456].handle = objc_getClass ("MPSCNNAdd");
	__xamarin_class_map [457].handle = objc_getClass ("MPSCNNGradientKernel");
	__xamarin_class_map [458].handle = objc_getClass ("MPSCNNArithmeticGradient");
	__xamarin_class_map [459].handle = objc_getClass ("MPSCNNAddGradient");
	__xamarin_class_map [460].handle = objc_getClass ("MPSState");
	__xamarin_class_map [461].handle = objc_getClass ("MPSNNBinaryGradientState");
	__xamarin_class_map [462].handle = objc_getClass ("MPSCNNArithmeticGradientState");
	__xamarin_class_map [463].handle = objc_getClass ("MPSCNNBatchNormalization");
	__xamarin_class_map [464].handle = objc_getClass ("Xamarin_Mac__MetalPerformanceShaders_MPSCnnBatchNormalizationDataSource");
	__xamarin_class_map [465].handle = objc_getClass ("MPSCNNBatchNormalizationGradient");
	__xamarin_class_map [466].handle = objc_getClass ("MPSNNGradientFilterNode");
	__xamarin_class_map [467].handle = objc_getClass ("MPSCNNBatchNormalizationGradientNode");
	__xamarin_class_map [468].handle = objc_getClass ("MPSCNNBatchNormalizationNode");
	__xamarin_class_map [469].handle = objc_getClass ("MPSNNGradientState");
	__xamarin_class_map [470].handle = objc_getClass ("MPSCNNBatchNormalizationState");
	__xamarin_class_map [471].handle = objc_getClass ("MPSCNNBatchNormalizationStatistics");
	__xamarin_class_map [472].handle = objc_getClass ("MPSCNNBatchNormalizationStatisticsGradient");
	__xamarin_class_map [473].handle = objc_getClass ("MPSCNNConvolutionDataSource");
	__xamarin_class_map [474].handle = objc_getClass ("MPSCNNConvolutionGradient");
	__xamarin_class_map [475].handle = objc_getClass ("MPSCNNConvolutionGradientNode");
	__xamarin_class_map [476].handle = objc_getClass ("MPSCNNConvolutionGradientState");
	__xamarin_class_map [477].handle = objc_getClass ("MPSNNStateNode");
	__xamarin_class_map [478].handle = objc_getClass ("MPSNNGradientStateNode");
	__xamarin_class_map [479].handle = objc_getClass ("MPSCNNConvolutionGradientStateNode");
	__xamarin_class_map [480].handle = objc_getClass ("MPSCNNConvolutionState");
	__xamarin_class_map [481].handle = objc_getClass ("MPSCNNConvolutionStateNode");
	__xamarin_class_map [482].handle = objc_getClass ("MPSCNNConvolutionTranspose");
	__xamarin_class_map [483].handle = objc_getClass ("MPSCNNConvolutionWeightsAndBiasesState");
	__xamarin_class_map [484].handle = objc_getClass ("MPSCNNCrossChannelNormalization");
	__xamarin_class_map [485].handle = objc_getClass ("MPSCNNCrossChannelNormalizationGradient");
	__xamarin_class_map [486].handle = objc_getClass ("MPSCNNCrossChannelNormalizationGradientNode");
	__xamarin_class_map [487].handle = objc_getClass ("MPSCNNNormalizationNode");
	__xamarin_class_map [488].handle = objc_getClass ("MPSCNNCrossChannelNormalizationNode");
	__xamarin_class_map [489].handle = objc_getClass ("MPSCNNDepthWiseConvolutionDescriptor");
	__xamarin_class_map [490].handle = objc_getClass ("MPSCNNPooling");
	__xamarin_class_map [491].handle = objc_getClass ("MPSCNNDilatedPoolingMax");
	__xamarin_class_map [492].handle = objc_getClass ("MPSCNNPoolingGradient");
	__xamarin_class_map [493].handle = objc_getClass ("MPSCNNDilatedPoolingMaxGradient");
	__xamarin_class_map [494].handle = objc_getClass ("MPSCNNPoolingGradientNode");
	__xamarin_class_map [495].handle = objc_getClass ("MPSCNNDilatedPoolingMaxGradientNode");
	__xamarin_class_map [496].handle = objc_getClass ("MPSCNNDilatedPoolingMaxNode");
	__xamarin_class_map [497].handle = objc_getClass ("MPSCNNDivide");
	__xamarin_class_map [498].handle = objc_getClass ("MPSCNNDropout");
	__xamarin_class_map [499].handle = objc_getClass ("MPSCNNDropoutGradient");
	__xamarin_class_map [500].handle = objc_getClass ("MPSCNNDropoutGradientNode");
	__xamarin_class_map [501].handle = objc_getClass ("MPSCNNDropoutGradientState");
	__xamarin_class_map [502].handle = objc_getClass ("MPSCNNDropoutNode");
	__xamarin_class_map [503].handle = objc_getClass ("MPSCNNFullyConnectedGradient");
	__xamarin_class_map [504].handle = objc_getClass ("MPSCNNFullyConnectedNode");
	__xamarin_class_map [505].handle = objc_getClass ("MPSCNNInstanceNormalization");
	__xamarin_class_map [506].handle = objc_getClass ("Xamarin_Mac__MetalPerformanceShaders_MPSCnnInstanceNormalizationDataSource");
	__xamarin_class_map [507].handle = objc_getClass ("MPSCNNInstanceNormalizationGradient");
	__xamarin_class_map [508].handle = objc_getClass ("MPSCNNInstanceNormalizationGradientNode");
	__xamarin_class_map [509].handle = objc_getClass ("MPSCNNInstanceNormalizationGradientState");
	__xamarin_class_map [510].handle = objc_getClass ("MPSCNNInstanceNormalizationNode");
	__xamarin_class_map [511].handle = objc_getClass ("MPSCNNLocalContrastNormalization");
	__xamarin_class_map [512].handle = objc_getClass ("MPSCNNLocalContrastNormalizationGradient");
	__xamarin_class_map [513].handle = objc_getClass ("MPSCNNLocalContrastNormalizationGradientNode");
	__xamarin_class_map [514].handle = objc_getClass ("MPSCNNLocalContrastNormalizationNode");
	__xamarin_class_map [515].handle = objc_getClass ("MPSCNNLogSoftMax");
	__xamarin_class_map [516].handle = objc_getClass ("MPSCNNLogSoftMaxGradient");
	__xamarin_class_map [517].handle = objc_getClass ("MPSCNNLogSoftMaxGradientNode");
	__xamarin_class_map [518].handle = objc_getClass ("MPSCNNLogSoftMaxNode");
	__xamarin_class_map [519].handle = objc_getClass ("MPSCNNLoss");
	__xamarin_class_map [520].handle = objc_getClass ("MPSCNNLossDataDescriptor");
	__xamarin_class_map [521].handle = objc_getClass ("MPSCNNLossDescriptor");
	__xamarin_class_map [522].handle = objc_getClass ("MPSCNNLossLabels");
	__xamarin_class_map [523].handle = objc_getClass ("MPSCNNLossNode");
	__xamarin_class_map [524].handle = objc_getClass ("MPSCNNMultiply");
	__xamarin_class_map [525].handle = objc_getClass ("MPSCNNMultiplyGradient");
	__xamarin_class_map [526].handle = objc_getClass ("MPSCNNNeuronAbsolute");
	__xamarin_class_map [527].handle = objc_getClass ("MPSCNNNeuronNode");
	__xamarin_class_map [528].handle = objc_getClass ("MPSCNNNeuronAbsoluteNode");
	__xamarin_class_map [529].handle = objc_getClass ("MPSCNNNeuronELU");
	__xamarin_class_map [530].handle = objc_getClass ("MPSCNNNeuronELUNode");
	__xamarin_class_map [531].handle = objc_getClass ("MPSCNNNeuronExponential");
	__xamarin_class_map [532].handle = objc_getClass ("MPSCNNNeuronExponentialNode");
	__xamarin_class_map [533].handle = objc_getClass ("MPSCNNNeuronGradient");
	__xamarin_class_map [534].handle = objc_getClass ("MPSCNNNeuronGradientNode");
	__xamarin_class_map [535].handle = objc_getClass ("MPSCNNNeuronHardSigmoid");
	__xamarin_class_map [536].handle = objc_getClass ("MPSCNNNeuronHardSigmoidNode");
	__xamarin_class_map [537].handle = objc_getClass ("MPSCNNNeuronLinear");
	__xamarin_class_map [538].handle = objc_getClass ("MPSCNNNeuronLinearNode");
	__xamarin_class_map [539].handle = objc_getClass ("MPSCNNNeuronLogarithm");
	__xamarin_class_map [540].handle = objc_getClass ("MPSCNNNeuronLogarithmNode");
	__xamarin_class_map [541].handle = objc_getClass ("MPSCNNNeuronPower");
	__xamarin_class_map [542].handle = objc_getClass ("MPSCNNNeuronPowerNode");
	__xamarin_class_map [543].handle = objc_getClass ("MPSCNNNeuronPReLUNode");
	__xamarin_class_map [544].handle = objc_getClass ("MPSCNNNeuronReLU");
	__xamarin_class_map [545].handle = objc_getClass ("MPSCNNNeuronReLUN");
	__xamarin_class_map [546].handle = objc_getClass ("MPSCNNNeuronReLUNNode");
	__xamarin_class_map [547].handle = objc_getClass ("MPSCNNNeuronReLUNode");
	__xamarin_class_map [548].handle = objc_getClass ("MPSCNNNeuronSigmoid");
	__xamarin_class_map [549].handle = objc_getClass ("MPSCNNNeuronSigmoidNode");
	__xamarin_class_map [550].handle = objc_getClass ("MPSCNNNeuronSoftPlus");
	__xamarin_class_map [551].handle = objc_getClass ("MPSCNNNeuronSoftPlusNode");
	__xamarin_class_map [552].handle = objc_getClass ("MPSCNNNeuronSoftSign");
	__xamarin_class_map [553].handle = objc_getClass ("MPSCNNNeuronSoftSignNode");
	__xamarin_class_map [554].handle = objc_getClass ("MPSCNNNeuronTanH");
	__xamarin_class_map [555].handle = objc_getClass ("MPSCNNNeuronTanHNode");
	__xamarin_class_map [556].handle = objc_getClass ("MPSCNNNormalizationGammaAndBetaState");
	__xamarin_class_map [557].handle = objc_getClass ("MPSCNNNormalizationMeanAndVarianceState");
	__xamarin_class_map [558].handle = objc_getClass ("MPSCNNPoolingAverage");
	__xamarin_class_map [559].handle = objc_getClass ("MPSCNNPoolingAverageGradient");
	__xamarin_class_map [560].handle = objc_getClass ("MPSCNNPoolingAverageGradientNode");
	__xamarin_class_map [561].handle = objc_getClass ("MPSCNNPoolingNode");
	__xamarin_class_map [562].handle = objc_getClass ("MPSCNNPoolingAverageNode");
	__xamarin_class_map [563].handle = objc_getClass ("MPSCNNPoolingL2Norm");
	__xamarin_class_map [564].handle = objc_getClass ("MPSCNNPoolingL2NormGradient");
	__xamarin_class_map [565].handle = objc_getClass ("MPSCNNPoolingL2NormGradientNode");
	__xamarin_class_map [566].handle = objc_getClass ("MPSCNNPoolingL2NormNode");
	__xamarin_class_map [567].handle = objc_getClass ("MPSCNNPoolingMax");
	__xamarin_class_map [568].handle = objc_getClass ("MPSCNNPoolingMaxGradient");
	__xamarin_class_map [569].handle = objc_getClass ("MPSCNNPoolingMaxGradientNode");
	__xamarin_class_map [570].handle = objc_getClass ("MPSCNNPoolingMaxNode");
	__xamarin_class_map [571].handle = objc_getClass ("MPSCNNSoftMax");
	__xamarin_class_map [572].handle = objc_getClass ("MPSCNNSoftMaxGradient");
	__xamarin_class_map [573].handle = objc_getClass ("MPSCNNSoftMaxGradientNode");
	__xamarin_class_map [574].handle = objc_getClass ("MPSCNNSoftMaxNode");
	__xamarin_class_map [575].handle = objc_getClass ("MPSCNNSpatialNormalization");
	__xamarin_class_map [576].handle = objc_getClass ("MPSCNNSpatialNormalizationGradient");
	__xamarin_class_map [577].handle = objc_getClass ("MPSCNNSpatialNormalizationGradientNode");
	__xamarin_class_map [578].handle = objc_getClass ("MPSCNNSpatialNormalizationNode");
	__xamarin_class_map [579].handle = objc_getClass ("MPSCNNSubPixelConvolutionDescriptor");
	__xamarin_class_map [580].handle = objc_getClass ("MPSCNNSubtract");
	__xamarin_class_map [581].handle = objc_getClass ("MPSCNNSubtractGradient");
	__xamarin_class_map [582].handle = objc_getClass ("MPSCNNUpsampling");
	__xamarin_class_map [583].handle = objc_getClass ("MPSCNNUpsamplingBilinear");
	__xamarin_class_map [584].handle = objc_getClass ("MPSCNNUpsamplingGradient");
	__xamarin_class_map [585].handle = objc_getClass ("MPSCNNUpsamplingBilinearGradient");
	__xamarin_class_map [586].handle = objc_getClass ("MPSCNNUpsamplingBilinearGradientNode");
	__xamarin_class_map [587].handle = objc_getClass ("MPSCNNUpsamplingBilinearNode");
	__xamarin_class_map [588].handle = objc_getClass ("MPSCNNUpsamplingNearest");
	__xamarin_class_map [589].handle = objc_getClass ("MPSCNNUpsamplingNearestGradient");
	__xamarin_class_map [590].handle = objc_getClass ("MPSCNNUpsamplingNearestGradientNode");
	__xamarin_class_map [591].handle = objc_getClass ("MPSCNNUpsamplingNearestNode");
	__xamarin_class_map [592].handle = objc_getClass ("MPSCNNYOLOLoss");
	__xamarin_class_map [593].handle = objc_getClass ("MPSCNNYOLOLossDescriptor");
	__xamarin_class_map [594].handle = objc_getClass ("MPSCNNYOLOLossNode");
	__xamarin_class_map [595].handle = objc_getClass ("MPSRNNDescriptor");
	__xamarin_class_map [596].handle = objc_getClass ("MPSGRUDescriptor");
	__xamarin_class_map [597].handle = objc_getClass ("MPSImage");
	__xamarin_class_map [598].handle = objc_getClass ("MPSImageArithmetic");
	__xamarin_class_map [599].handle = objc_getClass ("MPSImageAdd");
	__xamarin_class_map [600].handle = objc_getClass ("MPSImageAreaMax");
	__xamarin_class_map [601].handle = objc_getClass ("MPSImageAreaMin");
	__xamarin_class_map [602].handle = objc_getClass ("MPSImageBilinearScale");
	__xamarin_class_map [603].handle = objc_getClass ("MPSImageBox");
	__xamarin_class_map [604].handle = objc_getClass ("MPSImageConvolution");
	__xamarin_class_map [605].handle = objc_getClass ("MPSImageCopyToMatrix");
	__xamarin_class_map [606].handle = objc_getClass ("MPSImageDescriptor");
	__xamarin_class_map [607].handle = objc_getClass ("MPSImageDivide");
	__xamarin_class_map [608].handle = objc_getClass ("MPSImageEuclideanDistanceTransform");
	__xamarin_class_map [609].handle = objc_getClass ("MPSImageFindKeypoints");
	__xamarin_class_map [610].handle = objc_getClass ("MPSImageGaussianBlur");
	__xamarin_class_map [611].handle = objc_getClass ("MPSImageGuidedFilter");
	__xamarin_class_map [612].handle = objc_getClass ("MPSImageHistogram");
	__xamarin_class_map [613].handle = objc_getClass ("MPSImageHistogramEqualization");
	__xamarin_class_map [614].handle = objc_getClass ("MPSImageHistogramSpecification");
	__xamarin_class_map [615].handle = objc_getClass ("MPSImageIntegral");
	__xamarin_class_map [616].handle = objc_getClass ("MPSImageIntegralOfSquares");
	__xamarin_class_map [617].handle = objc_getClass ("MPSImageLanczosScale");
	__xamarin_class_map [618].handle = objc_getClass ("MPSImageLaplacian");
	__xamarin_class_map [619].handle = objc_getClass ("MPSImageMedian");
	__xamarin_class_map [620].handle = objc_getClass ("MPSImageMultiply");
	__xamarin_class_map [621].handle = objc_getClass ("MPSImageNormalizedHistogram");
	__xamarin_class_map [622].handle = objc_getClass ("MPSImageReduceUnary");
	__xamarin_class_map [623].handle = objc_getClass ("MPSImageReduceColumnMax");
	__xamarin_class_map [624].handle = objc_getClass ("MPSImageReduceColumnMean");
	__xamarin_class_map [625].handle = objc_getClass ("MPSImageReduceColumnMin");
	__xamarin_class_map [626].handle = objc_getClass ("MPSImageReduceColumnSum");
	__xamarin_class_map [627].handle = objc_getClass ("MPSImageReduceRowMax");
	__xamarin_class_map [628].handle = objc_getClass ("MPSImageReduceRowMean");
	__xamarin_class_map [629].handle = objc_getClass ("MPSImageReduceRowMin");
	__xamarin_class_map [630].handle = objc_getClass ("MPSImageReduceRowSum");
	__xamarin_class_map [631].handle = objc_getClass ("MPSImageStatisticsMean");
	__xamarin_class_map [632].handle = objc_getClass ("MPSImageStatisticsMeanAndVariance");
	__xamarin_class_map [633].handle = objc_getClass ("MPSImageStatisticsMinAndMax");
	__xamarin_class_map [634].handle = objc_getClass ("MPSImageSubtract");
	__xamarin_class_map [635].handle = objc_getClass ("MPSImageTent");
	__xamarin_class_map [636].handle = objc_getClass ("MPSImageTranspose");
	__xamarin_class_map [637].handle = objc_getClass ("MPSAccelerationStructure");
	__xamarin_class_map [638].handle = objc_getClass ("MPSInstanceAccelerationStructure");
	__xamarin_class_map [639].handle = objc_getClass ("NSCoder");
	__xamarin_class_map [640].handle = objc_getClass ("NSKeyedUnarchiver");
	__xamarin_class_map [641].handle = objc_getClass ("MPSKeyedUnarchiver");
	__xamarin_class_map [642].handle = objc_getClass ("MPSLSTMDescriptor");
	__xamarin_class_map [643].handle = objc_getClass ("MPSMatrix");
	__xamarin_class_map [644].handle = objc_getClass ("MPSMatrixUnaryKernel");
	__xamarin_class_map [645].handle = objc_getClass ("MPSMatrixBatchNormalization");
	__xamarin_class_map [646].handle = objc_getClass ("MPSMatrixBinaryKernel");
	__xamarin_class_map [647].handle = objc_getClass ("MPSMatrixBatchNormalizationGradient");
	__xamarin_class_map [648].handle = objc_getClass ("MPSMatrixCopy");
	__xamarin_class_map [649].handle = objc_getClass ("MPSMatrixCopyDescriptor");
	__xamarin_class_map [650].handle = objc_getClass ("MPSMatrixCopyToImage");
	__xamarin_class_map [651].handle = objc_getClass ("MPSMatrixDecompositionCholesky");
	__xamarin_class_map [652].handle = objc_getClass ("MPSMatrixDecompositionLU");
	__xamarin_class_map [653].handle = objc_getClass ("MPSMatrixDescriptor");
	__xamarin_class_map [654].handle = objc_getClass ("MPSMatrixFindTopK");
	__xamarin_class_map [655].handle = objc_getClass ("MPSMatrixFullyConnected");
	__xamarin_class_map [656].handle = objc_getClass ("MPSMatrixFullyConnectedGradient");
	__xamarin_class_map [657].handle = objc_getClass ("MPSMatrixSoftMax");
	__xamarin_class_map [658].handle = objc_getClass ("MPSMatrixLogSoftMax");
	__xamarin_class_map [659].handle = objc_getClass ("MPSMatrixSoftMaxGradient");
	__xamarin_class_map [660].handle = objc_getClass ("MPSMatrixLogSoftMaxGradient");
	__xamarin_class_map [661].handle = objc_getClass ("MPSMatrixMultiplication");
	__xamarin_class_map [662].handle = objc_getClass ("MPSMatrixNeuron");
	__xamarin_class_map [663].handle = objc_getClass ("MPSMatrixNeuronGradient");
	__xamarin_class_map [664].handle = objc_getClass ("MPSMatrixSolveCholesky");
	__xamarin_class_map [665].handle = objc_getClass ("MPSMatrixSolveLU");
	__xamarin_class_map [666].handle = objc_getClass ("MPSMatrixSolveTriangular");
	__xamarin_class_map [667].handle = objc_getClass ("MPSMatrixSum");
	__xamarin_class_map [668].handle = objc_getClass ("MPSMatrixVectorMultiplication");
	__xamarin_class_map [669].handle = objc_getClass ("MPSNNArithmeticGradientNode");
	__xamarin_class_map [670].handle = objc_getClass ("MPSNNAdditionGradientNode");
	__xamarin_class_map [671].handle = objc_getClass ("MPSNNBinaryArithmeticNode");
	__xamarin_class_map [672].handle = objc_getClass ("MPSNNAdditionNode");
	__xamarin_class_map [673].handle = objc_getClass ("MPSNNBinaryGradientStateNode");
	__xamarin_class_map [674].handle = objc_getClass ("MPSNNArithmeticGradientStateNode");
	__xamarin_class_map [675].handle = objc_getClass ("MPSNNScaleNode");
	__xamarin_class_map [676].handle = objc_getClass ("MPSNNBilinearScaleNode");
	__xamarin_class_map [677].handle = objc_getClass ("MPSNNCompare");
	__xamarin_class_map [678].handle = objc_getClass ("MPSNNComparisonNode");
	__xamarin_class_map [679].handle = objc_getClass ("MPSNNConcatenationGradientNode");
	__xamarin_class_map [680].handle = objc_getClass ("MPSNNConcatenationNode");
	__xamarin_class_map [681].handle = objc_getClass ("MPSNNCropAndResizeBilinear");
	__xamarin_class_map [682].handle = objc_getClass ("MPSNNDefaultPadding");
	__xamarin_class_map [683].handle = objc_getClass ("MPSNNDivisionNode");
	__xamarin_class_map [684].handle = objc_getClass ("MPSNNImageNode");
	__xamarin_class_map [685].handle = objc_getClass ("MPSNNLabelsNode");
	__xamarin_class_map [686].handle = objc_getClass ("MPSNNLanczosScaleNode");
	__xamarin_class_map [687].handle = objc_getClass ("MPSNNMultiplicationGradientNode");
	__xamarin_class_map [688].handle = objc_getClass ("MPSNNMultiplicationNode");
	__xamarin_class_map [689].handle = objc_getClass ("MPSNNNeuronDescriptor");
	__xamarin_class_map [690].handle = objc_getClass ("MPSNNOptimizer");
	__xamarin_class_map [691].handle = objc_getClass ("MPSNNOptimizerAdam");
	__xamarin_class_map [692].handle = objc_getClass ("MPSNNOptimizerDescriptor");
	__xamarin_class_map [693].handle = objc_getClass ("MPSNNOptimizerRMSProp");
	__xamarin_class_map [694].handle = objc_getClass ("MPSNNOptimizerStochasticGradientDescent");
	__xamarin_class_map [695].handle = objc_getClass ("MPSNNPad");
	__xamarin_class_map [696].handle = objc_getClass ("MPSNNPadGradient");
	__xamarin_class_map [697].handle = objc_getClass ("MPSNNPadGradientNode");
	__xamarin_class_map [698].handle = objc_getClass ("MPSNNPadNode");
	__xamarin_class_map [699].handle = objc_getClass ("MPSNNReduceBinary");
	__xamarin_class_map [700].handle = objc_getClass ("MPSNNReduceUnary");
	__xamarin_class_map [701].handle = objc_getClass ("MPSNNReduceColumnMax");
	__xamarin_class_map [702].handle = objc_getClass ("MPSNNReduceColumnMean");
	__xamarin_class_map [703].handle = objc_getClass ("MPSNNReduceColumnMin");
	__xamarin_class_map [704].handle = objc_getClass ("MPSNNReduceColumnSum");
	__xamarin_class_map [705].handle = objc_getClass ("MPSNNReduceFeatureChannelsAndWeightsMean");
	__xamarin_class_map [706].handle = objc_getClass ("MPSNNReduceFeatureChannelsAndWeightsSum");
	__xamarin_class_map [707].handle = objc_getClass ("MPSNNReduceFeatureChannelsArgumentMax");
	__xamarin_class_map [708].handle = objc_getClass ("MPSNNReduceFeatureChannelsArgumentMin");
	__xamarin_class_map [709].handle = objc_getClass ("MPSNNReduceFeatureChannelsMax");
	__xamarin_class_map [710].handle = objc_getClass ("MPSNNReduceFeatureChannelsMean");
	__xamarin_class_map [711].handle = objc_getClass ("MPSNNReduceFeatureChannelsMin");
	__xamarin_class_map [712].handle = objc_getClass ("MPSNNReduceFeatureChannelsSum");
	__xamarin_class_map [713].handle = objc_getClass ("MPSNNReduceRowMax");
	__xamarin_class_map [714].handle = objc_getClass ("MPSNNReduceRowMean");
	__xamarin_class_map [715].handle = objc_getClass ("MPSNNReduceRowMin");
	__xamarin_class_map [716].handle = objc_getClass ("MPSNNReduceRowSum");
	__xamarin_class_map [717].handle = objc_getClass ("MPSNNUnaryReductionNode");
	__xamarin_class_map [718].handle = objc_getClass ("MPSNNReductionColumnMaxNode");
	__xamarin_class_map [719].handle = objc_getClass ("MPSNNReductionColumnMeanNode");
	__xamarin_class_map [720].handle = objc_getClass ("MPSNNReductionColumnMinNode");
	__xamarin_class_map [721].handle = objc_getClass ("MPSNNReductionColumnSumNode");
	__xamarin_class_map [722].handle = objc_getClass ("MPSNNReductionFeatureChannelsArgumentMaxNode");
	__xamarin_class_map [723].handle = objc_getClass ("MPSNNReductionFeatureChannelsArgumentMinNode");
	__xamarin_class_map [724].handle = objc_getClass ("MPSNNReductionFeatureChannelsMaxNode");
	__xamarin_class_map [725].handle = objc_getClass ("MPSNNReductionFeatureChannelsMeanNode");
	__xamarin_class_map [726].handle = objc_getClass ("MPSNNReductionFeatureChannelsMinNode");
	__xamarin_class_map [727].handle = objc_getClass ("MPSNNReductionFeatureChannelsSumNode");
	__xamarin_class_map [728].handle = objc_getClass ("MPSNNReductionRowMaxNode");
	__xamarin_class_map [729].handle = objc_getClass ("MPSNNReductionRowMeanNode");
	__xamarin_class_map [730].handle = objc_getClass ("MPSNNReductionRowMinNode");
	__xamarin_class_map [731].handle = objc_getClass ("MPSNNReductionRowSumNode");
	__xamarin_class_map [732].handle = objc_getClass ("MPSNNReductionSpatialMeanGradientNode");
	__xamarin_class_map [733].handle = objc_getClass ("MPSNNReductionSpatialMeanNode");
	__xamarin_class_map [734].handle = objc_getClass ("MPSNNReshape");
	__xamarin_class_map [735].handle = objc_getClass ("MPSNNReshapeGradient");
	__xamarin_class_map [736].handle = objc_getClass ("MPSNNReshapeGradientNode");
	__xamarin_class_map [737].handle = objc_getClass ("MPSNNReshapeNode");
	__xamarin_class_map [738].handle = objc_getClass ("MPSNNResizeBilinear");
	__xamarin_class_map [739].handle = objc_getClass ("MPSNNSlice");
	__xamarin_class_map [740].handle = objc_getClass ("MPSNNSubtractionGradientNode");
	__xamarin_class_map [741].handle = objc_getClass ("MPSNNSubtractionNode");
	__xamarin_class_map [742].handle = objc_getClass ("MPSRayIntersector");
	__xamarin_class_map [743].handle = objc_getClass ("MPSRNNImageInferenceLayer");
	__xamarin_class_map [744].handle = objc_getClass ("MPSRNNMatrixInferenceLayer");
	__xamarin_class_map [745].handle = objc_getClass ("MPSRNNMatrixTrainingLayer");
	__xamarin_class_map [746].handle = objc_getClass ("MPSRNNMatrixTrainingState");
	__xamarin_class_map [747].handle = objc_getClass ("MPSRNNRecurrentImageState");
	__xamarin_class_map [748].handle = objc_getClass ("MPSRNNRecurrentMatrixState");
	__xamarin_class_map [749].handle = objc_getClass ("MPSRNNSingleGateDescriptor");
	__xamarin_class_map [750].handle = objc_getClass ("MPSTemporaryImage");
	__xamarin_class_map [751].handle = objc_getClass ("MPSTemporaryMatrix");
	__xamarin_class_map [752].handle = objc_getClass ("MPSVector");
	__xamarin_class_map [753].handle = objc_getClass ("MPSTemporaryVector");
	__xamarin_class_map [754].handle = objc_getClass ("MPSTriangleAccelerationStructure");
	__xamarin_class_map [755].handle = objc_getClass ("MPSVectorDescriptor");
	__xamarin_class_map [756].handle = objc_getClass ("MTKMesh");
	__xamarin_class_map [757].handle = objc_getClass ("MTKMeshBufferAllocator");
	__xamarin_class_map [758].handle = objc_getClass ("MTKMeshBuffer");
	__xamarin_class_map [759].handle = objc_getClass ("MTKSubmesh");
	__xamarin_class_map [760].handle = objc_getClass ("MTKView");
	__xamarin_class_map [761].handle = objc_getClass ("MTKViewDelegate");
	__xamarin_class_map [762].handle = objc_getClass ("MTLSharedTextureHandle");
	__xamarin_class_map [763].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [764].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptorArray");
	__xamarin_class_map [765].handle = objc_getClass ("MTLVertexAttributeDescriptorArray");
	__xamarin_class_map [766].handle = objc_getClass ("MTLVertexBufferLayoutDescriptorArray");
	__xamarin_class_map [767].handle = objc_getClass ("MTLBufferLayoutDescriptorArray");
	__xamarin_class_map [768].handle = objc_getClass ("MTLAttributeDescriptorArray");
	__xamarin_class_map [769].handle = objc_getClass ("MTLPipelineBufferDescriptorArray");
	__xamarin_class_map [770].handle = objc_getClass ("MTLRenderPassDescriptor");
	__xamarin_class_map [771].handle = objc_getClass ("MTLVertexDescriptor");
	__xamarin_class_map [772].handle = objc_getClass ("MTLArgument");
	__xamarin_class_map [773].handle = objc_getClass ("MTLArgumentDescriptor");
	__xamarin_class_map [774].handle = objc_getClass ("MTLType");
	__xamarin_class_map [775].handle = objc_getClass ("MTLArrayType");
	__xamarin_class_map [776].handle = objc_getClass ("MTLAttribute");
	__xamarin_class_map [777].handle = objc_getClass ("MTLAttributeDescriptor");
	__xamarin_class_map [778].handle = objc_getClass ("MTLBufferLayoutDescriptor");
	__xamarin_class_map [779].handle = objc_getClass ("MTLCaptureDescriptor");
	__xamarin_class_map [780].handle = objc_getClass ("MTLCaptureManager");
	__xamarin_class_map [781].handle = objc_getClass ("Xamarin_Mac__Metal_MTLCaptureScope");
	__xamarin_class_map [782].handle = objc_getClass ("MTLCompileOptions");
	__xamarin_class_map [783].handle = objc_getClass ("MTLComputePipelineDescriptor");
	__xamarin_class_map [784].handle = objc_getClass ("MTLComputePipelineReflection");
	__xamarin_class_map [785].handle = objc_getClass ("MTLCounterSampleBufferDescriptor");
	__xamarin_class_map [786].handle = objc_getClass ("MTLDepthStencilDescriptor");
	__xamarin_class_map [787].handle = objc_getClass ("MTLDrawable");
	__xamarin_class_map [788].handle = objc_getClass ("MTLFunctionConstant");
	__xamarin_class_map [789].handle = objc_getClass ("MTLFunctionConstantValues");
	__xamarin_class_map [790].handle = objc_getClass ("MTLHeapDescriptor");
	__xamarin_class_map [791].handle = objc_getClass ("MTLIndirectCommandBufferDescriptor");
	__xamarin_class_map [792].handle = objc_getClass ("MTLPipelineBufferDescriptor");
	__xamarin_class_map [793].handle = objc_getClass ("MTLPointerType");
	__xamarin_class_map [794].handle = objc_getClass ("MTLRenderPassAttachmentDescriptor");
	__xamarin_class_map [795].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptor");
	__xamarin_class_map [796].handle = objc_getClass ("MTLRenderPassDepthAttachmentDescriptor");
	__xamarin_class_map [797].handle = objc_getClass ("MTLRenderPassStencilAttachmentDescriptor");
	__xamarin_class_map [798].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [799].handle = objc_getClass ("MTLRenderPipelineDescriptor");
	__xamarin_class_map [800].handle = objc_getClass ("MTLRenderPipelineReflection");
	__xamarin_class_map [801].handle = objc_getClass ("MTLSamplerDescriptor");
	__xamarin_class_map [802].handle = objc_getClass ("MTLSharedEventHandle");
	__xamarin_class_map [803].handle = objc_getClass ("MTLSharedEventListener");
	__xamarin_class_map [804].handle = objc_getClass ("MTLStageInputOutputDescriptor");
	__xamarin_class_map [805].handle = objc_getClass ("MTLStencilDescriptor");
	__xamarin_class_map [806].handle = objc_getClass ("MTLStructMember");
	__xamarin_class_map [807].handle = objc_getClass ("MTLStructType");
	__xamarin_class_map [808].handle = objc_getClass ("MTLTextureDescriptor");
	__xamarin_class_map [809].handle = objc_getClass ("MTLTextureReferenceType");
	__xamarin_class_map [810].handle = objc_getClass ("MTLVertexAttribute");
	__xamarin_class_map [811].handle = objc_getClass ("MTLVertexAttributeDescriptor");
	__xamarin_class_map [812].handle = objc_getClass ("MTLVertexBufferLayoutDescriptor");
	__xamarin_class_map [813].handle = objc_getClass ("MPNowPlayingInfoCenter");
	__xamarin_class_map [814].handle = objc_getClass ("MPRemoteCommandEvent");
	__xamarin_class_map [815].handle = objc_getClass ("MPChangeLanguageOptionCommandEvent");
	__xamarin_class_map [816].handle = objc_getClass ("MPRemoteCommand");
	__xamarin_class_map [817].handle = objc_getClass ("MPChangePlaybackPositionCommand");
	__xamarin_class_map [818].handle = objc_getClass ("MPChangePlaybackPositionCommandEvent");
	__xamarin_class_map [819].handle = objc_getClass ("MPChangePlaybackRateCommand");
	__xamarin_class_map [820].handle = objc_getClass ("MPChangePlaybackRateCommandEvent");
	__xamarin_class_map [821].handle = objc_getClass ("MPChangeRepeatModeCommand");
	__xamarin_class_map [822].handle = objc_getClass ("MPChangeRepeatModeCommandEvent");
	__xamarin_class_map [823].handle = objc_getClass ("MPChangeShuffleModeCommand");
	__xamarin_class_map [824].handle = objc_getClass ("MPChangeShuffleModeCommandEvent");
	__xamarin_class_map [825].handle = objc_getClass ("MPContentItem");
	__xamarin_class_map [826].handle = objc_getClass ("MPFeedbackCommand");
	__xamarin_class_map [827].handle = objc_getClass ("MPFeedbackCommandEvent");
	__xamarin_class_map [828].handle = objc_getClass ("MPMediaItem");
	__xamarin_class_map [829].handle = objc_getClass ("MPMediaItemArtwork");
	__xamarin_class_map [830].handle = objc_getClass ("MPNowPlayingInfoLanguageOption");
	__xamarin_class_map [831].handle = objc_getClass ("MPNowPlayingInfoLanguageOptionGroup");
	__xamarin_class_map [832].handle = objc_getClass ("MPRatingCommand");
	__xamarin_class_map [833].handle = objc_getClass ("MPRatingCommandEvent");
	__xamarin_class_map [834].handle = objc_getClass ("MPRemoteCommandCenter");
	__xamarin_class_map [835].handle = objc_getClass ("MPSeekCommandEvent");
	__xamarin_class_map [836].handle = objc_getClass ("MPSkipIntervalCommandEvent");
	__xamarin_class_map [837].handle = objc_getClass ("MKShape");
	__xamarin_class_map [838].handle = objc_getClass ("MKMultiPoint");
	__xamarin_class_map [839].handle = objc_getClass ("MKPolyline");
	__xamarin_class_map [840].handle = objc_getClass ("MKGeodesicPolyline");
	__xamarin_class_map [841].handle = objc_getClass ("MKMapItem");
	__xamarin_class_map [842].handle = objc_getClass ("MKPolygon");
	__xamarin_class_map [843].handle = objc_getClass ("MKAnnotation");
	__xamarin_class_map [844].handle = objc_getClass ("MKAnnotationView");
	__xamarin_class_map [845].handle = objc_getClass ("MKCircle");
	__xamarin_class_map [846].handle = objc_getClass ("MKOverlayRenderer");
	__xamarin_class_map [847].handle = objc_getClass ("MKOverlayPathRenderer");
	__xamarin_class_map [848].handle = objc_getClass ("MKCircleRenderer");
	__xamarin_class_map [849].handle = objc_getClass ("MKClusterAnnotation");
	__xamarin_class_map [850].handle = objc_getClass ("MKDirectionsRequest");
	__xamarin_class_map [851].handle = objc_getClass ("MKDirectionsResponse");
	__xamarin_class_map [852].handle = objc_getClass ("NSFormatter");
	__xamarin_class_map [853].handle = objc_getClass ("MKDistanceFormatter");
	__xamarin_class_map [854].handle = objc_getClass ("MKETAResponse");
	__xamarin_class_map [855].handle = objc_getClass ("MKGeoJSONDecoder");
	__xamarin_class_map [856].handle = objc_getClass ("MKGeoJSONFeature");
	__xamarin_class_map [857].handle = objc_getClass ("MKLocalSearchCompleter");
	__xamarin_class_map [858].handle = objc_getClass ("MKLocalSearchCompleterDelegate");
	__xamarin_class_map [859].handle = objc_getClass ("MKLocalSearchCompletion");
	__xamarin_class_map [860].handle = objc_getClass ("MKLocalSearchRequest");
	__xamarin_class_map [861].handle = objc_getClass ("MKLocalSearchResponse");
	__xamarin_class_map [862].handle = objc_getClass ("MKMapCamera");
	__xamarin_class_map [863].handle = objc_getClass ("MKMapCameraBoundary");
	__xamarin_class_map [864].handle = objc_getClass ("MKMapCameraZoomRange");
	__xamarin_class_map [865].handle = objc_getClass ("MKMapSnapshot");
	__xamarin_class_map [866].handle = objc_getClass ("MKMapSnapshotOptions");
	__xamarin_class_map [867].handle = objc_getClass ("MKMapViewDelegate");
	__xamarin_class_map [868].handle = objc_getClass ("MKMultiPolygon");
	__xamarin_class_map [869].handle = objc_getClass ("MKMultiPolygonRenderer");
	__xamarin_class_map [870].handle = objc_getClass ("MKMultiPolyline");
	__xamarin_class_map [871].handle = objc_getClass ("MKMultiPolylineRenderer");
	__xamarin_class_map [872].handle = objc_getClass ("MKOverlay");
	__xamarin_class_map [873].handle = objc_getClass ("MKPinAnnotationView");
	__xamarin_class_map [874].handle = objc_getClass ("CLPlacemark");
	__xamarin_class_map [875].handle = objc_getClass ("MKPlacemark");
	__xamarin_class_map [876].handle = objc_getClass ("MKPointAnnotation");
	__xamarin_class_map [877].handle = objc_getClass ("MKPolygonRenderer");
	__xamarin_class_map [878].handle = objc_getClass ("MKPolylineRenderer");
	__xamarin_class_map [879].handle = objc_getClass ("MKRoute");
	__xamarin_class_map [880].handle = objc_getClass ("MKRouteStep");
	__xamarin_class_map [881].handle = objc_getClass ("MKTileOverlay");
	__xamarin_class_map [882].handle = objc_getClass ("MKTileOverlayRenderer");
	__xamarin_class_map [883].handle = objc_getClass ("MKUserLocation");
	__xamarin_class_map [884].handle = objc_getClass ("JSContext");
	__xamarin_class_map [885].handle = objc_getClass ("JSValue");
	__xamarin_class_map [886].handle = objc_getClass ("Xamarin_Mac__JavaScriptCore_JSExport");
	__xamarin_class_map [887].handle = objc_getClass ("JSManagedValue");
	__xamarin_class_map [888].handle = objc_getClass ("JSVirtualMachine");
	__xamarin_class_map [889].handle = objc_getClass ("ITLibrary");
	__xamarin_class_map [890].handle = objc_getClass ("ITLibAlbum");
	__xamarin_class_map [891].handle = objc_getClass ("ITLibArtist");
	__xamarin_class_map [892].handle = objc_getClass ("ITLibArtwork");
	__xamarin_class_map [893].handle = objc_getClass ("ITLibMediaEntity");
	__xamarin_class_map [894].handle = objc_getClass ("ITLibMediaItem");
	__xamarin_class_map [895].handle = objc_getClass ("ITLibMediaItemVideoInfo");
	__xamarin_class_map [896].handle = objc_getClass ("ITLibPlaylist");
	__xamarin_class_map [897].handle = objc_getClass ("IOSurface");
	__xamarin_class_map [898].handle = objc_getClass ("INCallRecord");
	__xamarin_class_map [899].handle = objc_getClass ("INIntentResolutionResult");
	__xamarin_class_map [900].handle = objc_getClass ("INCallRecordTypeResolutionResult");
	__xamarin_class_map [901].handle = objc_getClass ("INMessageAttributeOptionsResolutionResult");
	__xamarin_class_map [902].handle = objc_getClass ("INMessageAttributeResolutionResult");
	__xamarin_class_map [903].handle = objc_getClass ("INIntent");
	__xamarin_class_map [904].handle = objc_getClass ("INSearchCallHistoryIntent");
	__xamarin_class_map [905].handle = objc_getClass ("INSpeakableString");
	__xamarin_class_map [906].handle = objc_getClass ("INCallDestinationTypeResolutionResult");
	__xamarin_class_map [907].handle = objc_getClass ("INCallRecordTypeOptionsResolutionResult");
	__xamarin_class_map [908].handle = objc_getClass ("INDateComponentsRange");
	__xamarin_class_map [909].handle = objc_getClass ("INDateComponentsRangeResolutionResult");
	__xamarin_class_map [910].handle = objc_getClass ("INImage");
	__xamarin_class_map [911].handle = objc_getClass ("INIntentResponse");
	__xamarin_class_map [912].handle = objc_getClass ("INMessage");
	__xamarin_class_map [913].handle = objc_getClass ("INParameter");
	__xamarin_class_map [914].handle = objc_getClass ("INPerson");
	__xamarin_class_map [915].handle = objc_getClass ("INPersonHandle");
	__xamarin_class_map [916].handle = objc_getClass ("INPersonResolutionResult");
	__xamarin_class_map [917].handle = objc_getClass ("INPlacemarkResolutionResult");
	__xamarin_class_map [918].handle = objc_getClass ("INRecurrenceRule");
	__xamarin_class_map [919].handle = objc_getClass ("INSearchCallHistoryIntentResponse");
	__xamarin_class_map [920].handle = objc_getClass ("INSearchForMessagesIntent");
	__xamarin_class_map [921].handle = objc_getClass ("INSearchForMessagesIntentResponse");
	__xamarin_class_map [922].handle = objc_getClass ("INSendMessageIntent");
	__xamarin_class_map [923].handle = objc_getClass ("INSendMessageIntentResponse");
	__xamarin_class_map [924].handle = objc_getClass ("INSendMessageRecipientResolutionResult");
	__xamarin_class_map [925].handle = objc_getClass ("INSpeakableStringResolutionResult");
	__xamarin_class_map [926].handle = objc_getClass ("INStartAudioCallIntent");
	__xamarin_class_map [927].handle = objc_getClass ("INStartAudioCallIntentResponse");
	__xamarin_class_map [928].handle = objc_getClass ("INStartVideoCallIntent");
	__xamarin_class_map [929].handle = objc_getClass ("INStartVideoCallIntentResponse");
	__xamarin_class_map [930].handle = objc_getClass ("INStringResolutionResult");
	__xamarin_class_map [931].handle = objc_getClass ("GLKMesh");
	__xamarin_class_map [932].handle = objc_getClass ("GLKBaseEffect");
	__xamarin_class_map [933].handle = objc_getClass ("GLKEffectProperty");
	__xamarin_class_map [934].handle = objc_getClass ("GLKEffectPropertyFog");
	__xamarin_class_map [935].handle = objc_getClass ("GLKEffectPropertyLight");
	__xamarin_class_map [936].handle = objc_getClass ("GLKEffectPropertyMaterial");
	__xamarin_class_map [937].handle = objc_getClass ("GLKEffectPropertyTexture");
	__xamarin_class_map [938].handle = objc_getClass ("GLKEffectPropertyTransform");
	__xamarin_class_map [939].handle = objc_getClass ("GLKMeshBuffer");
	__xamarin_class_map [940].handle = objc_getClass ("GLKMeshBufferAllocator");
	__xamarin_class_map [941].handle = objc_getClass ("GLKNamedEffect");
	__xamarin_class_map [942].handle = objc_getClass ("GLKReflectionMapEffect");
	__xamarin_class_map [943].handle = objc_getClass ("GLKSkyboxEffect");
	__xamarin_class_map [944].handle = objc_getClass ("GLKSubmesh");
	__xamarin_class_map [945].handle = objc_getClass ("GLKTextureInfo");
	__xamarin_class_map [946].handle = objc_getClass ("GKBehavior");
	__xamarin_class_map [947].handle = objc_getClass ("GKComponentSystem");
	__xamarin_class_map [948].handle = objc_getClass ("GKCompositeBehavior");
	__xamarin_class_map [949].handle = objc_getClass ("GKEntity");
	__xamarin_class_map [950].handle = objc_getClass ("GKGraph");
	__xamarin_class_map [951].handle = objc_getClass ("GKGridGraph");
	__xamarin_class_map [952].handle = objc_getClass ("GKObstacleGraph");
	__xamarin_class_map [953].handle = objc_getClass ("GKPath");
	__xamarin_class_map [954].handle = objc_getClass ("GKObstacle");
	__xamarin_class_map [955].handle = objc_getClass ("GKPolygonObstacle");
	__xamarin_class_map [956].handle = objc_getClass ("GKState");
	__xamarin_class_map [957].handle = objc_getClass ("GKStateMachine");
	__xamarin_class_map [958].handle = objc_getClass ("GKComponent");
	__xamarin_class_map [959].handle = objc_getClass ("GKAgent");
	__xamarin_class_map [960].handle = objc_getClass ("GKAgent2D");
	__xamarin_class_map [961].handle = objc_getClass ("GKAgent3D");
	__xamarin_class_map [962].handle = objc_getClass ("GKAgentDelegate");
	__xamarin_class_map [963].handle = objc_getClass ("GKRandomSource");
	__xamarin_class_map [964].handle = objc_getClass ("GKARC4RandomSource");
	__xamarin_class_map [965].handle = objc_getClass ("GKNoiseSource");
	__xamarin_class_map [966].handle = objc_getClass ("GKCoherentNoiseSource");
	__xamarin_class_map [967].handle = objc_getClass ("GKBillowNoiseSource");
	__xamarin_class_map [968].handle = objc_getClass ("GKCheckerboardNoiseSource");
	__xamarin_class_map [969].handle = objc_getClass ("GKCircleObstacle");
	__xamarin_class_map [970].handle = objc_getClass ("GKConstantNoiseSource");
	__xamarin_class_map [971].handle = objc_getClass ("GKCylindersNoiseSource");
	__xamarin_class_map [972].handle = objc_getClass ("GKDecisionNode");
	__xamarin_class_map [973].handle = objc_getClass ("GKDecisionTree");
	__xamarin_class_map [974].handle = objc_getClass ("GKRandomDistribution");
	__xamarin_class_map [975].handle = objc_getClass ("GKGaussianDistribution");
	__xamarin_class_map [976].handle = objc_getClass ("GKGoal");
	__xamarin_class_map [977].handle = objc_getClass ("GKGraphNode");
	__xamarin_class_map [978].handle = objc_getClass ("GKGraphNode2D");
	__xamarin_class_map [979].handle = objc_getClass ("GKGraphNode3D");
	__xamarin_class_map [980].handle = objc_getClass ("GKGridGraphNode");
	__xamarin_class_map [981].handle = objc_getClass ("GKLinearCongruentialRandomSource");
	__xamarin_class_map [982].handle = objc_getClass ("GKMersenneTwisterRandomSource");
	__xamarin_class_map [983].handle = objc_getClass ("GKMeshGraph");
	__xamarin_class_map [984].handle = objc_getClass ("GKMinmaxStrategist");
	__xamarin_class_map [985].handle = objc_getClass ("GKMonteCarloStrategist");
	__xamarin_class_map [986].handle = objc_getClass ("GKNoise");
	__xamarin_class_map [987].handle = objc_getClass ("GKNoiseMap");
	__xamarin_class_map [988].handle = objc_getClass ("GKRule");
	__xamarin_class_map [989].handle = objc_getClass ("GKNSPredicateRule");
	__xamarin_class_map [990].handle = objc_getClass ("GKOctree");
	__xamarin_class_map [991].handle = objc_getClass ("GKOctreeNode");
	__xamarin_class_map [992].handle = objc_getClass ("GKPerlinNoiseSource");
	__xamarin_class_map [993].handle = objc_getClass ("GKQuadtree");
	__xamarin_class_map [994].handle = objc_getClass ("GKQuadtreeNode");
	__xamarin_class_map [995].handle = objc_getClass ("GKRidgedNoiseSource");
	__xamarin_class_map [996].handle = objc_getClass ("GKRTree");
	__xamarin_class_map [997].handle = objc_getClass ("GKRuleSystem");
	__xamarin_class_map [998].handle = objc_getClass ("GKScene");
	__xamarin_class_map [999].handle = objc_getClass ("GKSCNNodeComponent");
	__xamarin_class_map [1000].handle = objc_getClass ("GKShuffledDistribution");
	__xamarin_class_map [1001].handle = objc_getClass ("GKSKNodeComponent");
	__xamarin_class_map [1002].handle = objc_getClass ("GKSphereObstacle");
	__xamarin_class_map [1003].handle = objc_getClass ("GKSpheresNoiseSource");
	__xamarin_class_map [1004].handle = objc_getClass ("GKVoronoiNoiseSource");
	__xamarin_class_map [1005].handle = objc_getClass ("GCExtendedGamepad");
	__xamarin_class_map [1006].handle = objc_getClass ("GCExtendedGamepadSnapshot");
	__xamarin_class_map [1007].handle = objc_getClass ("GCGamepad");
	__xamarin_class_map [1008].handle = objc_getClass ("GCGamepadSnapshot");
	__xamarin_class_map [1009].handle = objc_getClass ("GCMicroGamepad");
	__xamarin_class_map [1010].handle = objc_getClass ("GCMicroGamepadSnapshot");
	__xamarin_class_map [1011].handle = objc_getClass ("GCControllerElement");
	__xamarin_class_map [1012].handle = objc_getClass ("GCControllerAxisInput");
	__xamarin_class_map [1013].handle = objc_getClass ("GCControllerButtonInput");
	__xamarin_class_map [1014].handle = objc_getClass ("GCControllerDirectionPad");
	__xamarin_class_map [1015].handle = objc_getClass ("GCEventViewController");
	__xamarin_class_map [1016].handle = objc_getClass ("GCMotion");
	__xamarin_class_map [1017].handle = objc_getClass ("EKObject");
	__xamarin_class_map [1018].handle = objc_getClass ("EKRecurrenceRule");
	__xamarin_class_map [1019].handle = objc_getClass ("EKRecurrenceDayOfWeek");
	__xamarin_class_map [1020].handle = objc_getClass ("EKCalendarItem");
	__xamarin_class_map [1021].handle = objc_getClass ("EKEvent");
	__xamarin_class_map [1022].handle = objc_getClass ("EKAlarm");
	__xamarin_class_map [1023].handle = objc_getClass ("EKReminder");
	__xamarin_class_map [1024].handle = objc_getClass ("EKCalendar");
	__xamarin_class_map [1025].handle = objc_getClass ("EKParticipant");
	__xamarin_class_map [1026].handle = objc_getClass ("EKRecurrenceEnd");
	__xamarin_class_map [1027].handle = objc_getClass ("EKSource");
	__xamarin_class_map [1028].handle = objc_getClass ("EKStructuredLocation");
	__xamarin_class_map [1029].handle = objc_getClass ("CWConfiguration");
	__xamarin_class_map [1030].handle = objc_getClass ("CW8021XProfile");
	__xamarin_class_map [1031].handle = objc_getClass ("CWChannel");
	__xamarin_class_map [1032].handle = objc_getClass ("CWEventDelegate");
	__xamarin_class_map [1033].handle = objc_getClass ("CWMutableConfiguration");
	__xamarin_class_map [1034].handle = objc_getClass ("CWNetworkProfile");
	__xamarin_class_map [1035].handle = objc_getClass ("CWMutableNetworkProfile");
	__xamarin_class_map [1036].handle = objc_getClass ("CWNetwork");
	__xamarin_class_map [1037].handle = objc_getClass ("CWWiFiClient");
	__xamarin_class_map [1038].handle = objc_getClass ("CWWirelessProfile");
	__xamarin_class_map [1039].handle = objc_getClass ("CSSearchableItemAttributeSet");
	__xamarin_class_map [1040].handle = objc_getClass ("CSCustomAttributeKey");
	__xamarin_class_map [1041].handle = objc_getClass ("CSIndexExtensionRequestHandler");
	__xamarin_class_map [1042].handle = objc_getClass ("NSString");
	__xamarin_class_map [1043].handle = objc_getClass ("CSLocalizedString");
	__xamarin_class_map [1044].handle = objc_getClass ("CSPerson");
	__xamarin_class_map [1045].handle = objc_getClass ("CSSearchableIndexDelegate");
	__xamarin_class_map [1046].handle = objc_getClass ("CSSearchableItem");
	__xamarin_class_map [1047].handle = objc_getClass ("CSSearchQuery");
	__xamarin_class_map [1048].handle = objc_getClass ("CMLogItem");
	__xamarin_class_map [1049].handle = objc_getClass ("CMAccelerometerData");
	__xamarin_class_map [1050].handle = objc_getClass ("CMAttitude");
	__xamarin_class_map [1051].handle = objc_getClass ("CMDeviceMotion");
	__xamarin_class_map [1052].handle = objc_getClass ("CMGyroData");
	__xamarin_class_map [1053].handle = objc_getClass ("CMMagnetometerData");
	__xamarin_class_map [1054].handle = objc_getClass ("CMPedometerData");
	__xamarin_class_map [1055].handle = objc_getClass ("CMPedometerEvent");
	__xamarin_class_map [1056].handle = objc_getClass ("CLHeading");
	__xamarin_class_map [1057].handle = objc_getClass ("CLLocation");
	__xamarin_class_map [1058].handle = objc_getClass ("CLRegion");
	__xamarin_class_map [1059].handle = objc_getClass ("CLCircularRegion");
	__xamarin_class_map [1060].handle = objc_getClass ("CLFloor");
	__xamarin_class_map [1061].handle = objc_getClass ("CLLocationManagerDelegate");
	__xamarin_class_map [1062].handle = objc_getClass ("CIColor");
	__xamarin_class_map [1063].handle = objc_getClass ("CIContext");
	__xamarin_class_map [1064].handle = objc_getClass ("CIDetector");
	__xamarin_class_map [1065].handle = objc_getClass ("CIFilter");
	__xamarin_class_map [1066].handle = objc_getClass ("CoreImage_CICmykHalftone");
	__xamarin_class_map [1067].handle = objc_getClass ("CoreImage_CICMYKHalftone");
	__xamarin_class_map [1068].handle = objc_getClass ("CIImage");
	__xamarin_class_map [1069].handle = objc_getClass ("CISampler");
	__xamarin_class_map [1070].handle = objc_getClass ("CIVector");
	__xamarin_class_map [1071].handle = objc_getClass ("CoreImage_CIAccordionFoldTransition");
	__xamarin_class_map [1072].handle = objc_getClass ("CoreImage_CICompositingFilter");
	__xamarin_class_map [1073].handle = objc_getClass ("CoreImage_CIAdditionCompositing");
	__xamarin_class_map [1074].handle = objc_getClass ("CoreImage_CIAffineFilter");
	__xamarin_class_map [1075].handle = objc_getClass ("CoreImage_CIAffineClamp");
	__xamarin_class_map [1076].handle = objc_getClass ("CoreImage_CIAffineTile");
	__xamarin_class_map [1077].handle = objc_getClass ("CoreImage_CIAffineTransform");
	__xamarin_class_map [1078].handle = objc_getClass ("CoreImage_CIReductionFilter");
	__xamarin_class_map [1079].handle = objc_getClass ("CoreImage_CIAreaAverage");
	__xamarin_class_map [1080].handle = objc_getClass ("CoreImage_CIAreaHistogram");
	__xamarin_class_map [1081].handle = objc_getClass ("CoreImage_CIAreaMaximum");
	__xamarin_class_map [1082].handle = objc_getClass ("CoreImage_CIAreaMaximumAlpha");
	__xamarin_class_map [1083].handle = objc_getClass ("CoreImage_CIAreaMinimum");
	__xamarin_class_map [1084].handle = objc_getClass ("CoreImage_CIAreaMinimumAlpha");
	__xamarin_class_map [1085].handle = objc_getClass ("CoreImage_CIAreaMinMax");
	__xamarin_class_map [1086].handle = objc_getClass ("CoreImage_CIAreaMinMaxRed");
	__xamarin_class_map [1087].handle = objc_getClass ("CoreImage_CIImageGenerator");
	__xamarin_class_map [1088].handle = objc_getClass ("CoreImage_CIAttributedTextImageGenerator");
	__xamarin_class_map [1089].handle = objc_getClass ("CIBarcodeDescriptor");
	__xamarin_class_map [1090].handle = objc_getClass ("CIAztecCodeDescriptor");
	__xamarin_class_map [1091].handle = objc_getClass ("CoreImage_CICodeGenerator");
	__xamarin_class_map [1092].handle = objc_getClass ("CoreImage_CIAztecCodeGenerator");
	__xamarin_class_map [1093].handle = objc_getClass ("CoreImage_CIBarcodeGenerator");
	__xamarin_class_map [1094].handle = objc_getClass ("CoreImage_CITransitionFilter");
	__xamarin_class_map [1095].handle = objc_getClass ("CoreImage_CIBarsSwipeTransition");
	__xamarin_class_map [1096].handle = objc_getClass ("CoreImage_CIBicubicScaleTransform");
	__xamarin_class_map [1097].handle = objc_getClass ("CoreImage_CIBlendFilter");
	__xamarin_class_map [1098].handle = objc_getClass ("CIKernel");
	__xamarin_class_map [1099].handle = objc_getClass ("CIColorKernel");
	__xamarin_class_map [1100].handle = objc_getClass ("CIBlendKernel");
	__xamarin_class_map [1101].handle = objc_getClass ("CoreImage_CIBlendWithMask");
	__xamarin_class_map [1102].handle = objc_getClass ("CoreImage_CIBlendWithAlphaMask");
	__xamarin_class_map [1103].handle = objc_getClass ("CoreImage_CIBlendWithBlueMask");
	__xamarin_class_map [1104].handle = objc_getClass ("CoreImage_CIBlendWithRedMask");
	__xamarin_class_map [1105].handle = objc_getClass ("CoreImage_CIBloom");
	__xamarin_class_map [1106].handle = objc_getClass ("CoreImage_CILinearBlur");
	__xamarin_class_map [1107].handle = objc_getClass ("CoreImage_CIBokehBlur");
	__xamarin_class_map [1108].handle = objc_getClass ("CoreImage_CIBoxBlur");
	__xamarin_class_map [1109].handle = objc_getClass ("CoreImage_CIDistortionFilter");
	__xamarin_class_map [1110].handle = objc_getClass ("CoreImage_CIBumpDistortion");
	__xamarin_class_map [1111].handle = objc_getClass ("CoreImage_CIBumpDistortionLinear");
	__xamarin_class_map [1112].handle = objc_getClass ("CoreImage_CICameraCalibrationLensCorrection");
	__xamarin_class_map [1113].handle = objc_getClass ("CoreImage_CICheckerboardGenerator");
	__xamarin_class_map [1114].handle = objc_getClass ("CoreImage_CICircleSplashDistortion");
	__xamarin_class_map [1115].handle = objc_getClass ("CoreImage_CIScreenFilter");
	__xamarin_class_map [1116].handle = objc_getClass ("CoreImage_CICircularScreen");
	__xamarin_class_map [1117].handle = objc_getClass ("CoreImage_CICircularWrap");
	__xamarin_class_map [1118].handle = objc_getClass ("CoreImage_CIClamp");
	__xamarin_class_map [1119].handle = objc_getClass ("CoreImage_CICode128BarcodeGenerator");
	__xamarin_class_map [1120].handle = objc_getClass ("CoreImage_CIColorBlendMode");
	__xamarin_class_map [1121].handle = objc_getClass ("CoreImage_CIColorBurnBlendMode");
	__xamarin_class_map [1122].handle = objc_getClass ("CoreImage_CIColorClamp");
	__xamarin_class_map [1123].handle = objc_getClass ("CoreImage_CIColorControls");
	__xamarin_class_map [1124].handle = objc_getClass ("CoreImage_CIColorCrossPolynomial");
	__xamarin_class_map [1125].handle = objc_getClass ("CoreImage_CIColorCube");
	__xamarin_class_map [1126].handle = objc_getClass ("CoreImage_CIColorCubesMixedWithMask");
	__xamarin_class_map [1127].handle = objc_getClass ("CoreImage_CIColorCubeWithColorSpace");
	__xamarin_class_map [1128].handle = objc_getClass ("CoreImage_CIColorCurves");
	__xamarin_class_map [1129].handle = objc_getClass ("CoreImage_CIColorDodgeBlendMode");
	__xamarin_class_map [1130].handle = objc_getClass ("CoreImage_CIColorInvert");
	__xamarin_class_map [1131].handle = objc_getClass ("CoreImage_CIColorMap");
	__xamarin_class_map [1132].handle = objc_getClass ("CoreImage_CIColorMatrix");
	__xamarin_class_map [1133].handle = objc_getClass ("CoreImage_CIColorMonochrome");
	__xamarin_class_map [1134].handle = objc_getClass ("CoreImage_CIColorPolynomial");
	__xamarin_class_map [1135].handle = objc_getClass ("CoreImage_CIColorPosterize");
	__xamarin_class_map [1136].handle = objc_getClass ("CoreImage_CIColumnAverage");
	__xamarin_class_map [1137].handle = objc_getClass ("CoreImage_CIComicEffect");
	__xamarin_class_map [1138].handle = objc_getClass ("CoreImage_CIConstantColorGenerator");
	__xamarin_class_map [1139].handle = objc_getClass ("CoreImage_CIConvolutionCore");
	__xamarin_class_map [1140].handle = objc_getClass ("CoreImage_CIConvolution3X3");
	__xamarin_class_map [1141].handle = objc_getClass ("CoreImage_CIConvolution5X5");
	__xamarin_class_map [1142].handle = objc_getClass ("CoreImage_CIConvolution7X7");
	__xamarin_class_map [1143].handle = objc_getClass ("CoreImage_CIConvolution9Horizontal");
	__xamarin_class_map [1144].handle = objc_getClass ("CoreImage_CIConvolution9Vertical");
	__xamarin_class_map [1145].handle = objc_getClass ("CoreImage_CICopyMachineTransition");
	__xamarin_class_map [1146].handle = objc_getClass ("CoreImage_CICoreMLModelFilter");
	__xamarin_class_map [1147].handle = objc_getClass ("CoreImage_CICrop");
	__xamarin_class_map [1148].handle = objc_getClass ("CoreImage_CICrystallize");
	__xamarin_class_map [1149].handle = objc_getClass ("CoreImage_CIDarkenBlendMode");
	__xamarin_class_map [1150].handle = objc_getClass ("CIDataMatrixCodeDescriptor");
	__xamarin_class_map [1151].handle = objc_getClass ("CoreImage_CIDepthBlurEffect");
	__xamarin_class_map [1152].handle = objc_getClass ("CoreImage_CIDepthDisparityConverter");
	__xamarin_class_map [1153].handle = objc_getClass ("CoreImage_CIDepthOfField");
	__xamarin_class_map [1154].handle = objc_getClass ("CoreImage_CIDepthToDisparity");
	__xamarin_class_map [1155].handle = objc_getClass ("CoreImage_CIDifferenceBlendMode");
	__xamarin_class_map [1156].handle = objc_getClass ("CoreImage_CIDiscBlur");
	__xamarin_class_map [1157].handle = objc_getClass ("CoreImage_CIDisintegrateWithMaskTransition");
	__xamarin_class_map [1158].handle = objc_getClass ("CoreImage_CIDisparityToDepth");
	__xamarin_class_map [1159].handle = objc_getClass ("CoreImage_CIDisplacementDistortion");
	__xamarin_class_map [1160].handle = objc_getClass ("CoreImage_CIDissolveTransition");
	__xamarin_class_map [1161].handle = objc_getClass ("CoreImage_CIDither");
	__xamarin_class_map [1162].handle = objc_getClass ("CoreImage_CIDivideBlendMode");
	__xamarin_class_map [1163].handle = objc_getClass ("CoreImage_CIDocumentEnhancer");
	__xamarin_class_map [1164].handle = objc_getClass ("CoreImage_CIDotScreen");
	__xamarin_class_map [1165].handle = objc_getClass ("CoreImage_CIDroste");
	__xamarin_class_map [1166].handle = objc_getClass ("CoreImage_CIEdgePreserveUpsampleFilter");
	__xamarin_class_map [1167].handle = objc_getClass ("CoreImage_CIEdges");
	__xamarin_class_map [1168].handle = objc_getClass ("CoreImage_CIEdgeWork");
	__xamarin_class_map [1169].handle = objc_getClass ("CoreImage_CITileFilter");
	__xamarin_class_map [1170].handle = objc_getClass ("CoreImage_CIEightfoldReflectedTile");
	__xamarin_class_map [1171].handle = objc_getClass ("CoreImage_CIExclusionBlendMode");
	__xamarin_class_map [1172].handle = objc_getClass ("CoreImage_CIExposureAdjust");
	__xamarin_class_map [1173].handle = objc_getClass ("CoreImage_CIFaceBalance");
	__xamarin_class_map [1174].handle = objc_getClass ("CIFeature");
	__xamarin_class_map [1175].handle = objc_getClass ("CIFaceFeature");
	__xamarin_class_map [1176].handle = objc_getClass ("CoreImage_CIFalseColor");
	__xamarin_class_map [1177].handle = objc_getClass ("CIFilterGenerator");
	__xamarin_class_map [1178].handle = objc_getClass ("CIFilterShape");
	__xamarin_class_map [1179].handle = objc_getClass ("CoreImage_CIFlashTransition");
	__xamarin_class_map [1180].handle = objc_getClass ("CoreImage_CIFourfoldReflectedTile");
	__xamarin_class_map [1181].handle = objc_getClass ("CoreImage_CIFourfoldRotatedTile");
	__xamarin_class_map [1182].handle = objc_getClass ("CoreImage_CIFourfoldTranslatedTile");
	__xamarin_class_map [1183].handle = objc_getClass ("CoreImage_CIGaborGradients");
	__xamarin_class_map [1184].handle = objc_getClass ("CoreImage_CIGammaAdjust");
	__xamarin_class_map [1185].handle = objc_getClass ("CoreImage_CIGaussianBlur");
	__xamarin_class_map [1186].handle = objc_getClass ("CoreImage_CIGaussianGradient");
	__xamarin_class_map [1187].handle = objc_getClass ("CoreImage_CIGlassDistortion");
	__xamarin_class_map [1188].handle = objc_getClass ("CoreImage_CIGlassLozenge");
	__xamarin_class_map [1189].handle = objc_getClass ("CoreImage_CIGlideReflectedTile");
	__xamarin_class_map [1190].handle = objc_getClass ("CoreImage_CIGloom");
	__xamarin_class_map [1191].handle = objc_getClass ("CoreImage_CIGuidedFilter");
	__xamarin_class_map [1192].handle = objc_getClass ("CoreImage_CIHardLightBlendMode");
	__xamarin_class_map [1193].handle = objc_getClass ("CoreImage_CIHatchedScreen");
	__xamarin_class_map [1194].handle = objc_getClass ("CoreImage_CIHeightFieldFromMask");
	__xamarin_class_map [1195].handle = objc_getClass ("CoreImage_CIHexagonalPixellate");
	__xamarin_class_map [1196].handle = objc_getClass ("CoreImage_CIHighlightShadowAdjust");
	__xamarin_class_map [1197].handle = objc_getClass ("CoreImage_CIHistogramDisplayFilter");
	__xamarin_class_map [1198].handle = objc_getClass ("CoreImage_CIHoleDistortion");
	__xamarin_class_map [1199].handle = objc_getClass ("CoreImage_CIHueAdjust");
	__xamarin_class_map [1200].handle = objc_getClass ("CoreImage_CIHueBlendMode");
	__xamarin_class_map [1201].handle = objc_getClass ("CoreImage_CIHueSaturationValueGradient");
	__xamarin_class_map [1202].handle = objc_getClass ("CIImageAccumulator");
	__xamarin_class_map [1203].handle = objc_getClass ("CIImageProcessorKernel");
	__xamarin_class_map [1204].handle = objc_getClass ("CoreImage_CIKaleidoscope");
	__xamarin_class_map [1205].handle = objc_getClass ("CoreImage_CIKeystoneCorrection");
	__xamarin_class_map [1206].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionCombined");
	__xamarin_class_map [1207].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionHorizontal");
	__xamarin_class_map [1208].handle = objc_getClass ("CoreImage_CIKeystoneCorrectionVertical");
	__xamarin_class_map [1209].handle = objc_getClass ("CoreImage_CIKMeans");
	__xamarin_class_map [1210].handle = objc_getClass ("CoreImage_CILabDeltaE");
	__xamarin_class_map [1211].handle = objc_getClass ("CoreImage_CILanczosScaleTransform");
	__xamarin_class_map [1212].handle = objc_getClass ("CoreImage_CILenticularHaloGenerator");
	__xamarin_class_map [1213].handle = objc_getClass ("CoreImage_CILightenBlendMode");
	__xamarin_class_map [1214].handle = objc_getClass ("CoreImage_CILightTunnel");
	__xamarin_class_map [1215].handle = objc_getClass ("CoreImage_CILinearBurnBlendMode");
	__xamarin_class_map [1216].handle = objc_getClass ("CoreImage_CILinearDodgeBlendMode");
	__xamarin_class_map [1217].handle = objc_getClass ("CoreImage_CILinearGradient");
	__xamarin_class_map [1218].handle = objc_getClass ("CoreImage_CILinearToSRGBToneCurve");
	__xamarin_class_map [1219].handle = objc_getClass ("CoreImage_CILineOverlay");
	__xamarin_class_map [1220].handle = objc_getClass ("CoreImage_CILineScreen");
	__xamarin_class_map [1221].handle = objc_getClass ("CoreImage_CILuminosityBlendMode");
	__xamarin_class_map [1222].handle = objc_getClass ("CoreImage_CIMaskedVariableBlur");
	__xamarin_class_map [1223].handle = objc_getClass ("CoreImage_CIMaskToAlpha");
	__xamarin_class_map [1224].handle = objc_getClass ("CoreImage_CIMaximumComponent");
	__xamarin_class_map [1225].handle = objc_getClass ("CoreImage_CIMaximumCompositing");
	__xamarin_class_map [1226].handle = objc_getClass ("CoreImage_CIMedianFilter");
	__xamarin_class_map [1227].handle = objc_getClass ("CoreImage_CIMeshGenerator");
	__xamarin_class_map [1228].handle = objc_getClass ("CoreImage_CIMinimumComponent");
	__xamarin_class_map [1229].handle = objc_getClass ("CoreImage_CIMinimumCompositing");
	__xamarin_class_map [1230].handle = objc_getClass ("CoreImage_CIMix");
	__xamarin_class_map [1231].handle = objc_getClass ("CoreImage_CIModTransition");
	__xamarin_class_map [1232].handle = objc_getClass ("CoreImage_CIMorphology");
	__xamarin_class_map [1233].handle = objc_getClass ("CoreImage_CIMorphologyGradient");
	__xamarin_class_map [1234].handle = objc_getClass ("CoreImage_CIMorphologyMaximum");
	__xamarin_class_map [1235].handle = objc_getClass ("CoreImage_CIMorphologyMinimum");
	__xamarin_class_map [1236].handle = objc_getClass ("CoreImage_CIMorphologyRectangle");
	__xamarin_class_map [1237].handle = objc_getClass ("CoreImage_CIMorphologyRectangleMaximum");
	__xamarin_class_map [1238].handle = objc_getClass ("CoreImage_CIMorphologyRectangleMinimum");
	__xamarin_class_map [1239].handle = objc_getClass ("CoreImage_CIMotionBlur");
	__xamarin_class_map [1240].handle = objc_getClass ("CoreImage_CIMultiplyBlendMode");
	__xamarin_class_map [1241].handle = objc_getClass ("CoreImage_CIMultiplyCompositing");
	__xamarin_class_map [1242].handle = objc_getClass ("CoreImage_CINinePartStretched");
	__xamarin_class_map [1243].handle = objc_getClass ("CoreImage_CINinePartTiled");
	__xamarin_class_map [1244].handle = objc_getClass ("CoreImage_CINoiseReduction");
	__xamarin_class_map [1245].handle = objc_getClass ("CoreImage_CIOpTile");
	__xamarin_class_map [1246].handle = objc_getClass ("CoreImage_CIOverlayBlendMode");
	__xamarin_class_map [1247].handle = objc_getClass ("CoreImage_CIPageCurlTransition");
	__xamarin_class_map [1248].handle = objc_getClass ("CoreImage_CIPageCurlWithShadowTransition");
	__xamarin_class_map [1249].handle = objc_getClass ("CoreImage_CIPaletteCentroid");
	__xamarin_class_map [1250].handle = objc_getClass ("CoreImage_CIPalettize");
	__xamarin_class_map [1251].handle = objc_getClass ("CoreImage_CIParallelogramTile");
	__xamarin_class_map [1252].handle = objc_getClass ("CoreImage_CIPdf417BarcodeGenerator");
	__xamarin_class_map [1253].handle = objc_getClass ("CIPDF417CodeDescriptor");
	__xamarin_class_map [1254].handle = objc_getClass ("CoreImage_CIPerspectiveTransform");
	__xamarin_class_map [1255].handle = objc_getClass ("CoreImage_CIPerspectiveCorrection");
	__xamarin_class_map [1256].handle = objc_getClass ("CoreImage_CIPerspectiveRotate");
	__xamarin_class_map [1257].handle = objc_getClass ("CoreImage_CIPerspectiveTile");
	__xamarin_class_map [1258].handle = objc_getClass ("CoreImage_CIPerspectiveTransformWithExtent");
	__xamarin_class_map [1259].handle = objc_getClass ("CoreImage_CIPhotoEffect");
	__xamarin_class_map [1260].handle = objc_getClass ("CoreImage_CIPhotoEffectChrome");
	__xamarin_class_map [1261].handle = objc_getClass ("CoreImage_CIPhotoEffectFade");
	__xamarin_class_map [1262].handle = objc_getClass ("CoreImage_CIPhotoEffectInstant");
	__xamarin_class_map [1263].handle = objc_getClass ("CoreImage_CIPhotoEffectMono");
	__xamarin_class_map [1264].handle = objc_getClass ("CoreImage_CIPhotoEffectNoir");
	__xamarin_class_map [1265].handle = objc_getClass ("CoreImage_CIPhotoEffectProcess");
	__xamarin_class_map [1266].handle = objc_getClass ("CoreImage_CIPhotoEffectTonal");
	__xamarin_class_map [1267].handle = objc_getClass ("CoreImage_CIPhotoEffectTransfer");
	__xamarin_class_map [1268].handle = objc_getClass ("CoreImage_CIPinchDistortion");
	__xamarin_class_map [1269].handle = objc_getClass ("CoreImage_CIPinLightBlendMode");
	__xamarin_class_map [1270].handle = objc_getClass ("CoreImage_CIPixellate");
	__xamarin_class_map [1271].handle = objc_getClass ("CIPlugIn");
	__xamarin_class_map [1272].handle = objc_getClass ("CoreImage_CIPointillize");
	__xamarin_class_map [1273].handle = objc_getClass ("CIQRCodeDescriptor");
	__xamarin_class_map [1274].handle = objc_getClass ("CIQRCodeFeature");
	__xamarin_class_map [1275].handle = objc_getClass ("CoreImage_CIQRCodeGenerator");
	__xamarin_class_map [1276].handle = objc_getClass ("CoreImage_CIRadialGradient");
	__xamarin_class_map [1277].handle = objc_getClass ("CoreImage_CIRandomGenerator");
	__xamarin_class_map [1278].handle = objc_getClass ("CIRectangleFeature");
	__xamarin_class_map [1279].handle = objc_getClass ("CIRenderDestination");
	__xamarin_class_map [1280].handle = objc_getClass ("CIRenderInfo");
	__xamarin_class_map [1281].handle = objc_getClass ("CIRenderTask");
	__xamarin_class_map [1282].handle = objc_getClass ("CoreImage_CIRippleTransition");
	__xamarin_class_map [1283].handle = objc_getClass ("CoreImage_CIRoundedRectangleGenerator");
	__xamarin_class_map [1284].handle = objc_getClass ("CoreImage_CIRowAverage");
	__xamarin_class_map [1285].handle = objc_getClass ("CoreImage_CISaliencyMapFilter");
	__xamarin_class_map [1286].handle = objc_getClass ("CoreImage_CISampleNearest");
	__xamarin_class_map [1287].handle = objc_getClass ("CoreImage_CISaturationBlendMode");
	__xamarin_class_map [1288].handle = objc_getClass ("CoreImage_CIScreenBlendMode");
	__xamarin_class_map [1289].handle = objc_getClass ("CoreImage_CISepiaTone");
	__xamarin_class_map [1290].handle = objc_getClass ("CoreImage_CIShadedMaterial");
	__xamarin_class_map [1291].handle = objc_getClass ("CoreImage_CISharpenLuminance");
	__xamarin_class_map [1292].handle = objc_getClass ("CoreImage_CISixfoldReflectedTile");
	__xamarin_class_map [1293].handle = objc_getClass ("CoreImage_CISixfoldRotatedTile");
	__xamarin_class_map [1294].handle = objc_getClass ("CoreImage_CISmoothLinearGradient");
	__xamarin_class_map [1295].handle = objc_getClass ("CoreImage_CISoftLightBlendMode");
	__xamarin_class_map [1296].handle = objc_getClass ("CoreImage_CISourceAtopCompositing");
	__xamarin_class_map [1297].handle = objc_getClass ("CoreImage_CISourceInCompositing");
	__xamarin_class_map [1298].handle = objc_getClass ("CoreImage_CISourceOutCompositing");
	__xamarin_class_map [1299].handle = objc_getClass ("CoreImage_CISourceOverCompositing");
	__xamarin_class_map [1300].handle = objc_getClass ("CoreImage_CISpotColor");
	__xamarin_class_map [1301].handle = objc_getClass ("CoreImage_CISpotLight");
	__xamarin_class_map [1302].handle = objc_getClass ("CoreImage_CISRGBToneCurveToLinear");
	__xamarin_class_map [1303].handle = objc_getClass ("CoreImage_CIStarShineGenerator");
	__xamarin_class_map [1304].handle = objc_getClass ("CoreImage_CIStraightenFilter");
	__xamarin_class_map [1305].handle = objc_getClass ("CoreImage_CIStretchCrop");
	__xamarin_class_map [1306].handle = objc_getClass ("CoreImage_CIStripesGenerator");
	__xamarin_class_map [1307].handle = objc_getClass ("CoreImage_CISubtractBlendMode");
	__xamarin_class_map [1308].handle = objc_getClass ("CoreImage_CISunbeamsGenerator");
	__xamarin_class_map [1309].handle = objc_getClass ("CoreImage_CISwipeTransition");
	__xamarin_class_map [1310].handle = objc_getClass ("CoreImage_CITemperatureAndTint");
	__xamarin_class_map [1311].handle = objc_getClass ("CITextFeature");
	__xamarin_class_map [1312].handle = objc_getClass ("CoreImage_CITextImageGenerator");
	__xamarin_class_map [1313].handle = objc_getClass ("CoreImage_CIThermal");
	__xamarin_class_map [1314].handle = objc_getClass ("CoreImage_CIToneCurve");
	__xamarin_class_map [1315].handle = objc_getClass ("CoreImage_CITorusLensDistortion");
	__xamarin_class_map [1316].handle = objc_getClass ("CoreImage_CITriangleKaleidoscope");
	__xamarin_class_map [1317].handle = objc_getClass ("CoreImage_CITriangleTile");
	__xamarin_class_map [1318].handle = objc_getClass ("CoreImage_CITwelvefoldReflectedTile");
	__xamarin_class_map [1319].handle = objc_getClass ("CoreImage_CITwirlDistortion");
	__xamarin_class_map [1320].handle = objc_getClass ("CoreImage_CIUnsharpMask");
	__xamarin_class_map [1321].handle = objc_getClass ("CoreImage_CIVibrance");
	__xamarin_class_map [1322].handle = objc_getClass ("CoreImage_CIVignette");
	__xamarin_class_map [1323].handle = objc_getClass ("CoreImage_CIVignetteEffect");
	__xamarin_class_map [1324].handle = objc_getClass ("CoreImage_CIVortexDistortion");
	__xamarin_class_map [1325].handle = objc_getClass ("CIWarpKernel");
	__xamarin_class_map [1326].handle = objc_getClass ("CoreImage_CIWhitePointAdjust");
	__xamarin_class_map [1327].handle = objc_getClass ("CoreImage_CIXRay");
	__xamarin_class_map [1328].handle = objc_getClass ("CoreImage_CIZoomBlur");
	__xamarin_class_map [1329].handle = objc_getClass ("CAAnimation");
	__xamarin_class_map [1330].handle = objc_getClass ("CAPropertyAnimation");
	__xamarin_class_map [1331].handle = objc_getClass ("CABasicAnimation");
	__xamarin_class_map [1332].handle = objc_getClass ("CAScrollLayer");
	__xamarin_class_map [1333].handle = objc_getClass ("CAEmitterBehavior");
	__xamarin_class_map [1334].handle = objc_getClass ("CAGradientLayer");
	__xamarin_class_map [1335].handle = objc_getClass ("CAKeyframeAnimation");
	__xamarin_class_map [1336].handle = objc_getClass ("CALayerDelegate");
	__xamarin_class_map [1337].handle = objc_getClass ("CAMediaTimingFunction");
	__xamarin_class_map [1338].handle = objc_getClass ("CATextLayer");
	__xamarin_class_map [1339].handle = objc_getClass ("CAAction");
	__xamarin_class_map [1340].handle = objc_getClass ("CAAnimationDelegate");
	__xamarin_class_map [1341].handle = objc_getClass ("CAAnimationGroup");
	__xamarin_class_map [1342].handle = objc_getClass ("CAConstraint");
	__xamarin_class_map [1343].handle = objc_getClass ("CAConstraintLayoutManager");
	__xamarin_class_map [1344].handle = objc_getClass ("CAEDRMetadata");
	__xamarin_class_map [1345].handle = objc_getClass ("CAEmitterCell");
	__xamarin_class_map [1346].handle = objc_getClass ("CAEmitterLayer");
	__xamarin_class_map [1347].handle = objc_getClass ("CAMediaTiming");
	__xamarin_class_map [1348].handle = objc_getClass ("CAMetalLayer");
	__xamarin_class_map [1349].handle = objc_getClass ("CARenderer");
	__xamarin_class_map [1350].handle = objc_getClass ("CAReplicatorLayer");
	__xamarin_class_map [1351].handle = objc_getClass ("CAShapeLayer");
	__xamarin_class_map [1352].handle = objc_getClass ("CASpringAnimation");
	__xamarin_class_map [1353].handle = objc_getClass ("CATiledLayer");
	__xamarin_class_map [1354].handle = objc_getClass ("CATransaction");
	__xamarin_class_map [1355].handle = objc_getClass ("CATransformLayer");
	__xamarin_class_map [1356].handle = objc_getClass ("CATransition");
	__xamarin_class_map [1357].handle = objc_getClass ("CAValueFunction");
	__xamarin_class_map [1358].handle = objc_getClass ("CNFetchRequest");
	__xamarin_class_map [1359].handle = objc_getClass ("CNContactFetchRequest");
	__xamarin_class_map [1360].handle = objc_getClass ("CNInstantMessageAddress");
	__xamarin_class_map [1361].handle = objc_getClass ("CNSocialProfile");
	__xamarin_class_map [1362].handle = objc_getClass ("CNChangeHistoryEvent");
	__xamarin_class_map [1363].handle = objc_getClass ("CNChangeHistoryAddContactEvent");
	__xamarin_class_map [1364].handle = objc_getClass ("CNChangeHistoryAddGroupEvent");
	__xamarin_class_map [1365].handle = objc_getClass ("CNChangeHistoryAddMemberToGroupEvent");
	__xamarin_class_map [1366].handle = objc_getClass ("CNChangeHistoryAddSubgroupToGroupEvent");
	__xamarin_class_map [1367].handle = objc_getClass ("CNChangeHistoryDeleteContactEvent");
	__xamarin_class_map [1368].handle = objc_getClass ("CNChangeHistoryDeleteGroupEvent");
	__xamarin_class_map [1369].handle = objc_getClass ("CNChangeHistoryDropEverythingEvent");
	__xamarin_class_map [1370].handle = objc_getClass ("CNChangeHistoryFetchRequest");
	__xamarin_class_map [1371].handle = objc_getClass ("CNChangeHistoryRemoveMemberFromGroupEvent");
	__xamarin_class_map [1372].handle = objc_getClass ("CNChangeHistoryRemoveSubgroupFromGroupEvent");
	__xamarin_class_map [1373].handle = objc_getClass ("CNChangeHistoryUpdateContactEvent");
	__xamarin_class_map [1374].handle = objc_getClass ("CNChangeHistoryUpdateGroupEvent");
	__xamarin_class_map [1375].handle = objc_getClass ("CNContactFormatter");
	__xamarin_class_map [1376].handle = objc_getClass ("CNContactProperty");
	__xamarin_class_map [1377].handle = objc_getClass ("CNContactRelation");
	__xamarin_class_map [1378].handle = objc_getClass ("CNContactsUserDefaults");
	__xamarin_class_map [1379].handle = objc_getClass ("CNContactVCardSerialization");
	__xamarin_class_map [1380].handle = objc_getClass ("CNContainer");
	__xamarin_class_map [1381].handle = objc_getClass ("CNFetchResult");
	__xamarin_class_map [1382].handle = objc_getClass ("CNGroup");
	__xamarin_class_map [1383].handle = objc_getClass ("CNLabeledValue");
	__xamarin_class_map [1384].handle = objc_getClass ("CNContact");
	__xamarin_class_map [1385].handle = objc_getClass ("CNMutableContact");
	__xamarin_class_map [1386].handle = objc_getClass ("CNMutableGroup");
	__xamarin_class_map [1387].handle = objc_getClass ("CNPostalAddress");
	__xamarin_class_map [1388].handle = objc_getClass ("CNMutablePostalAddress");
	__xamarin_class_map [1389].handle = objc_getClass ("CNPhoneNumber");
	__xamarin_class_map [1390].handle = objc_getClass ("CNPostalAddressFormatter");
	__xamarin_class_map [1391].handle = objc_getClass ("CNSaveRequest");
	__xamarin_class_map [1392].handle = objc_getClass ("NSOperation");
	__xamarin_class_map [1393].handle = objc_getClass ("CKOperation");
	__xamarin_class_map [1394].handle = objc_getClass ("CKNotificationID");
	__xamarin_class_map [1395].handle = objc_getClass ("CKRecord");
	__xamarin_class_map [1396].handle = objc_getClass ("CKRecordID");
	__xamarin_class_map [1397].handle = objc_getClass ("CKRecordZoneID");
	__xamarin_class_map [1398].handle = objc_getClass ("CKUserIdentityLookupInfo");
	__xamarin_class_map [1399].handle = objc_getClass ("CKAcceptSharesOperation");
	__xamarin_class_map [1400].handle = objc_getClass ("CKAsset");
	__xamarin_class_map [1401].handle = objc_getClass ("CKNotification");
	__xamarin_class_map [1402].handle = objc_getClass ("CKDatabaseNotification");
	__xamarin_class_map [1403].handle = objc_getClass ("CKDatabaseOperation");
	__xamarin_class_map [1404].handle = objc_getClass ("CKSubscription");
	__xamarin_class_map [1405].handle = objc_getClass ("CKDatabaseSubscription");
	__xamarin_class_map [1406].handle = objc_getClass ("CKDiscoverAllContactsOperation");
	__xamarin_class_map [1407].handle = objc_getClass ("CKDiscoverAllUserIdentitiesOperation");
	__xamarin_class_map [1408].handle = objc_getClass ("CKDiscoveredUserInfo");
	__xamarin_class_map [1409].handle = objc_getClass ("CKDiscoverUserIdentitiesOperation");
	__xamarin_class_map [1410].handle = objc_getClass ("CKDiscoverUserInfosOperation");
	__xamarin_class_map [1411].handle = objc_getClass ("CKFetchDatabaseChangesOperation");
	__xamarin_class_map [1412].handle = objc_getClass ("CKFetchNotificationChangesOperation");
	__xamarin_class_map [1413].handle = objc_getClass ("CKFetchRecordChangesOperation");
	__xamarin_class_map [1414].handle = objc_getClass ("CKFetchRecordsOperation");
	__xamarin_class_map [1415].handle = objc_getClass ("CKFetchRecordZoneChangesConfiguration");
	__xamarin_class_map [1416].handle = objc_getClass ("CKFetchRecordZoneChangesOperation");
	__xamarin_class_map [1417].handle = objc_getClass ("CKFetchRecordZoneChangesOptions");
	__xamarin_class_map [1418].handle = objc_getClass ("CKFetchRecordZonesOperation");
	__xamarin_class_map [1419].handle = objc_getClass ("CKFetchShareMetadataOperation");
	__xamarin_class_map [1420].handle = objc_getClass ("CKFetchShareParticipantsOperation");
	__xamarin_class_map [1421].handle = objc_getClass ("CKFetchSubscriptionsOperation");
	__xamarin_class_map [1422].handle = objc_getClass ("CKFetchWebAuthTokenOperation");
	__xamarin_class_map [1423].handle = objc_getClass ("NSSortDescriptor");
	__xamarin_class_map [1424].handle = objc_getClass ("CKLocationSortDescriptor");
	__xamarin_class_map [1425].handle = objc_getClass ("CKMarkNotificationsReadOperation");
	__xamarin_class_map [1426].handle = objc_getClass ("CKModifyBadgeOperation");
	__xamarin_class_map [1427].handle = objc_getClass ("CKModifyRecordsOperation");
	__xamarin_class_map [1428].handle = objc_getClass ("CKModifyRecordZonesOperation");
	__xamarin_class_map [1429].handle = objc_getClass ("CKModifySubscriptionsOperation");
	__xamarin_class_map [1430].handle = objc_getClass ("CKNotificationInfo");
	__xamarin_class_map [1431].handle = objc_getClass ("CKOperationConfiguration");
	__xamarin_class_map [1432].handle = objc_getClass ("CKOperationGroup");
	__xamarin_class_map [1433].handle = objc_getClass ("CKQuery");
	__xamarin_class_map [1434].handle = objc_getClass ("CKQueryCursor");
	__xamarin_class_map [1435].handle = objc_getClass ("CKQueryNotification");
	__xamarin_class_map [1436].handle = objc_getClass ("CKQueryOperation");
	__xamarin_class_map [1437].handle = objc_getClass ("CKQuerySubscription");
	__xamarin_class_map [1438].handle = objc_getClass ("CKRecordValue");
	__xamarin_class_map [1439].handle = objc_getClass ("CKRecordZone");
	__xamarin_class_map [1440].handle = objc_getClass ("CKRecordZoneNotification");
	__xamarin_class_map [1441].handle = objc_getClass ("CKRecordZoneSubscription");
	__xamarin_class_map [1442].handle = objc_getClass ("CKReference");
	__xamarin_class_map [1443].handle = objc_getClass ("CKServerChangeToken");
	__xamarin_class_map [1444].handle = objc_getClass ("CKShare");
	__xamarin_class_map [1445].handle = objc_getClass ("CKShareMetadata");
	__xamarin_class_map [1446].handle = objc_getClass ("CKShareParticipant");
	__xamarin_class_map [1447].handle = objc_getClass ("CKUserIdentity");
	__xamarin_class_map [1448].handle = objc_getClass ("BCChatAction");
	__xamarin_class_map [1449].handle = objc_getClass ("NSControl");
	__xamarin_class_map [1450].handle = objc_getClass ("BCChatButton");
	__xamarin_class_map [1451].handle = objc_getClass ("AUParameterNode");
	__xamarin_class_map [1452].handle = objc_getClass ("AUParameter");
	__xamarin_class_map [1453].handle = objc_getClass ("AUAudioUnitBus");
	__xamarin_class_map [1454].handle = objc_getClass ("AUAudioUnitBusArray");
	__xamarin_class_map [1455].handle = objc_getClass ("AUAudioUnitPreset");
	__xamarin_class_map [1456].handle = objc_getClass ("AUParameterGroup");
	__xamarin_class_map [1457].handle = objc_getClass ("AUParameterTree");
	__xamarin_class_map [1458].handle = objc_getClass ("SKAction");
	__xamarin_class_map [1459].handle = objc_getClass ("SKKeyframeSequence");
	__xamarin_class_map [1460].handle = objc_getClass ("SKNode");
	__xamarin_class_map [1461].handle = objc_getClass ("SKShapeNode");
	__xamarin_class_map [1462].handle = objc_getClass ("SKUniform");
	__xamarin_class_map [1463].handle = objc_getClass ("SKVideoNode");
	__xamarin_class_map [1464].handle = objc_getClass ("SKWarpGeometry");
	__xamarin_class_map [1465].handle = objc_getClass ("SKWarpGeometryGrid");
	__xamarin_class_map [1466].handle = objc_getClass ("SK3DNode");
	__xamarin_class_map [1467].handle = objc_getClass ("SKAttribute");
	__xamarin_class_map [1468].handle = objc_getClass ("SKAttributeValue");
	__xamarin_class_map [1469].handle = objc_getClass ("SKAudioNode");
	__xamarin_class_map [1470].handle = objc_getClass ("SKCameraNode");
	__xamarin_class_map [1471].handle = objc_getClass ("SKConstraint");
	__xamarin_class_map [1472].handle = objc_getClass ("SKCropNode");
	__xamarin_class_map [1473].handle = objc_getClass ("SKEffectNode");
	__xamarin_class_map [1474].handle = objc_getClass ("SKEmitterNode");
	__xamarin_class_map [1475].handle = objc_getClass ("SKFieldNode");
	__xamarin_class_map [1476].handle = objc_getClass ("SKLabelNode");
	__xamarin_class_map [1477].handle = objc_getClass ("SKLightNode");
	__xamarin_class_map [1478].handle = objc_getClass ("SKTexture");
	__xamarin_class_map [1479].handle = objc_getClass ("SKMutableTexture");
	__xamarin_class_map [1480].handle = objc_getClass ("SKPhysicsBody");
	__xamarin_class_map [1481].handle = objc_getClass ("SKPhysicsContact");
	__xamarin_class_map [1482].handle = objc_getClass ("SKPhysicsContactDelegate");
	__xamarin_class_map [1483].handle = objc_getClass ("SKPhysicsJoint");
	__xamarin_class_map [1484].handle = objc_getClass ("SKPhysicsJointFixed");
	__xamarin_class_map [1485].handle = objc_getClass ("SKPhysicsJointLimit");
	__xamarin_class_map [1486].handle = objc_getClass ("SKPhysicsJointPin");
	__xamarin_class_map [1487].handle = objc_getClass ("SKPhysicsJointSliding");
	__xamarin_class_map [1488].handle = objc_getClass ("SKPhysicsJointSpring");
	__xamarin_class_map [1489].handle = objc_getClass ("SKRange");
	__xamarin_class_map [1490].handle = objc_getClass ("SKReachConstraints");
	__xamarin_class_map [1491].handle = objc_getClass ("SKReferenceNode");
	__xamarin_class_map [1492].handle = objc_getClass ("SKRegion");
	__xamarin_class_map [1493].handle = objc_getClass ("SKRenderer");
	__xamarin_class_map [1494].handle = objc_getClass ("SKScene");
	__xamarin_class_map [1495].handle = objc_getClass ("SKSceneDelegate");
	__xamarin_class_map [1496].handle = objc_getClass ("SKShader");
	__xamarin_class_map [1497].handle = objc_getClass ("SKSpriteNode");
	__xamarin_class_map [1498].handle = objc_getClass ("SKTileDefinition");
	__xamarin_class_map [1499].handle = objc_getClass ("SKTileGroup");
	__xamarin_class_map [1500].handle = objc_getClass ("SKTileGroupRule");
	__xamarin_class_map [1501].handle = objc_getClass ("SKTileMapNode");
	__xamarin_class_map [1502].handle = objc_getClass ("SKTileSet");
	__xamarin_class_map [1503].handle = objc_getClass ("SKTransformNode");
	__xamarin_class_map [1504].handle = objc_getClass ("SKTransition");
	__xamarin_class_map [1505].handle = objc_getClass ("SKView");
	__xamarin_class_map [1506].handle = objc_getClass ("SKViewDelegate");
	__xamarin_class_map [1507].handle = objc_getClass ("SCNGeometry");
	__xamarin_class_map [1508].handle = objc_getClass ("SCNText");
	__xamarin_class_map [1509].handle = objc_getClass ("SCNAnimatable");
	__xamarin_class_map [1510].handle = objc_getClass ("SCNScene");
	__xamarin_class_map [1511].handle = objc_getClass ("SCNSceneRenderer");
	__xamarin_class_map [1512].handle = objc_getClass ("SCNGeometrySource");
	__xamarin_class_map [1513].handle = objc_getClass ("SCNParticleSystem");
	__xamarin_class_map [1514].handle = objc_getClass ("SCNPhysicsShape");
	__xamarin_class_map [1515].handle = objc_getClass ("SCNSceneSource");
	__xamarin_class_map [1516].handle = objc_getClass ("SCNSkinner");
	__xamarin_class_map [1517].handle = objc_getClass ("SCNTechnique");
	__xamarin_class_map [1518].handle = objc_getClass ("SCNConstraint");
	__xamarin_class_map [1519].handle = objc_getClass ("SCNAccelerationConstraint");
	__xamarin_class_map [1520].handle = objc_getClass ("SCNActionable");
	__xamarin_class_map [1521].handle = objc_getClass ("SCNAnimation");
	__xamarin_class_map [1522].handle = objc_getClass ("SCNAnimationPlayer");
	__xamarin_class_map [1523].handle = objc_getClass ("SCNAudioPlayer");
	__xamarin_class_map [1524].handle = objc_getClass ("SCNAudioSource");
	__xamarin_class_map [1525].handle = objc_getClass ("SCNAvoidOccluderConstraint");
	__xamarin_class_map [1526].handle = objc_getClass ("SCNAvoidOccluderConstraintDelegate");
	__xamarin_class_map [1527].handle = objc_getClass ("SCNBillboardConstraint");
	__xamarin_class_map [1528].handle = objc_getClass ("SCNBoundingVolume");
	__xamarin_class_map [1529].handle = objc_getClass ("SCNBox");
	__xamarin_class_map [1530].handle = objc_getClass ("SCNCamera");
	__xamarin_class_map [1531].handle = objc_getClass ("SCNCameraController");
	__xamarin_class_map [1532].handle = objc_getClass ("SCNCameraControllerDelegate");
	__xamarin_class_map [1533].handle = objc_getClass ("SCNCapsule");
	__xamarin_class_map [1534].handle = objc_getClass ("SCNCone");
	__xamarin_class_map [1535].handle = objc_getClass ("SCNCylinder");
	__xamarin_class_map [1536].handle = objc_getClass ("SCNDistanceConstraint");
	__xamarin_class_map [1537].handle = objc_getClass ("SCNFloor");
	__xamarin_class_map [1538].handle = objc_getClass ("SCNGeometryElement");
	__xamarin_class_map [1539].handle = objc_getClass ("SCNGeometryTessellator");
	__xamarin_class_map [1540].handle = objc_getClass ("SCNHitTestResult");
	__xamarin_class_map [1541].handle = objc_getClass ("SCNIKConstraint");
	__xamarin_class_map [1542].handle = objc_getClass ("SCNLevelOfDetail");
	__xamarin_class_map [1543].handle = objc_getClass ("SCNLight");
	__xamarin_class_map [1544].handle = objc_getClass ("SCNLookAtConstraint");
	__xamarin_class_map [1545].handle = objc_getClass ("SCNMaterial");
	__xamarin_class_map [1546].handle = objc_getClass ("SCNMaterialProperty");
	__xamarin_class_map [1547].handle = objc_getClass ("SCNMorpher");
	__xamarin_class_map [1548].handle = objc_getClass ("SCNNodeRendererDelegate");
	__xamarin_class_map [1549].handle = objc_getClass ("SCNParticlePropertyController");
	__xamarin_class_map [1550].handle = objc_getClass ("SCNPhysicsBehavior");
	__xamarin_class_map [1551].handle = objc_getClass ("SCNPhysicsBallSocketJoint");
	__xamarin_class_map [1552].handle = objc_getClass ("SCNPhysicsBody");
	__xamarin_class_map [1553].handle = objc_getClass ("SCNPhysicsConeTwistJoint");
	__xamarin_class_map [1554].handle = objc_getClass ("SCNPhysicsContact");
	__xamarin_class_map [1555].handle = objc_getClass ("SCNPhysicsContactDelegate");
	__xamarin_class_map [1556].handle = objc_getClass ("SCNPhysicsField");
	__xamarin_class_map [1557].handle = objc_getClass ("SCNPhysicsHingeJoint");
	__xamarin_class_map [1558].handle = objc_getClass ("SCNPhysicsSliderJoint");
	__xamarin_class_map [1559].handle = objc_getClass ("SCNPhysicsVehicle");
	__xamarin_class_map [1560].handle = objc_getClass ("SCNPhysicsVehicleWheel");
	__xamarin_class_map [1561].handle = objc_getClass ("SCNPlane");
	__xamarin_class_map [1562].handle = objc_getClass ("SCNProgram");
	__xamarin_class_map [1563].handle = objc_getClass ("SCNProgramDelegate");
	__xamarin_class_map [1564].handle = objc_getClass ("SCNPyramid");
	__xamarin_class_map [1565].handle = objc_getClass ("SCNNode");
	__xamarin_class_map [1566].handle = objc_getClass ("SCNReferenceNode");
	__xamarin_class_map [1567].handle = objc_getClass ("SCNReplicatorConstraint");
	__xamarin_class_map [1568].handle = objc_getClass ("SCNSceneExportDelegate");
	__xamarin_class_map [1569].handle = objc_getClass ("SCNSceneRendererDelegate");
	__xamarin_class_map [1570].handle = objc_getClass ("SCNShadable");
	__xamarin_class_map [1571].handle = objc_getClass ("SCNShape");
	__xamarin_class_map [1572].handle = objc_getClass ("SCNSliderConstraint");
	__xamarin_class_map [1573].handle = objc_getClass ("SCNSphere");
	__xamarin_class_map [1574].handle = objc_getClass ("SCNTechniqueSupport");
	__xamarin_class_map [1575].handle = objc_getClass ("SCNTimingFunction");
	__xamarin_class_map [1576].handle = objc_getClass ("SCNTorus");
	__xamarin_class_map [1577].handle = objc_getClass ("SCNTransaction");
	__xamarin_class_map [1578].handle = objc_getClass ("SCNTransformConstraint");
	__xamarin_class_map [1579].handle = objc_getClass ("SCNTube");
	__xamarin_class_map [1580].handle = objc_getClass ("GKVoiceChat");
	__xamarin_class_map [1581].handle = objc_getClass ("GKTurnBasedExchangeReply");
	__xamarin_class_map [1582].handle = objc_getClass ("GKMatchRequest");
	__xamarin_class_map [1583].handle = objc_getClass ("GKChallenge");
	__xamarin_class_map [1584].handle = objc_getClass ("GKAchievementChallenge");
	__xamarin_class_map [1585].handle = objc_getClass ("GKAchievementViewControllerDelegate");
	__xamarin_class_map [1586].handle = objc_getClass ("GKBasePlayer");
	__xamarin_class_map [1587].handle = objc_getClass ("GKChallengeEventHandlerDelegate");
	__xamarin_class_map [1588].handle = objc_getClass ("GKChallengeListener");
	__xamarin_class_map [1589].handle = objc_getClass ("GKChallengesViewController");
	__xamarin_class_map [1590].handle = objc_getClass ("GKChallengesViewControllerDelegate");
	__xamarin_class_map [1591].handle = objc_getClass ("GKCloudPlayer");
	__xamarin_class_map [1592].handle = objc_getClass ("GKDialogController");
	__xamarin_class_map [1593].handle = objc_getClass ("GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [1594].handle = objc_getClass ("GKGameCenterControllerDelegate");
	__xamarin_class_map [1595].handle = objc_getClass ("GKInvite");
	__xamarin_class_map [1596].handle = objc_getClass ("GKInviteEventListener");
	__xamarin_class_map [1597].handle = objc_getClass ("GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [1598].handle = objc_getClass ("GKLocalPlayerListener");
	__xamarin_class_map [1599].handle = objc_getClass ("GKMatchDelegate");
	__xamarin_class_map [1600].handle = objc_getClass ("GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [1601].handle = objc_getClass ("GKSavedGameListener");
	__xamarin_class_map [1602].handle = objc_getClass ("GKScoreChallenge");
	__xamarin_class_map [1603].handle = objc_getClass ("GKSession");
	__xamarin_class_map [1604].handle = objc_getClass ("GKSessionDelegate");
	__xamarin_class_map [1605].handle = objc_getClass ("GKTurnBasedEventHandler");
	__xamarin_class_map [1606].handle = objc_getClass ("GKTurnBasedEventHandlerDelegate");
	__xamarin_class_map [1607].handle = objc_getClass ("GKTurnBasedEventListener");
	__xamarin_class_map [1608].handle = objc_getClass ("GKTurnBasedMatchmakerViewController");
	__xamarin_class_map [1609].handle = objc_getClass ("GKTurnBasedMatchmakerViewControllerDelegate");
	__xamarin_class_map [1610].handle = objc_getClass ("GKTurnBasedParticipant");
	__xamarin_class_map [1611].handle = objc_getClass ("WebScriptObject");
	__xamarin_class_map [1612].handle = objc_getClass ("DOMObject");
	__xamarin_class_map [1613].handle = objc_getClass ("DOMCSSRuleList");
	__xamarin_class_map [1614].handle = objc_getClass ("DOMCSSStyleDeclaration");
	__xamarin_class_map [1615].handle = objc_getClass ("DOMHTMLCollection");
	__xamarin_class_map [1616].handle = objc_getClass ("DOMMediaList");
	__xamarin_class_map [1617].handle = objc_getClass ("DOMNamedNodeMap");
	__xamarin_class_map [1618].handle = objc_getClass ("DOMNodeList");
	__xamarin_class_map [1619].handle = objc_getClass ("DOMStyleSheetList");
	__xamarin_class_map [1620].handle = objc_getClass ("WebFrame");
	__xamarin_class_map [1621].handle = objc_getClass ("DOMNode");
	__xamarin_class_map [1622].handle = objc_getClass ("DOMElement");
	__xamarin_class_map [1623].handle = objc_getClass ("DOMHTMLElement");
	__xamarin_class_map [1624].handle = objc_getClass ("DOMHTMLSelectElement");
	__xamarin_class_map [1625].handle = objc_getClass ("DOMHTMLOptionsCollection");
	__xamarin_class_map [1626].handle = objc_getClass ("WebPolicyDelegate");
	__xamarin_class_map [1627].handle = objc_getClass ("WKWindowFeatures");
	__xamarin_class_map [1628].handle = objc_getClass ("DOMAbstractView");
	__xamarin_class_map [1629].handle = objc_getClass ("DOMAttr");
	__xamarin_class_map [1630].handle = objc_getClass ("DOMBlob");
	__xamarin_class_map [1631].handle = objc_getClass ("DOMCharacterData");
	__xamarin_class_map [1632].handle = objc_getClass ("DOMText");
	__xamarin_class_map [1633].handle = objc_getClass ("DOMCDATASection");
	__xamarin_class_map [1634].handle = objc_getClass ("DOMComment");
	__xamarin_class_map [1635].handle = objc_getClass ("DOMCSSRule");
	__xamarin_class_map [1636].handle = objc_getClass ("DOMCSSCharsetRule");
	__xamarin_class_map [1637].handle = objc_getClass ("DOMCSSFontFaceRule");
	__xamarin_class_map [1638].handle = objc_getClass ("DOMCSSMediaRule");
	__xamarin_class_map [1639].handle = objc_getClass ("DOMCSSPageRule");
	__xamarin_class_map [1640].handle = objc_getClass ("DOMCSSStyleRule");
	__xamarin_class_map [1641].handle = objc_getClass ("DOMStyleSheet");
	__xamarin_class_map [1642].handle = objc_getClass ("DOMCSSStyleSheet");
	__xamarin_class_map [1643].handle = objc_getClass ("DOMCSSUnknownRule");
	__xamarin_class_map [1644].handle = objc_getClass ("DOMCSSValue");
	__xamarin_class_map [1645].handle = objc_getClass ("DOMDocument");
	__xamarin_class_map [1646].handle = objc_getClass ("DOMDocumentFragment");
	__xamarin_class_map [1647].handle = objc_getClass ("DOMDocumentType");
	__xamarin_class_map [1648].handle = objc_getClass ("DOMEntityReference");
	__xamarin_class_map [1649].handle = objc_getClass ("DOMEvent");
	__xamarin_class_map [1650].handle = objc_getClass ("DOMEventListener");
	__xamarin_class_map [1651].handle = objc_getClass ("DOMEventTarget");
	__xamarin_class_map [1652].handle = objc_getClass ("DOMFile");
	__xamarin_class_map [1653].handle = objc_getClass ("DOMFileList");
	__xamarin_class_map [1654].handle = objc_getClass ("DOMHTMLAnchorElement");
	__xamarin_class_map [1655].handle = objc_getClass ("DOMHTMLAppletElement");
	__xamarin_class_map [1656].handle = objc_getClass ("DOMHTMLAreaElement");
	__xamarin_class_map [1657].handle = objc_getClass ("DOMHTMLBaseElement");
	__xamarin_class_map [1658].handle = objc_getClass ("DOMHTMLBaseFontElement");
	__xamarin_class_map [1659].handle = objc_getClass ("DOMHTMLBodyElement");
	__xamarin_class_map [1660].handle = objc_getClass ("DOMHTMLBRElement");
	__xamarin_class_map [1661].handle = objc_getClass ("DOMHTMLButtonElement");
	__xamarin_class_map [1662].handle = objc_getClass ("DOMHTMLDirectoryElement");
	__xamarin_class_map [1663].handle = objc_getClass ("DOMHTMLDivElement");
	__xamarin_class_map [1664].handle = objc_getClass ("DOMHTMLDListElement");
	__xamarin_class_map [1665].handle = objc_getClass ("DOMHTMLDocument");
	__xamarin_class_map [1666].handle = objc_getClass ("DOMHTMLEmbedElement");
	__xamarin_class_map [1667].handle = objc_getClass ("DOMHTMLFieldSetElement");
	__xamarin_class_map [1668].handle = objc_getClass ("DOMHTMLFontElement");
	__xamarin_class_map [1669].handle = objc_getClass ("DOMHTMLFormElement");
	__xamarin_class_map [1670].handle = objc_getClass ("DOMHTMLFrameElement");
	__xamarin_class_map [1671].handle = objc_getClass ("DOMHTMLFrameSetElement");
	__xamarin_class_map [1672].handle = objc_getClass ("DOMHTMLHeadElement");
	__xamarin_class_map [1673].handle = objc_getClass ("DOMHTMLHeadingElement");
	__xamarin_class_map [1674].handle = objc_getClass ("DOMHTMLHRElement");
	__xamarin_class_map [1675].handle = objc_getClass ("DOMHTMLHtmlElement");
	__xamarin_class_map [1676].handle = objc_getClass ("DOMHTMLIFrameElement");
	__xamarin_class_map [1677].handle = objc_getClass ("DOMHTMLImageElement");
	__xamarin_class_map [1678].handle = objc_getClass ("DOMHTMLInputElement");
	__xamarin_class_map [1679].handle = objc_getClass ("DOMHTMLLabelElement");
	__xamarin_class_map [1680].handle = objc_getClass ("DOMHTMLLegendElement");
	__xamarin_class_map [1681].handle = objc_getClass ("DOMHTMLLIElement");
	__xamarin_class_map [1682].handle = objc_getClass ("DOMHTMLLinkElement");
	__xamarin_class_map [1683].handle = objc_getClass ("DOMHTMLMapElement");
	__xamarin_class_map [1684].handle = objc_getClass ("DOMHTMLMarqueeElement");
	__xamarin_class_map [1685].handle = objc_getClass ("DOMHTMLMenuElement");
	__xamarin_class_map [1686].handle = objc_getClass ("DOMHTMLMetaElement");
	__xamarin_class_map [1687].handle = objc_getClass ("DOMHTMLModElement");
	__xamarin_class_map [1688].handle = objc_getClass ("DOMHTMLObjectElement");
	__xamarin_class_map [1689].handle = objc_getClass ("DOMHTMLOListElement");
	__xamarin_class_map [1690].handle = objc_getClass ("DOMHTMLOptGroupElement");
	__xamarin_class_map [1691].handle = objc_getClass ("DOMHTMLOptionElement");
	__xamarin_class_map [1692].handle = objc_getClass ("DOMHTMLParagraphElement");
	__xamarin_class_map [1693].handle = objc_getClass ("DOMHTMLParamElement");
	__xamarin_class_map [1694].handle = objc_getClass ("DOMHTMLPreElement");
	__xamarin_class_map [1695].handle = objc_getClass ("DOMHTMLQuoteElement");
	__xamarin_class_map [1696].handle = objc_getClass ("DOMHTMLScriptElement");
	__xamarin_class_map [1697].handle = objc_getClass ("DOMHTMLStyleElement");
	__xamarin_class_map [1698].handle = objc_getClass ("DOMHTMLTableCaptionElement");
	__xamarin_class_map [1699].handle = objc_getClass ("DOMHTMLTableCellElement");
	__xamarin_class_map [1700].handle = objc_getClass ("DOMHTMLTableColElement");
	__xamarin_class_map [1701].handle = objc_getClass ("DOMHTMLTableElement");
	__xamarin_class_map [1702].handle = objc_getClass ("DOMHTMLTableRowElement");
	__xamarin_class_map [1703].handle = objc_getClass ("DOMHTMLTableSectionElement");
	__xamarin_class_map [1704].handle = objc_getClass ("DOMHTMLTextAreaElement");
	__xamarin_class_map [1705].handle = objc_getClass ("DOMImplementation");
	__xamarin_class_map [1706].handle = objc_getClass ("DOMCSSImportRule");
	__xamarin_class_map [1707].handle = objc_getClass ("DOMUIEvent");
	__xamarin_class_map [1708].handle = objc_getClass ("DOMKeyboardEvent");
	__xamarin_class_map [1709].handle = objc_getClass ("DOMMouseEvent");
	__xamarin_class_map [1710].handle = objc_getClass ("Xamarin_Mac__WebKit_DomNodeFilter");
	__xamarin_class_map [1711].handle = objc_getClass ("DOMNodeIterator");
	__xamarin_class_map [1712].handle = objc_getClass ("DOMOverflowEvent");
	__xamarin_class_map [1713].handle = objc_getClass ("DOMProcessingInstruction");
	__xamarin_class_map [1714].handle = objc_getClass ("DOMProgressEvent");
	__xamarin_class_map [1715].handle = objc_getClass ("DOMRange");
	__xamarin_class_map [1716].handle = objc_getClass ("DOMWheelEvent");
	__xamarin_class_map [1717].handle = objc_getClass ("WebArchive");
	__xamarin_class_map [1718].handle = objc_getClass ("WebBackForwardList");
	__xamarin_class_map [1719].handle = objc_getClass ("WebDataSource");
	__xamarin_class_map [1720].handle = objc_getClass ("WebDocumentRepresentation");
	__xamarin_class_map [1721].handle = objc_getClass ("NSURLDownload");
	__xamarin_class_map [1722].handle = objc_getClass ("WebDownload");
	__xamarin_class_map [1723].handle = objc_getClass ("WebDownloadDelegate");
	__xamarin_class_map [1724].handle = objc_getClass ("WebFrameLoadDelegate");
	__xamarin_class_map [1725].handle = objc_getClass ("WebFrameView");
	__xamarin_class_map [1726].handle = objc_getClass ("WebHistory");
	__xamarin_class_map [1727].handle = objc_getClass ("Xamarin_Mac__WebKit_WebOpenPanelResultListener");
	__xamarin_class_map [1728].handle = objc_getClass ("Xamarin_Mac__WebKit_WebPolicyDecisionListener");
	__xamarin_class_map [1729].handle = objc_getClass ("WebPreferences");
	__xamarin_class_map [1730].handle = objc_getClass ("WebResource");
	__xamarin_class_map [1731].handle = objc_getClass ("WebResourceLoadDelegate");
	__xamarin_class_map [1732].handle = objc_getClass ("WebUIDelegate");
	__xamarin_class_map [1733].handle = objc_getClass ("WKBackForwardList");
	__xamarin_class_map [1734].handle = objc_getClass ("WKBackForwardListItem");
	__xamarin_class_map [1735].handle = objc_getClass ("WKContentRuleList");
	__xamarin_class_map [1736].handle = objc_getClass ("WKFrameInfo");
	__xamarin_class_map [1737].handle = objc_getClass ("WKNavigation");
	__xamarin_class_map [1738].handle = objc_getClass ("WKNavigationAction");
	__xamarin_class_map [1739].handle = objc_getClass ("WKNavigationDelegate");
	__xamarin_class_map [1740].handle = objc_getClass ("WKNavigationResponse");
	__xamarin_class_map [1741].handle = objc_getClass ("WKOpenPanelParameters");
	__xamarin_class_map [1742].handle = objc_getClass ("WKPreferences");
	__xamarin_class_map [1743].handle = objc_getClass ("WKProcessPool");
	__xamarin_class_map [1744].handle = objc_getClass ("WKScriptMessage");
	__xamarin_class_map [1745].handle = objc_getClass ("WKScriptMessageHandler");
	__xamarin_class_map [1746].handle = objc_getClass ("WKSecurityOrigin");
	__xamarin_class_map [1747].handle = objc_getClass ("WKSnapshotConfiguration");
	__xamarin_class_map [1748].handle = objc_getClass ("WKUIDelegate");
	__xamarin_class_map [1749].handle = objc_getClass ("WKUserContentController");
	__xamarin_class_map [1750].handle = objc_getClass ("WKUserScript");
	__xamarin_class_map [1751].handle = objc_getClass ("WKWebpagePreferences");
	__xamarin_class_map [1752].handle = objc_getClass ("WKWebsiteDataRecord");
	__xamarin_class_map [1753].handle = objc_getClass ("WKWebViewConfiguration");
	__xamarin_class_map [1754].handle = objc_getClass ("NSLayoutConstraint");
	__xamarin_class_map [1755].handle = objc_getClass ("__monomac_internal_ActionDispatcher");
	__xamarin_class_map [1756].handle = objc_getClass ("NSSavePanel");
	__xamarin_class_map [1757].handle = objc_getClass ("NSOpenPanel");
	__xamarin_class_map [1758].handle = objc_getClass ("NSPageLayout");
	__xamarin_class_map [1759].handle = objc_getClass ("NSPathControl");
	__xamarin_class_map [1760].handle = objc_getClass ("NSStatusItem");
	__xamarin_class_map [1761].handle = objc_getClass ("NSCell");
	__xamarin_class_map [1762].handle = objc_getClass ("NSActionCell");
	__xamarin_class_map [1763].handle = objc_getClass ("__MonoMac_NSAlertDidEndDispatcher");
	__xamarin_class_map [1764].handle = objc_getClass ("NSApplicationDelegate");
	__xamarin_class_map [1765].handle = objc_getClass ("NSController");
	__xamarin_class_map [1766].handle = objc_getClass ("NSObjectController");
	__xamarin_class_map [1767].handle = objc_getClass ("NSArrayController");
	__xamarin_class_map [1768].handle = objc_getClass ("NSBezierPath");
	__xamarin_class_map [1769].handle = objc_getClass ("NSImageRep");
	__xamarin_class_map [1770].handle = objc_getClass ("NSBitmapImageRep");
	__xamarin_class_map [1771].handle = objc_getClass ("NSButton");
	__xamarin_class_map [1772].handle = objc_getClass ("NSTextFieldCell");
	__xamarin_class_map [1773].handle = objc_getClass ("NSComboBoxCell");
	__xamarin_class_map [1774].handle = objc_getClass ("NSDraggingSession");
	__xamarin_class_map [1775].handle = objc_getClass ("NSDraggingItem");
	__xamarin_class_map [1776].handle = objc_getClass ("NSPasteboard");
	__xamarin_class_map [1777].handle = objc_getClass ("NSSharingServiceDelegate");
	__xamarin_class_map [1778].handle = objc_getClass ("NSGraphicsContext");
	__xamarin_class_map [1779].handle = objc_getClass ("NSLayoutManager");
	__xamarin_class_map [1780].handle = objc_getClass ("NSLevelIndicator");
	__xamarin_class_map [1781].handle = objc_getClass ("NSOpenGLContext");
	__xamarin_class_map [1782].handle = objc_getClass ("NSOpenGLPixelFormat");
	__xamarin_class_map [1783].handle = objc_getClass ("NSPathControlItem");
	__xamarin_class_map [1784].handle = objc_getClass ("NSPrintInfo");
	__xamarin_class_map [1785].handle = objc_getClass ("NSSegmentedControl");
	__xamarin_class_map [1786].handle = objc_getClass ("NSSlider");
	__xamarin_class_map [1787].handle = objc_getClass ("NSSpeechSynthesizer");
	__xamarin_class_map [1788].handle = objc_getClass ("NSStatusBar");
	__xamarin_class_map [1789].handle = objc_getClass ("NSTextContainer");
	__xamarin_class_map [1790].handle = objc_getClass ("NSToolbarItem");
	__xamarin_class_map [1791].handle = objc_getClass ("NSTouch");
	__xamarin_class_map [1792].handle = objc_getClass ("NSTreeController");
	__xamarin_class_map [1793].handle = objc_getClass ("NSCollectionView");
	__xamarin_class_map [1794].handle = objc_getClass ("NSCollectionViewDelegate");
	__xamarin_class_map [1795].handle = objc_getClass ("NSCollectionViewDelegateFlowLayout");
	__xamarin_class_map [1796].handle = objc_getClass ("NSTextBlock");
	__xamarin_class_map [1797].handle = objc_getClass ("NSTextTableBlock");
	__xamarin_class_map [1798].handle = objc_getClass ("NSFontCollection");
	__xamarin_class_map [1799].handle = objc_getClass ("NSMutableFontCollection");
	__xamarin_class_map [1800].handle = objc_getClass ("NSCollectionViewLayout");
	__xamarin_class_map [1801].handle = objc_getClass ("NSTouchBarItem");
	__xamarin_class_map [1802].handle = objc_getClass ("NSColorPickerTouchBarItem");
	__xamarin_class_map [1803].handle = objc_getClass ("NSSliderTouchBarItem");
	__xamarin_class_map [1804].handle = objc_getClass ("NSCollectionLayoutAnchor");
	__xamarin_class_map [1805].handle = objc_getClass ("NSAccessibilityCustomAction");
	__xamarin_class_map [1806].handle = objc_getClass ("NSAccessibilityCustomRotor");
	__xamarin_class_map [1807].handle = objc_getClass ("NSAccessibilityCustomRotorItemResult");
	__xamarin_class_map [1808].handle = objc_getClass ("NSAccessibilityCustomRotorItemSearchDelegate");
	__xamarin_class_map [1809].handle = objc_getClass ("NSAccessibilityCustomRotorSearchParameters");
	__xamarin_class_map [1810].handle = objc_getClass ("NSAlertDelegate");
	__xamarin_class_map [1811].handle = objc_getClass ("NSAlignmentFeedbackFilter");
	__xamarin_class_map [1812].handle = objc_getClass ("NSAlignmentFeedbackToken");
	__xamarin_class_map [1813].handle = objc_getClass ("NSAnimationContext");
	__xamarin_class_map [1814].handle = objc_getClass ("NSAnimationDelegate");
	__xamarin_class_map [1815].handle = objc_getClass ("NSAppearance");
	__xamarin_class_map [1816].handle = objc_getClass ("NSAppearanceCustomization");
	__xamarin_class_map [1817].handle = objc_getClass ("NSTypesetter");
	__xamarin_class_map [1818].handle = objc_getClass ("NSATSTypesetter");
	__xamarin_class_map [1819].handle = objc_getClass ("NSBox");
	__xamarin_class_map [1820].handle = objc_getClass ("NSBrowserCell");
	__xamarin_class_map [1821].handle = objc_getClass ("NSBrowserDelegate");
	__xamarin_class_map [1822].handle = objc_getClass ("NSButtonCell");
	__xamarin_class_map [1823].handle = objc_getClass ("NSButtonTouchBarItem");
	__xamarin_class_map [1824].handle = objc_getClass ("NSCachedImageRep");
	__xamarin_class_map [1825].handle = objc_getClass ("NSCandidateListTouchBarItem");
	__xamarin_class_map [1826].handle = objc_getClass ("NSCandidateListTouchBarItemDelegate");
	__xamarin_class_map [1827].handle = objc_getClass ("NSCIImageRep");
	__xamarin_class_map [1828].handle = objc_getClass ("NSClipView");
	__xamarin_class_map [1829].handle = objc_getClass ("NSCloudSharingServiceDelegate");
	__xamarin_class_map [1830].handle = objc_getClass ("NSCollectionLayoutItem");
	__xamarin_class_map [1831].handle = objc_getClass ("NSCollectionLayoutSupplementaryItem");
	__xamarin_class_map [1832].handle = objc_getClass ("NSCollectionLayoutBoundarySupplementaryItem");
	__xamarin_class_map [1833].handle = objc_getClass ("NSCollectionLayoutDecorationItem");
	__xamarin_class_map [1834].handle = objc_getClass ("NSCollectionLayoutDimension");
	__xamarin_class_map [1835].handle = objc_getClass ("NSCollectionLayoutEdgeSpacing");
	__xamarin_class_map [1836].handle = objc_getClass ("NSCollectionLayoutGroup");
	__xamarin_class_map [1837].handle = objc_getClass ("NSCollectionLayoutGroupCustomItem");
	__xamarin_class_map [1838].handle = objc_getClass ("NSCollectionLayoutSection");
	__xamarin_class_map [1839].handle = objc_getClass ("NSCollectionLayoutSize");
	__xamarin_class_map [1840].handle = objc_getClass ("NSCollectionLayoutSpacing");
	__xamarin_class_map [1841].handle = objc_getClass ("NSCollectionViewCompositionalLayout");
	__xamarin_class_map [1842].handle = objc_getClass ("NSCollectionViewCompositionalLayoutConfiguration");
	__xamarin_class_map [1843].handle = objc_getClass ("NSCollectionViewDataSource");
	__xamarin_class_map [1844].handle = objc_getClass ("NSCollectionViewDiffableDataSource");
	__xamarin_class_map [1845].handle = objc_getClass ("NSCollectionViewElement");
	__xamarin_class_map [1846].handle = objc_getClass ("NSCollectionViewFlowLayout");
	__xamarin_class_map [1847].handle = objc_getClass ("NSCollectionViewLayoutInvalidationContext");
	__xamarin_class_map [1848].handle = objc_getClass ("NSCollectionViewFlowLayoutInvalidationContext");
	__xamarin_class_map [1849].handle = objc_getClass ("NSCollectionViewGridLayout");
	__xamarin_class_map [1850].handle = objc_getClass ("NSCollectionViewItem");
	__xamarin_class_map [1851].handle = objc_getClass ("NSCollectionViewLayoutAttributes");
	__xamarin_class_map [1852].handle = objc_getClass ("NSCollectionViewTransitionLayout");
	__xamarin_class_map [1853].handle = objc_getClass ("NSCollectionViewUpdateItem");
	__xamarin_class_map [1854].handle = objc_getClass ("NSColorList");
	__xamarin_class_map [1855].handle = objc_getClass ("NSColorPicker");
	__xamarin_class_map [1856].handle = objc_getClass ("NSColorSampler");
	__xamarin_class_map [1857].handle = objc_getClass ("NSColorSpace");
	__xamarin_class_map [1858].handle = objc_getClass ("NSColorWell");
	__xamarin_class_map [1859].handle = objc_getClass ("NSComboBoxCellDataSource");
	__xamarin_class_map [1860].handle = objc_getClass ("NSComboBoxDataSource");
	__xamarin_class_map [1861].handle = objc_getClass ("NSTextFieldDelegate");
	__xamarin_class_map [1862].handle = objc_getClass ("NSComboBoxDelegate");
	__xamarin_class_map [1863].handle = objc_getClass ("NSControlTextEditingDelegate");
	__xamarin_class_map [1864].handle = objc_getClass ("NSCursor");
	__xamarin_class_map [1865].handle = objc_getClass ("NSCustomImageRep");
	__xamarin_class_map [1866].handle = objc_getClass ("NSCustomTouchBarItem");
	__xamarin_class_map [1867].handle = objc_getClass ("NSDataAsset");
	__xamarin_class_map [1868].handle = objc_getClass ("NSDatePickerCellDelegate");
	__xamarin_class_map [1869].handle = objc_getClass ("NSDictionaryController");
	__xamarin_class_map [1870].handle = objc_getClass ("NSDictionaryControllerKeyValuePair");
	__xamarin_class_map [1871].handle = objc_getClass ("NSDiffableDataSourceSnapshot");
	__xamarin_class_map [1872].handle = objc_getClass ("NSDockTile");
	__xamarin_class_map [1873].handle = objc_getClass ("NSDockTilePlugIn");
	__xamarin_class_map [1874].handle = objc_getClass ("NSDocumentController");
	__xamarin_class_map [1875].handle = objc_getClass ("NSDraggingDestination");
	__xamarin_class_map [1876].handle = objc_getClass ("NSDraggingImageComponent");
	__xamarin_class_map [1877].handle = objc_getClass ("NSDraggingSource");
	__xamarin_class_map [1878].handle = objc_getClass ("NSDrawerDelegate");
	__xamarin_class_map [1879].handle = objc_getClass ("NSEPSImageRep");
	__xamarin_class_map [1880].handle = objc_getClass ("NSFilePromiseProvider");
	__xamarin_class_map [1881].handle = objc_getClass ("NSFilePromiseProviderDelegate");
	__xamarin_class_map [1882].handle = objc_getClass ("NSFilePromiseReceiver");
	__xamarin_class_map [1883].handle = objc_getClass ("NSFontAssetRequest");
	__xamarin_class_map [1884].handle = objc_getClass ("NSFontDescriptor");
	__xamarin_class_map [1885].handle = objc_getClass ("NSFontManager");
	__xamarin_class_map [1886].handle = objc_getClass ("NSFontPanel");
	__xamarin_class_map [1887].handle = objc_getClass ("NSMatrix");
	__xamarin_class_map [1888].handle = objc_getClass ("NSForm");
	__xamarin_class_map [1889].handle = objc_getClass ("NSFormCell");
	__xamarin_class_map [1890].handle = objc_getClass ("NSGestureRecognizerDelegate");
	__xamarin_class_map [1891].handle = objc_getClass ("NSGlyphGenerator");
	__xamarin_class_map [1892].handle = objc_getClass ("NSGlyphInfo");
	__xamarin_class_map [1893].handle = objc_getClass ("NSGridCell");
	__xamarin_class_map [1894].handle = objc_getClass ("NSGridColumn");
	__xamarin_class_map [1895].handle = objc_getClass ("NSGridRow");
	__xamarin_class_map [1896].handle = objc_getClass ("NSGridView");
	__xamarin_class_map [1897].handle = objc_getClass ("NSGroupTouchBarItem");
	__xamarin_class_map [1898].handle = objc_getClass ("NSHapticFeedbackManager");
	__xamarin_class_map [1899].handle = objc_getClass ("NSHapticFeedbackPerformer");
	__xamarin_class_map [1900].handle = objc_getClass ("NSImageCell");
	__xamarin_class_map [1901].handle = objc_getClass ("NSImageDelegate");
	__xamarin_class_map [1902].handle = objc_getClass ("NSImageView");
	__xamarin_class_map [1903].handle = objc_getClass ("NSLayoutAnchor");
	__xamarin_class_map [1904].handle = objc_getClass ("NSLayoutDimension");
	__xamarin_class_map [1905].handle = objc_getClass ("NSLayoutGuide");
	__xamarin_class_map [1906].handle = objc_getClass ("NSLayoutManagerDelegate");
	__xamarin_class_map [1907].handle = objc_getClass ("NSLayoutXAxisAnchor");
	__xamarin_class_map [1908].handle = objc_getClass ("NSLayoutYAxisAnchor");
	__xamarin_class_map [1909].handle = objc_getClass ("NSLevelIndicatorCell");
	__xamarin_class_map [1910].handle = objc_getClass ("NSMatrixDelegate");
	__xamarin_class_map [1911].handle = objc_getClass ("NSMenuDelegate");
	__xamarin_class_map [1912].handle = objc_getClass ("NSMenuItemCell");
	__xamarin_class_map [1913].handle = objc_getClass ("NSMenuToolbarItem");
	__xamarin_class_map [1914].handle = objc_getClass ("NSMenuView");
	__xamarin_class_map [1915].handle = objc_getClass ("NSParagraphStyle");
	__xamarin_class_map [1916].handle = objc_getClass ("NSMutableParagraphStyle");
	__xamarin_class_map [1917].handle = objc_getClass ("NSNib");
	__xamarin_class_map [1918].handle = objc_getClass ("NSOpenGLLayer");
	__xamarin_class_map [1919].handle = objc_getClass ("NSOpenGLPixelBuffer");
	__xamarin_class_map [1920].handle = objc_getClass ("NSOpenGLView");
	__xamarin_class_map [1921].handle = objc_getClass ("NSOpenSavePanelDelegate");
	__xamarin_class_map [1922].handle = objc_getClass ("NSOutlineViewDataSource");
	__xamarin_class_map [1923].handle = objc_getClass ("NSOutlineViewDelegate");
	__xamarin_class_map [1924].handle = objc_getClass ("NSPageControllerDelegate");
	__xamarin_class_map [1925].handle = objc_getClass ("NSPasteboardItem");
	__xamarin_class_map [1926].handle = objc_getClass ("NSPasteboardItemDataProvider");
	__xamarin_class_map [1927].handle = objc_getClass ("NSPasteboardReading");
	__xamarin_class_map [1928].handle = objc_getClass ("NSPasteboardWriting");
	__xamarin_class_map [1929].handle = objc_getClass ("NSPathCellDelegate");
	__xamarin_class_map [1930].handle = objc_getClass ("NSPathComponentCell");
	__xamarin_class_map [1931].handle = objc_getClass ("NSPathControlDelegate");
	__xamarin_class_map [1932].handle = objc_getClass ("NSPDFImageRep");
	__xamarin_class_map [1933].handle = objc_getClass ("NSPickerTouchBarItem");
	__xamarin_class_map [1934].handle = objc_getClass ("NSPopoverDelegate");
	__xamarin_class_map [1935].handle = objc_getClass ("NSPopoverTouchBarItem");
	__xamarin_class_map [1936].handle = objc_getClass ("NSRuleEditor");
	__xamarin_class_map [1937].handle = objc_getClass ("NSPredicateEditor");
	__xamarin_class_map [1938].handle = objc_getClass ("NSPressureConfiguration");
	__xamarin_class_map [1939].handle = objc_getClass ("NSPrinter");
	__xamarin_class_map [1940].handle = objc_getClass ("NSPrintOperation");
	__xamarin_class_map [1941].handle = objc_getClass ("NSPrintPanel");
	__xamarin_class_map [1942].handle = objc_getClass ("NSPrintPanelAccessorizing");
	__xamarin_class_map [1943].handle = objc_getClass ("NSPrintPreviewGraphicsContext");
	__xamarin_class_map [1944].handle = objc_getClass ("NSProgressIndicator");
	__xamarin_class_map [1945].handle = objc_getClass ("NSRemoteOpenPanel");
	__xamarin_class_map [1946].handle = objc_getClass ("NSRemoteSavePanel");
	__xamarin_class_map [1947].handle = objc_getClass ("NSRuleEditorDelegate");
	__xamarin_class_map [1948].handle = objc_getClass ("NSRulerMarker");
	__xamarin_class_map [1949].handle = objc_getClass ("NSRulerView");
	__xamarin_class_map [1950].handle = objc_getClass ("NSRunningApplication");
	__xamarin_class_map [1951].handle = objc_getClass ("NSScrubber");
	__xamarin_class_map [1952].handle = objc_getClass ("NSScrubberArrangedView");
	__xamarin_class_map [1953].handle = objc_getClass ("NSScrubberDataSource");
	__xamarin_class_map [1954].handle = objc_getClass ("NSScrubberDelegate");
	__xamarin_class_map [1955].handle = objc_getClass ("NSScrubberLayout");
	__xamarin_class_map [1956].handle = objc_getClass ("NSScrubberFlowLayout");
	__xamarin_class_map [1957].handle = objc_getClass ("NSScrubberFlowLayoutDelegate");
	__xamarin_class_map [1958].handle = objc_getClass ("NSScrubberItemView");
	__xamarin_class_map [1959].handle = objc_getClass ("NSScrubberImageItemView");
	__xamarin_class_map [1960].handle = objc_getClass ("NSScrubberLayoutAttributes");
	__xamarin_class_map [1961].handle = objc_getClass ("NSScrubberProportionalLayout");
	__xamarin_class_map [1962].handle = objc_getClass ("NSScrubberSelectionStyle");
	__xamarin_class_map [1963].handle = objc_getClass ("NSScrubberSelectionView");
	__xamarin_class_map [1964].handle = objc_getClass ("NSScrubberTextItemView");
	__xamarin_class_map [1965].handle = objc_getClass ("NSSearchFieldCell");
	__xamarin_class_map [1966].handle = objc_getClass ("NSSearchFieldDelegate");
	__xamarin_class_map [1967].handle = objc_getClass ("NSTextField");
	__xamarin_class_map [1968].handle = objc_getClass ("NSSecureTextField");
	__xamarin_class_map [1969].handle = objc_getClass ("NSSecureTextFieldCell");
	__xamarin_class_map [1970].handle = objc_getClass ("NSSegmentedCell");
	__xamarin_class_map [1971].handle = objc_getClass ("NSSeguePerforming");
	__xamarin_class_map [1972].handle = objc_getClass ("NSShadow");
	__xamarin_class_map [1973].handle = objc_getClass ("NSSharingServicePickerDelegate");
	__xamarin_class_map [1974].handle = objc_getClass ("NSSharingServicePickerToolbarItem");
	__xamarin_class_map [1975].handle = objc_getClass ("Xamarin_Mac__AppKit_NSSharingServicePickerToolbarItemDelegate");
	__xamarin_class_map [1976].handle = objc_getClass ("NSSharingServicePickerTouchBarItem");
	__xamarin_class_map [1977].handle = objc_getClass ("NSSharingServicePickerTouchBarItemDelegate");
	__xamarin_class_map [1978].handle = objc_getClass ("NSSliderAccessoryBehavior");
	__xamarin_class_map [1979].handle = objc_getClass ("NSSliderCell");
	__xamarin_class_map [1980].handle = objc_getClass ("NSSoundDelegate");
	__xamarin_class_map [1981].handle = objc_getClass ("NSSpeechRecognizer");
	__xamarin_class_map [1982].handle = objc_getClass ("NSSpeechRecognizerDelegate");
	__xamarin_class_map [1983].handle = objc_getClass ("NSSpeechSynthesizerDelegate");
	__xamarin_class_map [1984].handle = objc_getClass ("NSSplitViewController");
	__xamarin_class_map [1985].handle = objc_getClass ("NSSplitViewDelegate");
	__xamarin_class_map [1986].handle = objc_getClass ("NSSplitViewItem");
	__xamarin_class_map [1987].handle = objc_getClass ("NSSpringLoadingDestination");
	__xamarin_class_map [1988].handle = objc_getClass ("NSStackView");
	__xamarin_class_map [1989].handle = objc_getClass ("NSStackViewDelegate");
	__xamarin_class_map [1990].handle = objc_getClass ("NSStatusBarButton");
	__xamarin_class_map [1991].handle = objc_getClass ("NSStepper");
	__xamarin_class_map [1992].handle = objc_getClass ("NSStepperCell");
	__xamarin_class_map [1993].handle = objc_getClass ("NSStepperTouchBarItem");
	__xamarin_class_map [1994].handle = objc_getClass ("NSStoryboard");
	__xamarin_class_map [1995].handle = objc_getClass ("NSStoryboardSegue");
	__xamarin_class_map [1996].handle = objc_getClass ("NSStringDrawingContext");
	__xamarin_class_map [1997].handle = objc_getClass ("NSSwitch");
	__xamarin_class_map [1998].handle = objc_getClass ("NSTableCellView");
	__xamarin_class_map [1999].handle = objc_getClass ("NSTableColumn");
	__xamarin_class_map [2000].handle = objc_getClass ("NSTableHeaderCell");
	__xamarin_class_map [2001].handle = objc_getClass ("NSTableHeaderView");
	__xamarin_class_map [2002].handle = objc_getClass ("NSTableRowView");
	__xamarin_class_map [2003].handle = objc_getClass ("NSTableViewDataSource");
	__xamarin_class_map [2004].handle = objc_getClass ("NSTableViewDelegate");
	__xamarin_class_map [2005].handle = objc_getClass ("NSTableViewRowAction");
	__xamarin_class_map [2006].handle = objc_getClass ("NSTableViewSource");
	__xamarin_class_map [2007].handle = objc_getClass ("NSTabViewController");
	__xamarin_class_map [2008].handle = objc_getClass ("NSTabViewDelegate");
	__xamarin_class_map [2009].handle = objc_getClass ("NSTabViewItem");
	__xamarin_class_map [2010].handle = objc_getClass ("NSTextAttachment");
	__xamarin_class_map [2011].handle = objc_getClass ("NSTextAttachmentCell");
	__xamarin_class_map [2012].handle = objc_getClass ("NSTextAttachmentContainer");
	__xamarin_class_map [2013].handle = objc_getClass ("NSTextCheckingController");
	__xamarin_class_map [2014].handle = objc_getClass ("NSTextDelegate");
	__xamarin_class_map [2015].handle = objc_getClass ("NSTextFinder");
	__xamarin_class_map [2016].handle = objc_getClass ("NSTextFinderBarContainer");
	__xamarin_class_map [2017].handle = objc_getClass ("NSTextFinderClient");
	__xamarin_class_map [2018].handle = objc_getClass ("NSTextInputClient");
	__xamarin_class_map [2019].handle = objc_getClass ("NSTextList");
	__xamarin_class_map [2020].handle = objc_getClass ("NSTextStorageDelegate");
	__xamarin_class_map [2021].handle = objc_getClass ("NSTextTab");
	__xamarin_class_map [2022].handle = objc_getClass ("NSTextTable");
	__xamarin_class_map [2023].handle = objc_getClass ("NSTextViewDelegate");
	__xamarin_class_map [2024].handle = objc_getClass ("NSTitlebarAccessoryViewController");
	__xamarin_class_map [2025].handle = objc_getClass ("NSTokenField");
	__xamarin_class_map [2026].handle = objc_getClass ("NSTokenFieldCell");
	__xamarin_class_map [2027].handle = objc_getClass ("NSTokenFieldCellDelegate");
	__xamarin_class_map [2028].handle = objc_getClass ("NSTokenFieldDelegate");
	__xamarin_class_map [2029].handle = objc_getClass ("NSToolbarDelegate");
	__xamarin_class_map [2030].handle = objc_getClass ("NSToolbarItemGroup");
	__xamarin_class_map [2031].handle = objc_getClass ("NSTouchBarDelegate");
	__xamarin_class_map [2032].handle = objc_getClass ("NSTrackingArea");
	__xamarin_class_map [2033].handle = objc_getClass ("NSTreeNode");
	__xamarin_class_map [2034].handle = objc_getClass ("NSUserDefaultsController");
	__xamarin_class_map [2035].handle = objc_getClass ("NSUserInterfaceCompressionOptions");
	__xamarin_class_map [2036].handle = objc_getClass ("NSAnimation");
	__xamarin_class_map [2037].handle = objc_getClass ("NSViewAnimation");
	__xamarin_class_map [2038].handle = objc_getClass ("NSViewControllerPresentationAnimator");
	__xamarin_class_map [2039].handle = objc_getClass ("NSVisualEffectView");
	__xamarin_class_map [2040].handle = objc_getClass ("NSWindowDelegate");
	__xamarin_class_map [2041].handle = objc_getClass ("NSWindowRestoration");
	__xamarin_class_map [2042].handle = objc_getClass ("NSWindowTab");
	__xamarin_class_map [2043].handle = objc_getClass ("NSWindowTabGroup");
	__xamarin_class_map [2044].handle = objc_getClass ("NSWorkspaceAuthorization");
	__xamarin_class_map [2045].handle = objc_getClass ("NSWorkspaceOpenConfiguration");
	__xamarin_class_map [2046].handle = objc_getClass ("MLDictionaryFeatureProvider");
	__xamarin_class_map [2047].handle = objc_getClass ("MLMultiArrayConstraint");
	__xamarin_class_map [2048].handle = objc_getClass ("MLArrayBatchProvider");
	__xamarin_class_map [2049].handle = objc_getClass ("Xamarin_Mac__CoreML_MLCustomModel");
	__xamarin_class_map [2050].handle = objc_getClass ("MLDictionaryConstraint");
	__xamarin_class_map [2051].handle = objc_getClass ("MLFeatureDescription");
	__xamarin_class_map [2052].handle = objc_getClass ("MLFeatureValue");
	__xamarin_class_map [2053].handle = objc_getClass ("MLImageConstraint");
	__xamarin_class_map [2054].handle = objc_getClass ("MLImageSize");
	__xamarin_class_map [2055].handle = objc_getClass ("MLImageSizeConstraint");
	__xamarin_class_map [2056].handle = objc_getClass ("MLKey");
	__xamarin_class_map [2057].handle = objc_getClass ("MLMetricKey");
	__xamarin_class_map [2058].handle = objc_getClass ("MLModel");
	__xamarin_class_map [2059].handle = objc_getClass ("MLModelConfiguration");
	__xamarin_class_map [2060].handle = objc_getClass ("MLModelDescription");
	__xamarin_class_map [2061].handle = objc_getClass ("MLMultiArrayShapeConstraint");
	__xamarin_class_map [2062].handle = objc_getClass ("MLNumericConstraint");
	__xamarin_class_map [2063].handle = objc_getClass ("MLParameterDescription");
	__xamarin_class_map [2064].handle = objc_getClass ("MLParameterKey");
	__xamarin_class_map [2065].handle = objc_getClass ("MLPredictionOptions");
	__xamarin_class_map [2066].handle = objc_getClass ("MLSequence");
	__xamarin_class_map [2067].handle = objc_getClass ("MLSequenceConstraint");
	__xamarin_class_map [2068].handle = objc_getClass ("MLTask");
	__xamarin_class_map [2069].handle = objc_getClass ("MLUpdateContext");
	__xamarin_class_map [2070].handle = objc_getClass ("MLUpdateProgressHandlers");
	__xamarin_class_map [2071].handle = objc_getClass ("MLUpdateTask");
	__xamarin_class_map [2072].handle = objc_getClass ("NSPropertyDescription");
	__xamarin_class_map [2073].handle = objc_getClass ("NSAttributeDescription");
	__xamarin_class_map [2074].handle = objc_getClass ("NSEntityDescription");
	__xamarin_class_map [2075].handle = objc_getClass ("NSMergeConflict");
	__xamarin_class_map [2076].handle = objc_getClass ("NSMergePolicy");
	__xamarin_class_map [2077].handle = objc_getClass ("NSPersistentStoreRequest");
	__xamarin_class_map [2078].handle = objc_getClass ("NSAsynchronousFetchRequest");
	__xamarin_class_map [2079].handle = objc_getClass ("NSPersistentStoreResult");
	__xamarin_class_map [2080].handle = objc_getClass ("NSPersistentStoreAsynchronousResult");
	__xamarin_class_map [2081].handle = objc_getClass ("NSAsynchronousFetchResult");
	__xamarin_class_map [2082].handle = objc_getClass ("NSPersistentStore");
	__xamarin_class_map [2083].handle = objc_getClass ("NSAtomicStore");
	__xamarin_class_map [2084].handle = objc_getClass ("NSAtomicStoreCacheNode");
	__xamarin_class_map [2085].handle = objc_getClass ("NSBatchDeleteRequest");
	__xamarin_class_map [2086].handle = objc_getClass ("NSBatchDeleteResult");
	__xamarin_class_map [2087].handle = objc_getClass ("NSBatchInsertRequest");
	__xamarin_class_map [2088].handle = objc_getClass ("NSBatchInsertResult");
	__xamarin_class_map [2089].handle = objc_getClass ("NSBatchUpdateRequest");
	__xamarin_class_map [2090].handle = objc_getClass ("NSBatchUpdateResult");
	__xamarin_class_map [2091].handle = objc_getClass ("NSConstraintConflict");
	__xamarin_class_map [2092].handle = objc_getClass ("NSCoreDataCoreSpotlightDelegate");
	__xamarin_class_map [2093].handle = objc_getClass ("NSDerivedAttributeDescription");
	__xamarin_class_map [2094].handle = objc_getClass ("NSEntityMapping");
	__xamarin_class_map [2095].handle = objc_getClass ("NSEntityMigrationPolicy");
	__xamarin_class_map [2096].handle = objc_getClass ("NSExpressionDescription");
	__xamarin_class_map [2097].handle = objc_getClass ("NSFetchedPropertyDescription");
	__xamarin_class_map [2098].handle = objc_getClass ("NSFetchIndexDescription");
	__xamarin_class_map [2099].handle = objc_getClass ("NSFetchIndexElementDescription");
	__xamarin_class_map [2100].handle = objc_getClass ("NSFetchRequest");
	__xamarin_class_map [2101].handle = objc_getClass ("NSExpression");
	__xamarin_class_map [2102].handle = objc_getClass ("NSFetchRequestExpression");
	__xamarin_class_map [2103].handle = objc_getClass ("NSIncrementalStore");
	__xamarin_class_map [2104].handle = objc_getClass ("NSIncrementalStoreNode");
	__xamarin_class_map [2105].handle = objc_getClass ("NSManagedObject");
	__xamarin_class_map [2106].handle = objc_getClass ("NSManagedObjectID");
	__xamarin_class_map [2107].handle = objc_getClass ("NSManagedObjectModel");
	__xamarin_class_map [2108].handle = objc_getClass ("NSMappingModel");
	__xamarin_class_map [2109].handle = objc_getClass ("NSMigrationManager");
	__xamarin_class_map [2110].handle = objc_getClass ("NSPersistentContainer");
	__xamarin_class_map [2111].handle = objc_getClass ("NSPersistentCloudKitContainer");
	__xamarin_class_map [2112].handle = objc_getClass ("NSPersistentCloudKitContainerOptions");
	__xamarin_class_map [2113].handle = objc_getClass ("NSPersistentHistoryChange");
	__xamarin_class_map [2114].handle = objc_getClass ("NSPersistentHistoryChangeRequest");
	__xamarin_class_map [2115].handle = objc_getClass ("NSPersistentHistoryResult");
	__xamarin_class_map [2116].handle = objc_getClass ("NSPersistentHistoryToken");
	__xamarin_class_map [2117].handle = objc_getClass ("NSPersistentHistoryTransaction");
	__xamarin_class_map [2118].handle = objc_getClass ("NSPersistentStoreDescription");
	__xamarin_class_map [2119].handle = objc_getClass ("NSPropertyMapping");
	__xamarin_class_map [2120].handle = objc_getClass ("NSQueryGenerationToken");
	__xamarin_class_map [2121].handle = objc_getClass ("NSRelationshipDescription");
	__xamarin_class_map [2122].handle = objc_getClass ("NSSaveChangesRequest");
	__xamarin_class_map [2123].handle = objc_getClass ("CBAttribute");
	__xamarin_class_map [2124].handle = objc_getClass ("CBCharacteristic");
	__xamarin_class_map [2125].handle = objc_getClass ("CBMutableCharacteristic");
	__xamarin_class_map [2126].handle = objc_getClass ("CBService");
	__xamarin_class_map [2127].handle = objc_getClass ("CBMutableService");
	__xamarin_class_map [2128].handle = objc_getClass ("CBUUID");
	__xamarin_class_map [2129].handle = objc_getClass ("CBATTRequest");
	__xamarin_class_map [2130].handle = objc_getClass ("CBPeer");
	__xamarin_class_map [2131].handle = objc_getClass ("CBCentral");
	__xamarin_class_map [2132].handle = objc_getClass ("CBCentralManagerDelegate");
	__xamarin_class_map [2133].handle = objc_getClass ("CBDescriptor");
	__xamarin_class_map [2134].handle = objc_getClass ("CBL2CAPChannel");
	__xamarin_class_map [2135].handle = objc_getClass ("CBManager");
	__xamarin_class_map [2136].handle = objc_getClass ("CBMutableDescriptor");
	__xamarin_class_map [2137].handle = objc_getClass ("CBPeripheralDelegate");
	__xamarin_class_map [2138].handle = objc_getClass ("CBPeripheralManagerDelegate");
	__xamarin_class_map [2139].handle = objc_getClass ("AVCaptureView");
	__xamarin_class_map [2140].handle = objc_getClass ("AVCaptureViewDelegate");
	__xamarin_class_map [2141].handle = objc_getClass ("AVPictureInPictureController");
	__xamarin_class_map [2142].handle = objc_getClass ("AVPictureInPictureControllerDelegate");
	__xamarin_class_map [2143].handle = objc_getClass ("AVPlayerView");
	__xamarin_class_map [2144].handle = objc_getClass ("Xamarin_Mac__AVKit_AVPlayerViewPictureInPictureDelegate");
	__xamarin_class_map [2145].handle = objc_getClass ("AVRoutePickerView");
	__xamarin_class_map [2146].handle = objc_getClass ("AVRoutePickerViewDelegate");
	__xamarin_class_map [2147].handle = objc_getClass ("AVAssetImageGenerator");
	__xamarin_class_map [2148].handle = objc_getClass ("AVAssetReaderOutput");
	__xamarin_class_map [2149].handle = objc_getClass ("AVAssetReaderVideoCompositionOutput");
	__xamarin_class_map [2150].handle = objc_getClass ("AVAssetResourceLoadingDataRequest");
	__xamarin_class_map [2151].handle = objc_getClass ("AVAudioBuffer");
	__xamarin_class_map [2152].handle = objc_getClass ("AVAudioChannelLayout");
	__xamarin_class_map [2153].handle = objc_getClass ("AVAudioFormat");
	__xamarin_class_map [2154].handle = objc_getClass ("AVAudioPlayer");
	__xamarin_class_map [2155].handle = objc_getClass ("AVAudioRecorder");
	__xamarin_class_map [2156].handle = objc_getClass ("AVCaptureConnection");
	__xamarin_class_map [2157].handle = objc_getClass ("AVCaptureInput");
	__xamarin_class_map [2158].handle = objc_getClass ("AVCaptureDeviceInput");
	__xamarin_class_map [2159].handle = objc_getClass ("AVCaptureSynchronizedDataCollection");
	__xamarin_class_map [2160].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizer");
	__xamarin_class_map [2161].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizerDelegate");
	__xamarin_class_map [2162].handle = objc_getClass ("AVAssetTrack");
	__xamarin_class_map [2163].handle = objc_getClass ("AVCompositionTrack");
	__xamarin_class_map [2164].handle = objc_getClass ("AVMutableCompositionTrack");
	__xamarin_class_map [2165].handle = objc_getClass ("AVCaptureAudioDataOutputSampleBufferDelegate");
	__xamarin_class_map [2166].handle = objc_getClass ("AVCaptureInputPort");
	__xamarin_class_map [2167].handle = objc_getClass ("AVAudioConnectionPoint");
	__xamarin_class_map [2168].handle = objc_getClass ("AVContentKeyResponse");
	__xamarin_class_map [2169].handle = objc_getClass ("AVDepthData");
	__xamarin_class_map [2170].handle = objc_getClass ("AVAsset");
	__xamarin_class_map [2171].handle = objc_getClass ("AVURLAsset");
	__xamarin_class_map [2172].handle = objc_getClass ("AVFragmentedAsset");
	__xamarin_class_map [2173].handle = objc_getClass ("AVFragmentedAssetTrack");
	__xamarin_class_map [2174].handle = objc_getClass ("AVPlayerLayer");
	__xamarin_class_map [2175].handle = objc_getClass ("AVMetadataItemFilter");
	__xamarin_class_map [2176].handle = objc_getClass ("AVTextStyleRule");
	__xamarin_class_map [2177].handle = objc_getClass ("AVAudioPlayerDelegate");
	__xamarin_class_map [2178].handle = objc_getClass ("AVFoundation_InternalAVAudioPlayerDelegate");
	__xamarin_class_map [2179].handle = objc_getClass ("AVAudioRecorderDelegate");
	__xamarin_class_map [2180].handle = objc_getClass ("AVFoundation_InternalAVAudioRecorderDelegate");
	__xamarin_class_map [2181].handle = objc_getClass ("AVPlayerLooper");
	__xamarin_class_map [2182].handle = objc_getClass ("AVAssetCache");
	__xamarin_class_map [2183].handle = objc_getClass ("AVAssetReader");
	__xamarin_class_map [2184].handle = objc_getClass ("AVAssetReaderAudioMixOutput");
	__xamarin_class_map [2185].handle = objc_getClass ("AVAssetReaderOutputMetadataAdaptor");
	__xamarin_class_map [2186].handle = objc_getClass ("AVAssetReaderSampleReferenceOutput");
	__xamarin_class_map [2187].handle = objc_getClass ("AVAssetReaderTrackOutput");
	__xamarin_class_map [2188].handle = objc_getClass ("AVAssetResourceLoader");
	__xamarin_class_map [2189].handle = objc_getClass ("AVAssetResourceLoaderDelegate");
	__xamarin_class_map [2190].handle = objc_getClass ("AVAssetResourceLoadingContentInformationRequest");
	__xamarin_class_map [2191].handle = objc_getClass ("AVAssetResourceLoadingRequest");
	__xamarin_class_map [2192].handle = objc_getClass ("AVAssetResourceLoadingRequestor");
	__xamarin_class_map [2193].handle = objc_getClass ("AVAssetResourceRenewalRequest");
	__xamarin_class_map [2194].handle = objc_getClass ("AVAssetTrackGroup");
	__xamarin_class_map [2195].handle = objc_getClass ("AVAssetTrackSegment");
	__xamarin_class_map [2196].handle = objc_getClass ("AVAssetWriterInput");
	__xamarin_class_map [2197].handle = objc_getClass ("AVMediaSelectionGroup");
	__xamarin_class_map [2198].handle = objc_getClass ("AVAssetWriterInputGroup");
	__xamarin_class_map [2199].handle = objc_getClass ("AVAssetWriterInputMetadataAdaptor");
	__xamarin_class_map [2200].handle = objc_getClass ("AVAssetWriterInputPassDescription");
	__xamarin_class_map [2201].handle = objc_getClass ("AVAssetWriterInputPixelBufferAdaptor");
	__xamarin_class_map [2202].handle = objc_getClass ("AVAsynchronousCIImageFilteringRequest");
	__xamarin_class_map [2203].handle = objc_getClass ("AVAsynchronousKeyValueLoading");
	__xamarin_class_map [2204].handle = objc_getClass ("AVAsynchronousVideoCompositionRequest");
	__xamarin_class_map [2205].handle = objc_getClass ("AVAudio3DMixing");
	__xamarin_class_map [2206].handle = objc_getClass ("AVAudioCompressedBuffer");
	__xamarin_class_map [2207].handle = objc_getClass ("AVAudioConverter");
	__xamarin_class_map [2208].handle = objc_getClass ("AVAudioEnvironmentDistanceAttenuationParameters");
	__xamarin_class_map [2209].handle = objc_getClass ("AVAudioNode");
	__xamarin_class_map [2210].handle = objc_getClass ("AVAudioEnvironmentNode");
	__xamarin_class_map [2211].handle = objc_getClass ("AVAudioEnvironmentReverbParameters");
	__xamarin_class_map [2212].handle = objc_getClass ("AVAudioFile");
	__xamarin_class_map [2213].handle = objc_getClass ("AVAudioIONode");
	__xamarin_class_map [2214].handle = objc_getClass ("AVAudioInputNode");
	__xamarin_class_map [2215].handle = objc_getClass ("AVAudioMix");
	__xamarin_class_map [2216].handle = objc_getClass ("AVAudioMixerNode");
	__xamarin_class_map [2217].handle = objc_getClass ("AVAudioMixingDestination");
	__xamarin_class_map [2218].handle = objc_getClass ("AVAudioMixInputParameters");
	__xamarin_class_map [2219].handle = objc_getClass ("AVAudioOutputNode");
	__xamarin_class_map [2220].handle = objc_getClass ("AVAudioPCMBuffer");
	__xamarin_class_map [2221].handle = objc_getClass ("AVAudioSequencer");
	__xamarin_class_map [2222].handle = objc_getClass ("AVAudioSinkNode");
	__xamarin_class_map [2223].handle = objc_getClass ("AVAudioSourceNode");
	__xamarin_class_map [2224].handle = objc_getClass ("AVAudioStereoMixing");
	__xamarin_class_map [2225].handle = objc_getClass ("AVAudioTime");
	__xamarin_class_map [2226].handle = objc_getClass ("AVAudioUnit");
	__xamarin_class_map [2227].handle = objc_getClass ("AVAudioUnitEffect");
	__xamarin_class_map [2228].handle = objc_getClass ("AVAudioUnitDelay");
	__xamarin_class_map [2229].handle = objc_getClass ("AVAudioUnitDistortion");
	__xamarin_class_map [2230].handle = objc_getClass ("AVAudioUnitEQ");
	__xamarin_class_map [2231].handle = objc_getClass ("AVAudioUnitEQFilterParameters");
	__xamarin_class_map [2232].handle = objc_getClass ("AVAudioUnitGenerator");
	__xamarin_class_map [2233].handle = objc_getClass ("AVAudioUnitMIDIInstrument");
	__xamarin_class_map [2234].handle = objc_getClass ("AVAudioUnitReverb");
	__xamarin_class_map [2235].handle = objc_getClass ("AVAudioUnitSampler");
	__xamarin_class_map [2236].handle = objc_getClass ("AVAudioUnitTimeEffect");
	__xamarin_class_map [2237].handle = objc_getClass ("AVAudioUnitTimePitch");
	__xamarin_class_map [2238].handle = objc_getClass ("AVAudioUnitVarispeed");
	__xamarin_class_map [2239].handle = objc_getClass ("AVCameraCalibrationData");
	__xamarin_class_map [2240].handle = objc_getClass ("AVCaptureAudioChannel");
	__xamarin_class_map [2241].handle = objc_getClass ("AVCaptureOutput");
	__xamarin_class_map [2242].handle = objc_getClass ("AVCaptureAudioDataOutput");
	__xamarin_class_map [2243].handle = objc_getClass ("AVCaptureFileOutput");
	__xamarin_class_map [2244].handle = objc_getClass ("AVCaptureAudioFileOutput");
	__xamarin_class_map [2245].handle = objc_getClass ("AVCaptureAudioPreviewOutput");
	__xamarin_class_map [2246].handle = objc_getClass ("AVCaptureDeviceDiscoverySession");
	__xamarin_class_map [2247].handle = objc_getClass ("AVCaptureDeviceFormat");
	__xamarin_class_map [2248].handle = objc_getClass ("AVCaptureDeviceInputSource");
	__xamarin_class_map [2249].handle = objc_getClass ("AVCaptureFileOutputDelegate");
	__xamarin_class_map [2250].handle = objc_getClass ("AVCaptureFileOutputRecordingDelegate");
	__xamarin_class_map [2251].handle = objc_getClass ("AVCaptureMovieFileOutput");
	__xamarin_class_map [2252].handle = objc_getClass ("AVCapturePhoto");
	__xamarin_class_map [2253].handle = objc_getClass ("AVCapturePhotoCaptureDelegate");
	__xamarin_class_map [2254].handle = objc_getClass ("AVCaptureResolvedPhotoSettings");
	__xamarin_class_map [2255].handle = objc_getClass ("AVCaptureScreenInput");
	__xamarin_class_map [2256].handle = objc_getClass ("AVCaptureSynchronizedData");
	__xamarin_class_map [2257].handle = objc_getClass ("AVCaptureVideoDataOutput");
	__xamarin_class_map [2258].handle = objc_getClass ("AVCaptureVideoDataOutputSampleBufferDelegate");
	__xamarin_class_map [2259].handle = objc_getClass ("AVComposition");
	__xamarin_class_map [2260].handle = objc_getClass ("AVCompositionTrackFormatDescriptionReplacement");
	__xamarin_class_map [2261].handle = objc_getClass ("AVCompositionTrackSegment");
	__xamarin_class_map [2262].handle = objc_getClass ("AVContentKeySessionDelegate");
	__xamarin_class_map [2263].handle = objc_getClass ("AVMetadataGroup");
	__xamarin_class_map [2264].handle = objc_getClass ("AVDateRangeMetadataGroup");
	__xamarin_class_map [2265].handle = objc_getClass ("AVFragmentedAssetMinder");
	__xamarin_class_map [2266].handle = objc_getClass ("AVFragmentedMovieMinder");
	__xamarin_class_map [2267].handle = objc_getClass ("AVFrameRateRange");
	__xamarin_class_map [2268].handle = objc_getClass ("AVMediaDataStorage");
	__xamarin_class_map [2269].handle = objc_getClass ("AVMediaSelection");
	__xamarin_class_map [2270].handle = objc_getClass ("AVMediaSelectionOption");
	__xamarin_class_map [2271].handle = objc_getClass ("AVMetadataObject");
	__xamarin_class_map [2272].handle = objc_getClass ("AVMetadataBodyObject");
	__xamarin_class_map [2273].handle = objc_getClass ("AVMetadataCatBodyObject");
	__xamarin_class_map [2274].handle = objc_getClass ("AVMetadataDogBodyObject");
	__xamarin_class_map [2275].handle = objc_getClass ("AVMetadataFaceObject");
	__xamarin_class_map [2276].handle = objc_getClass ("AVMetadataHumanBodyObject");
	__xamarin_class_map [2277].handle = objc_getClass ("AVMetadataItemValueRequest");
	__xamarin_class_map [2278].handle = objc_getClass ("AVMetadataMachineReadableCodeObject");
	__xamarin_class_map [2279].handle = objc_getClass ("AVMetadataSalientObject");
	__xamarin_class_map [2280].handle = objc_getClass ("AVMovie");
	__xamarin_class_map [2281].handle = objc_getClass ("AVMovieTrack");
	__xamarin_class_map [2282].handle = objc_getClass ("AVMusicTrack");
	__xamarin_class_map [2283].handle = objc_getClass ("AVMutableAudioMix");
	__xamarin_class_map [2284].handle = objc_getClass ("AVMutableAudioMixInputParameters");
	__xamarin_class_map [2285].handle = objc_getClass ("AVMutableComposition");
	__xamarin_class_map [2286].handle = objc_getClass ("AVMutableDateRangeMetadataGroup");
	__xamarin_class_map [2287].handle = objc_getClass ("AVMutableMediaSelection");
	__xamarin_class_map [2288].handle = objc_getClass ("AVMetadataItem");
	__xamarin_class_map [2289].handle = objc_getClass ("AVMutableMetadataItem");
	__xamarin_class_map [2290].handle = objc_getClass ("AVMutableMovie");
	__xamarin_class_map [2291].handle = objc_getClass ("AVMutableMovieTrack");
	__xamarin_class_map [2292].handle = objc_getClass ("AVTimedMetadataGroup");
	__xamarin_class_map [2293].handle = objc_getClass ("AVMutableTimedMetadataGroup");
	__xamarin_class_map [2294].handle = objc_getClass ("AVVideoComposition");
	__xamarin_class_map [2295].handle = objc_getClass ("AVMutableVideoComposition");
	__xamarin_class_map [2296].handle = objc_getClass ("AVVideoCompositionInstruction");
	__xamarin_class_map [2297].handle = objc_getClass ("AVMutableVideoCompositionInstruction");
	__xamarin_class_map [2298].handle = objc_getClass ("AVVideoCompositionLayerInstruction");
	__xamarin_class_map [2299].handle = objc_getClass ("AVMutableVideoCompositionLayerInstruction");
	__xamarin_class_map [2300].handle = objc_getClass ("AVOutputSettingsAssistant");
	__xamarin_class_map [2301].handle = objc_getClass ("AVContentKeyRequest");
	__xamarin_class_map [2302].handle = objc_getClass ("AVPersistableContentKeyRequest");
	__xamarin_class_map [2303].handle = objc_getClass ("AVPlayerItemAccessLog");
	__xamarin_class_map [2304].handle = objc_getClass ("AVPlayerItemAccessLogEvent");
	__xamarin_class_map [2305].handle = objc_getClass ("AVPlayerItemErrorLog");
	__xamarin_class_map [2306].handle = objc_getClass ("AVPlayerItemErrorLogEvent");
	__xamarin_class_map [2307].handle = objc_getClass ("AVPlayerItemOutput");
	__xamarin_class_map [2308].handle = objc_getClass ("AVPlayerItemLegibleOutput");
	__xamarin_class_map [2309].handle = objc_getClass ("AVPlayerItemOutputPushDelegate");
	__xamarin_class_map [2310].handle = objc_getClass ("AVPlayerItemLegibleOutputPushDelegate");
	__xamarin_class_map [2311].handle = objc_getClass ("AVPlayerItemMediaDataCollector");
	__xamarin_class_map [2312].handle = objc_getClass ("AVPlayerItemMetadataCollector");
	__xamarin_class_map [2313].handle = objc_getClass ("AVPlayerItemMetadataCollectorPushDelegate");
	__xamarin_class_map [2314].handle = objc_getClass ("AVPlayerItemMetadataOutput");
	__xamarin_class_map [2315].handle = objc_getClass ("AVPlayerItemMetadataOutputPushDelegate");
	__xamarin_class_map [2316].handle = objc_getClass ("AVPlayerItemOutputPullDelegate");
	__xamarin_class_map [2317].handle = objc_getClass ("AVPlayerItemTrack");
	__xamarin_class_map [2318].handle = objc_getClass ("AVPortraitEffectsMatte");
	__xamarin_class_map [2319].handle = objc_getClass ("AVPlayer");
	__xamarin_class_map [2320].handle = objc_getClass ("AVQueuePlayer");
	__xamarin_class_map [2321].handle = objc_getClass ("AVSampleBufferRequest");
	__xamarin_class_map [2322].handle = objc_getClass ("AVSampleCursor");
	__xamarin_class_map [2323].handle = objc_getClass ("AVSemanticSegmentationMatte");
	__xamarin_class_map [2324].handle = objc_getClass ("AVSpeechSynthesisVoice");
	__xamarin_class_map [2325].handle = objc_getClass ("AVSpeechSynthesizerDelegate");
	__xamarin_class_map [2326].handle = objc_getClass ("AVSpeechUtterance");
	__xamarin_class_map [2327].handle = objc_getClass ("AVSynchronizedLayer");
	__xamarin_class_map [2328].handle = objc_getClass ("AVVideoCompositing");
	__xamarin_class_map [2329].handle = objc_getClass ("AVVideoCompositionCoreAnimationTool");
	__xamarin_class_map [2330].handle = objc_getClass ("AVVideoCompositionRenderContext");
	__xamarin_class_map [2331].handle = objc_getClass ("AVVideoCompositionRenderHint");
	__xamarin_class_map [2332].handle = objc_getClass ("AVVideoCompositionValidationHandling");
	__xamarin_class_map [2333].handle = objc_getClass ("ASAuthorization");
	__xamarin_class_map [2334].handle = objc_getClass ("ASAuthorizationRequest");
	__xamarin_class_map [2335].handle = objc_getClass ("ASAuthorizationAppleIDButton");
	__xamarin_class_map [2336].handle = objc_getClass ("ASAuthorizationOpenIDRequest");
	__xamarin_class_map [2337].handle = objc_getClass ("ASAuthorizationAppleIDRequest");
	__xamarin_class_map [2338].handle = objc_getClass ("ASAuthorizationController");
	__xamarin_class_map [2339].handle = objc_getClass ("Xamarin_Mac__AuthenticationServices_ASAuthorizationControllerDelegate");
	__xamarin_class_map [2340].handle = objc_getClass ("ASAuthorizationPasswordProvider");
	__xamarin_class_map [2341].handle = objc_getClass ("ASAuthorizationPasswordRequest");
	__xamarin_class_map [2342].handle = objc_getClass ("ASAuthorizationSingleSignOnProvider");
	__xamarin_class_map [2343].handle = objc_getClass ("ASAuthorizationSingleSignOnRequest");
	__xamarin_class_map [2344].handle = objc_getClass ("ASPasswordCredential");
	__xamarin_class_map [2345].handle = objc_getClass ("ASWebAuthenticationSession");
	__xamarin_class_map [2346].handle = objc_getClass ("ASWebAuthenticationSessionRequest");
	__xamarin_class_map [2347].handle = objc_getClass ("Xamarin_Mac__AuthenticationServices_ASWebAuthenticationSessionRequestDelegate");
	__xamarin_class_map [2348].handle = objc_getClass ("ASWebAuthenticationSessionWebBrowserSessionManager");
	__xamarin_class_map [2349].handle = objc_getClass ("NSAppleEventDescriptor");
	__xamarin_class_map [2350].handle = objc_getClass ("NSBundle");
	__xamarin_class_map [2351].handle = objc_getClass ("NSConnection");
	__xamarin_class_map [2352].handle = objc_getClass ("NSDate");
	__xamarin_class_map [2353].handle = objc_getClass ("NSEnumerator");
	__xamarin_class_map [2354].handle = objc_getClass ("NSDirectoryEnumerator");
	__xamarin_class_map [2355].handle = objc_getClass ("NSFileManagerDelegate");
	__xamarin_class_map [2356].handle = objc_getClass ("NSHTTPCookie");
	__xamarin_class_map [2357].handle = objc_getClass ("NSStream");
	__xamarin_class_map [2358].handle = objc_getClass ("NSInputStream");
	__xamarin_class_map [2359].handle = objc_getClass ("NSJSONSerialization");
	__xamarin_class_map [2360].handle = objc_getClass ("NSMetadataItem");
	__xamarin_class_map [2361].handle = objc_getClass ("NSAttributedString");
	__xamarin_class_map [2362].handle = objc_getClass ("NSMutableAttributedString");
	__xamarin_class_map [2363].handle = objc_getClass ("NSOrderedSet");
	__xamarin_class_map [2364].handle = objc_getClass ("NSMutableOrderedSet");
	__xamarin_class_map [2365].handle = objc_getClass ("NSSet");
	__xamarin_class_map [2366].handle = objc_getClass ("NSMutableSet");
	__xamarin_class_map [2367].handle = objc_getClass ("NSMutableString");
	__xamarin_class_map [2368].handle = objc_getClass ("NSURLRequest");
	__xamarin_class_map [2369].handle = objc_getClass ("NSMutableURLRequest");
	__xamarin_class_map [2370].handle = objc_getClass ("Foundation_InternalNSNotificationHandler");
	__xamarin_class_map [2371].handle = objc_getClass ("NSNull");
	__xamarin_class_map [2372].handle = objc_getClass ("NSOutputStream");
	__xamarin_class_map [2373].handle = objc_getClass ("NSPredicate");
	__xamarin_class_map [2374].handle = objc_getClass ("NSPropertyListSerialization");
	__xamarin_class_map [2375].handle = objc_getClass ("NSProxy");
	__xamarin_class_map [2376].handle = objc_getClass ("NSRunLoop");
	__xamarin_class_map [2377].handle = objc_getClass ("NSScriptCommandDescription");
	__xamarin_class_map [2378].handle = objc_getClass ("NSTimer");
	__xamarin_class_map [2379].handle = objc_getClass ("NSTimeZone");
	__xamarin_class_map [2380].handle = objc_getClass ("NSUnit");
	__xamarin_class_map [2381].handle = objc_getClass ("NSDimension");
	__xamarin_class_map [2382].handle = objc_getClass ("NSUnitAcceleration");
	__xamarin_class_map [2383].handle = objc_getClass ("NSUnitAngle");
	__xamarin_class_map [2384].handle = objc_getClass ("NSUnitArea");
	__xamarin_class_map [2385].handle = objc_getClass ("NSUnitConcentrationMass");
	__xamarin_class_map [2386].handle = objc_getClass ("NSUnitDispersion");
	__xamarin_class_map [2387].handle = objc_getClass ("NSUnitDuration");
	__xamarin_class_map [2388].handle = objc_getClass ("NSUnitElectricCharge");
	__xamarin_class_map [2389].handle = objc_getClass ("NSUnitElectricCurrent");
	__xamarin_class_map [2390].handle = objc_getClass ("NSUnitElectricPotentialDifference");
	__xamarin_class_map [2391].handle = objc_getClass ("NSUnitElectricResistance");
	__xamarin_class_map [2392].handle = objc_getClass ("NSUnitEnergy");
	__xamarin_class_map [2393].handle = objc_getClass ("NSUnitFrequency");
	__xamarin_class_map [2394].handle = objc_getClass ("NSUnitFuelEfficiency");
	__xamarin_class_map [2395].handle = objc_getClass ("NSUnitLength");
	__xamarin_class_map [2396].handle = objc_getClass ("NSUnitIlluminance");
	__xamarin_class_map [2397].handle = objc_getClass ("NSUnitMass");
	__xamarin_class_map [2398].handle = objc_getClass ("NSUnitPower");
	__xamarin_class_map [2399].handle = objc_getClass ("NSUnitPressure");
	__xamarin_class_map [2400].handle = objc_getClass ("NSUnitSpeed");
	__xamarin_class_map [2401].handle = objc_getClass ("NSUnitVolume");
	__xamarin_class_map [2402].handle = objc_getClass ("NSURLComponents");
	__xamarin_class_map [2403].handle = objc_getClass ("NSURLCredential");
	__xamarin_class_map [2404].handle = objc_getClass ("NSURLProtectionSpace");
	__xamarin_class_map [2405].handle = objc_getClass ("NSURLProtocol");
	__xamarin_class_map [2406].handle = objc_getClass ("Foundation_NSUrlProtocolClient");
	__xamarin_class_map [2407].handle = objc_getClass ("NSUUID");
	__xamarin_class_map [2408].handle = objc_getClass ("NSAppleEventManager");
	__xamarin_class_map [2409].handle = objc_getClass ("Foundation_NSDispatcher");
	__xamarin_class_map [2410].handle = objc_getClass ("__MonoMac_NSActionDispatcher");
	__xamarin_class_map [2411].handle = objc_getClass ("__MonoMac_NSSynchronizationContextDispatcher");
	__xamarin_class_map [2412].handle = objc_getClass ("__Xamarin_NSTimerActionDispatcher");
	__xamarin_class_map [2413].handle = objc_getClass ("Foundation_NSAsyncDispatcher");
	__xamarin_class_map [2414].handle = objc_getClass ("__MonoMac_NSAsyncActionDispatcher");
	__xamarin_class_map [2415].handle = objc_getClass ("__MonoMac_NSAsyncSynchronizationContextDispatcher");
	__xamarin_class_map [2416].handle = objc_getClass ("NSAutoreleasePool");
	__xamarin_class_map [2417].handle = objc_getClass ("NSError");
	__xamarin_class_map [2418].handle = objc_getClass ("NSValue");
	__xamarin_class_map [2419].handle = objc_getClass ("NSNumber");
	__xamarin_class_map [2420].handle = objc_getClass ("NSDateComponents");
	__xamarin_class_map [2421].handle = objc_getClass ("NSAffineTransform");
	__xamarin_class_map [2422].handle = objc_getClass ("NSAppleScript");
	__xamarin_class_map [2423].handle = objc_getClass ("NSBindingSelectionMarker");
	__xamarin_class_map [2424].handle = objc_getClass ("NSBlockOperation");
	__xamarin_class_map [2425].handle = objc_getClass ("NSByteCountFormatter");
	__xamarin_class_map [2426].handle = objc_getClass ("NSCacheDelegate");
	__xamarin_class_map [2427].handle = objc_getClass ("NSCachedURLResponse");
	__xamarin_class_map [2428].handle = objc_getClass ("NSCalendarDate");
	__xamarin_class_map [2429].handle = objc_getClass ("NSCharacterSet");
	__xamarin_class_map [2430].handle = objc_getClass ("NSCoding");
	__xamarin_class_map [2431].handle = objc_getClass ("NSComparisonPredicate");
	__xamarin_class_map [2432].handle = objc_getClass ("NSCompoundPredicate");
	__xamarin_class_map [2433].handle = objc_getClass ("NSCondition");
	__xamarin_class_map [2434].handle = objc_getClass ("NSConditionLock");
	__xamarin_class_map [2435].handle = objc_getClass ("NSConnectionDelegate");
	__xamarin_class_map [2436].handle = objc_getClass ("NSCopying");
	__xamarin_class_map [2437].handle = objc_getClass ("NSRegularExpression");
	__xamarin_class_map [2438].handle = objc_getClass ("NSDataDetector");
	__xamarin_class_map [2439].handle = objc_getClass ("NSDateComponentsFormatter");
	__xamarin_class_map [2440].handle = objc_getClass ("NSDateFormatter");
	__xamarin_class_map [2441].handle = objc_getClass ("NSDateInterval");
	__xamarin_class_map [2442].handle = objc_getClass ("NSDateIntervalFormatter");
	__xamarin_class_map [2443].handle = objc_getClass ("NSDecimalNumber");
	__xamarin_class_map [2444].handle = objc_getClass ("NSDistantObjectRequest");
	__xamarin_class_map [2445].handle = objc_getClass ("NSDistributedLock");
	__xamarin_class_map [2446].handle = objc_getClass ("NSNotificationCenter");
	__xamarin_class_map [2447].handle = objc_getClass ("NSDistributedNotificationCenter");
	__xamarin_class_map [2448].handle = objc_getClass ("NSEnergyFormatter");
	__xamarin_class_map [2449].handle = objc_getClass ("NSException");
	__xamarin_class_map [2450].handle = objc_getClass ("NSExtensionItem");
	__xamarin_class_map [2451].handle = objc_getClass ("NSExtensionRequestHandling");
	__xamarin_class_map [2452].handle = objc_getClass ("NSFileAccessIntent");
	__xamarin_class_map [2453].handle = objc_getClass ("NSFileCoordinator");
	__xamarin_class_map [2454].handle = objc_getClass ("NSFilePresenter");
	__xamarin_class_map [2455].handle = objc_getClass ("NSFileProviderService");
	__xamarin_class_map [2456].handle = objc_getClass ("NSFileWrapper");
	__xamarin_class_map [2457].handle = objc_getClass ("NSURLResponse");
	__xamarin_class_map [2458].handle = objc_getClass ("NSHTTPURLResponse");
	__xamarin_class_map [2459].handle = objc_getClass ("NSInvocation");
	__xamarin_class_map [2460].handle = objc_getClass ("NSISO8601DateFormatter");
	__xamarin_class_map [2461].handle = objc_getClass ("NSKeyedArchiverDelegate");
	__xamarin_class_map [2462].handle = objc_getClass ("NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2463].handle = objc_getClass ("NSLengthFormatter");
	__xamarin_class_map [2464].handle = objc_getClass ("NSLinguisticTagger");
	__xamarin_class_map [2465].handle = objc_getClass ("NSListFormatter");
	__xamarin_class_map [2466].handle = objc_getClass ("NSLock");
	__xamarin_class_map [2467].handle = objc_getClass ("NSPort");
	__xamarin_class_map [2468].handle = objc_getClass ("NSMachPort");
	__xamarin_class_map [2469].handle = objc_getClass ("NSPortDelegate");
	__xamarin_class_map [2470].handle = objc_getClass ("NSMachPortDelegate");
	__xamarin_class_map [2471].handle = objc_getClass ("NSMassFormatter");
	__xamarin_class_map [2472].handle = objc_getClass ("NSMeasurement");
	__xamarin_class_map [2473].handle = objc_getClass ("NSMeasurementFormatter");
	__xamarin_class_map [2474].handle = objc_getClass ("NSMetadataQueryAttributeValueTuple");
	__xamarin_class_map [2475].handle = objc_getClass ("NSMetadataQueryDelegate");
	__xamarin_class_map [2476].handle = objc_getClass ("NSMetadataQueryResultGroup");
	__xamarin_class_map [2477].handle = objc_getClass ("NSMethodSignature");
	__xamarin_class_map [2478].handle = objc_getClass ("NSMutableCharacterSet");
	__xamarin_class_map [2479].handle = objc_getClass ("NSMutableCopying");
	__xamarin_class_map [2480].handle = objc_getClass ("NSIndexSet");
	__xamarin_class_map [2481].handle = objc_getClass ("NSMutableIndexSet");
	__xamarin_class_map [2482].handle = objc_getClass ("NSNetServiceBrowserDelegate");
	__xamarin_class_map [2483].handle = objc_getClass ("NSNetServiceDelegate");
	__xamarin_class_map [2484].handle = objc_getClass ("NSNotification");
	__xamarin_class_map [2485].handle = objc_getClass ("NSNotificationQueue");
	__xamarin_class_map [2486].handle = objc_getClass ("NSNumberFormatter");
	__xamarin_class_map [2487].handle = objc_getClass ("NSOperationQueue");
	__xamarin_class_map [2488].handle = objc_getClass ("NSOrthography");
	__xamarin_class_map [2489].handle = objc_getClass ("NSPersonNameComponents");
	__xamarin_class_map [2490].handle = objc_getClass ("NSPersonNameComponentsFormatter");
	__xamarin_class_map [2491].handle = objc_getClass ("NSPipe");
	__xamarin_class_map [2492].handle = objc_getClass ("NSPortMessage");
	__xamarin_class_map [2493].handle = objc_getClass ("NSPortNameServer");
	__xamarin_class_map [2494].handle = objc_getClass ("NSData");
	__xamarin_class_map [2495].handle = objc_getClass ("NSMutableData");
	__xamarin_class_map [2496].handle = objc_getClass ("NSPurgeableData");
	__xamarin_class_map [2497].handle = objc_getClass ("NSRecursiveLock");
	__xamarin_class_map [2498].handle = objc_getClass ("NSRelativeDateTimeFormatter");
	__xamarin_class_map [2499].handle = objc_getClass ("NSScriptCommand");
	__xamarin_class_map [2500].handle = objc_getClass ("NSStreamDelegate");
	__xamarin_class_map [2501].handle = objc_getClass ("NSTextCheckingResult");
	__xamarin_class_map [2502].handle = objc_getClass ("NSUnitConverter");
	__xamarin_class_map [2503].handle = objc_getClass ("NSUnitConverterLinear");
	__xamarin_class_map [2504].handle = objc_getClass ("NSUnitInformationStorage");
	__xamarin_class_map [2505].handle = objc_getClass ("NSUnitTemperature");
	__xamarin_class_map [2506].handle = objc_getClass ("NSURLAuthenticationChallenge");
	__xamarin_class_map [2507].handle = objc_getClass ("NSURLAuthenticationChallengeSender");
	__xamarin_class_map [2508].handle = objc_getClass ("NSURLConnectionDelegate");
	__xamarin_class_map [2509].handle = objc_getClass ("NSURLConnectionDataDelegate");
	__xamarin_class_map [2510].handle = objc_getClass ("NSURLConnectionDownloadDelegate");
	__xamarin_class_map [2511].handle = objc_getClass ("NSUrlDownloadDelegate");
	__xamarin_class_map [2512].handle = objc_getClass ("NSURLQueryItem");
	__xamarin_class_map [2513].handle = objc_getClass ("NSURLSessionConfiguration");
	__xamarin_class_map [2514].handle = objc_getClass ("NSURLSessionDelegate");
	__xamarin_class_map [2515].handle = objc_getClass ("NSURLSessionTaskDelegate");
	__xamarin_class_map [2516].handle = objc_getClass ("NSURLSessionDataDelegate");
	__xamarin_class_map [2517].handle = objc_getClass ("NSURLSessionTask");
	__xamarin_class_map [2518].handle = objc_getClass ("NSURLSessionDataTask");
	__xamarin_class_map [2519].handle = objc_getClass ("NSURLSessionDownloadDelegate");
	__xamarin_class_map [2520].handle = objc_getClass ("NSURLSessionDownloadTask");
	__xamarin_class_map [2521].handle = objc_getClass ("NSURLSessionStreamDelegate");
	__xamarin_class_map [2522].handle = objc_getClass ("NSURLSessionTaskMetrics");
	__xamarin_class_map [2523].handle = objc_getClass ("NSURLSessionTaskTransactionMetrics");
	__xamarin_class_map [2524].handle = objc_getClass ("NSURLSessionUploadTask");
	__xamarin_class_map [2525].handle = objc_getClass ("Xamarin_Mac__Foundation_NSUrlSessionWebSocketDelegate");
	__xamarin_class_map [2526].handle = objc_getClass ("NSURLSessionWebSocketMessage");
	__xamarin_class_map [2527].handle = objc_getClass ("NSUserActivityDelegate");
	__xamarin_class_map [2528].handle = objc_getClass ("NSUserNotification");
	__xamarin_class_map [2529].handle = objc_getClass ("NSUserNotificationAction");
	__xamarin_class_map [2530].handle = objc_getClass ("NSUserNotificationCenterDelegate");
	__xamarin_class_map [2531].handle = objc_getClass ("NSValueTransformer");
	__xamarin_class_map [2532].handle = objc_getClass ("NSXPCListenerEndpoint");
	__xamarin_class_map [2533].handle = objc_getClass ("SNAudioFileAnalyzer");
	__xamarin_class_map [2534].handle = objc_getClass ("SFContentBlockerManager");
	__xamarin_class_map [2535].handle = objc_getClass ("SFSafariApplication");
	__xamarin_class_map [2536].handle = objc_getClass ("SFSafariExtension");
	__xamarin_class_map [2537].handle = objc_getClass ("SFSafariExtensionHandler");
	__xamarin_class_map [2538].handle = objc_getClass ("SFSafariPage");
	__xamarin_class_map [2539].handle = objc_getClass ("SFSafariTab");
	__xamarin_class_map [2540].handle = objc_getClass ("SFSafariWindow");
	__xamarin_class_map [2541].handle = objc_getClass ("QLThumbnailGenerator");
	__xamarin_class_map [2542].handle = objc_getClass ("NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate");
	__xamarin_class_map [2543].handle = objc_getClass ("NCWidgetListViewController");
	__xamarin_class_map [2544].handle = objc_getClass ("NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate");
	__xamarin_class_map [2545].handle = objc_getClass ("NCWidgetSearchViewController");
	__xamarin_class_map [2546].handle = objc_getClass ("LPMetadataProvider");
	__xamarin_class_map [2547].handle = objc_getClass ("LAContext");
	__xamarin_class_map [2548].handle = objc_getClass ("ExternalAccessory_EAAccessory__EAAccessoryDelegate");
	__xamarin_class_map [2549].handle = objc_getClass ("EAAccessory");
	__xamarin_class_map [2550].handle = objc_getClass ("EAAccessoryManager");
	__xamarin_class_map [2551].handle = objc_getClass ("DCDevice");
	__xamarin_class_map [2552].handle = objc_getClass ("ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate");
	__xamarin_class_map [2553].handle = objc_getClass ("IKCameraDeviceView");
	__xamarin_class_map [2554].handle = objc_getClass ("ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate");
	__xamarin_class_map [2555].handle = objc_getClass ("IKDeviceBrowserView");
	__xamarin_class_map [2556].handle = objc_getClass ("IKFilterBrowserPanel");
	__xamarin_class_map [2557].handle = objc_getClass ("ImageKit_IKImageBrowserView__IKImageBrowserDelegate");
	__xamarin_class_map [2558].handle = objc_getClass ("IKImageBrowserView");
	__xamarin_class_map [2559].handle = objc_getClass ("ImageKit_IKSaveOptions__IKSaveOptionsDelegate");
	__xamarin_class_map [2560].handle = objc_getClass ("IKSaveOptions");
	__xamarin_class_map [2561].handle = objc_getClass ("ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate");
	__xamarin_class_map [2562].handle = objc_getClass ("IKScannerDeviceView");
	__xamarin_class_map [2563].handle = objc_getClass ("FIFinderSync");
	__xamarin_class_map [2564].handle = objc_getClass ("FIFinderSyncController");
	__xamarin_class_map [2565].handle = objc_getClass ("ACAccountStore");
	__xamarin_class_map [2566].handle = objc_getClass ("VNFaceLandmarkRegion2D");
	__xamarin_class_map [2567].handle = objc_getClass ("VNRecognizeAnimalsRequest");
	__xamarin_class_map [2568].handle = objc_getClass ("UNUserNotificationCenter");
	__xamarin_class_map [2569].handle = objc_getClass ("StoreKit_SKRequest__SKRequestDelegate");
	__xamarin_class_map [2570].handle = objc_getClass ("StoreKit_SKProductsRequest__SKProductsRequestDelegate");
	__xamarin_class_map [2571].handle = objc_getClass ("SKProductsRequest");
	__xamarin_class_map [2572].handle = objc_getClass ("SLRequest");
	__xamarin_class_map [2573].handle = objc_getClass ("ScriptingBridge_SBApplication__SBApplicationDelegate");
	__xamarin_class_map [2574].handle = objc_getClass ("SBApplication");
	__xamarin_class_map [2575].handle = objc_getClass ("PHLivePhotoEditingContext");
	__xamarin_class_map [2576].handle = objc_getClass ("PHAssetResourceManager");
	__xamarin_class_map [2577].handle = objc_getClass ("PHPhotoLibrary");
	__xamarin_class_map [2578].handle = objc_getClass ("PdfKit_PdfView__PdfViewDelegate");
	__xamarin_class_map [2579].handle = objc_getClass ("PDFView");
	__xamarin_class_map [2580].handle = objc_getClass ("PdfKit_PdfDocument__PdfDocumentDelegate");
	__xamarin_class_map [2581].handle = objc_getClass ("PDFDocument");
	__xamarin_class_map [2582].handle = objc_getClass ("PDFThumbnailView");
	__xamarin_class_map [2583].handle = objc_getClass ("NETunnelProvider");
	__xamarin_class_map [2584].handle = objc_getClass ("NEPacketTunnelProvider");
	__xamarin_class_map [2585].handle = objc_getClass ("NEVPNManager");
	__xamarin_class_map [2586].handle = objc_getClass ("NEAppProxyFlow");
	__xamarin_class_map [2587].handle = objc_getClass ("NEAppProxyProvider");
	__xamarin_class_map [2588].handle = objc_getClass ("NETunnelProviderManager");
	__xamarin_class_map [2589].handle = objc_getClass ("NEAppProxyProviderManager");
	__xamarin_class_map [2590].handle = objc_getClass ("NEAppProxyTCPFlow");
	__xamarin_class_map [2591].handle = objc_getClass ("NEAppProxyUDPFlow");
	__xamarin_class_map [2592].handle = objc_getClass ("NEDNSProxyManager");
	__xamarin_class_map [2593].handle = objc_getClass ("NEDNSProxyProvider");
	__xamarin_class_map [2594].handle = objc_getClass ("NEFilterDataProvider");
	__xamarin_class_map [2595].handle = objc_getClass ("NEFilterManager");
	__xamarin_class_map [2596].handle = objc_getClass ("NEPacketTunnelFlow");
	__xamarin_class_map [2597].handle = objc_getClass ("NETransparentProxyManager");
	__xamarin_class_map [2598].handle = objc_getClass ("NWTCPConnection");
	__xamarin_class_map [2599].handle = objc_getClass ("NWUDPSession");
	__xamarin_class_map [2600].handle = objc_getClass ("NLEmbedding");
	__xamarin_class_map [2601].handle = objc_getClass ("NLLanguageRecognizer");
	__xamarin_class_map [2602].handle = objc_getClass ("NLTagger");
	__xamarin_class_map [2603].handle = objc_getClass ("MCSession");
	__xamarin_class_map [2604].handle = objc_getClass ("MDLMesh");
	__xamarin_class_map [2605].handle = objc_getClass ("MPSNNGraph");
	__xamarin_class_map [2606].handle = objc_getClass ("MTKTextureLoader");
	__xamarin_class_map [2607].handle = objc_getClass ("MPSkipIntervalCommand");
	__xamarin_class_map [2608].handle = objc_getClass ("MKDirections");
	__xamarin_class_map [2609].handle = objc_getClass ("MKLocalSearch");
	__xamarin_class_map [2610].handle = objc_getClass ("MKMapSnapshotter");
	__xamarin_class_map [2611].handle = objc_getClass ("MapKit_MKMapView__MKMapViewDelegate");
	__xamarin_class_map [2612].handle = objc_getClass ("MKMapView");
	__xamarin_class_map [2613].handle = objc_getClass ("MKPointOfInterestFilter");
	__xamarin_class_map [2614].handle = objc_getClass ("INInteraction");
	__xamarin_class_map [2615].handle = objc_getClass ("GLKTextureLoader");
	__xamarin_class_map [2616].handle = objc_getClass ("GCController");
	__xamarin_class_map [2617].handle = objc_getClass ("EKEventStore");
	__xamarin_class_map [2618].handle = objc_getClass ("CWInterface");
	__xamarin_class_map [2619].handle = objc_getClass ("CSSearchableIndex");
	__xamarin_class_map [2620].handle = objc_getClass ("CMPedometer");
	__xamarin_class_map [2621].handle = objc_getClass ("CoreLocation_CLLocationManager__CLLocationManagerDelegate");
	__xamarin_class_map [2622].handle = objc_getClass ("CLLocationManager");
	__xamarin_class_map [2623].handle = objc_getClass ("CLGeocoder");
	__xamarin_class_map [2624].handle = objc_getClass ("CoreAnimation_CAAnimation__CAAnimationDelegate");
	__xamarin_class_map [2625].handle = objc_getClass ("CNContactStore");
	__xamarin_class_map [2626].handle = objc_getClass ("CKContainer");
	__xamarin_class_map [2627].handle = objc_getClass ("CKDatabase");
	__xamarin_class_map [2628].handle = objc_getClass ("AUAudioUnit");
	__xamarin_class_map [2629].handle = objc_getClass ("SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate");
	__xamarin_class_map [2630].handle = objc_getClass ("SKPhysicsWorld");
	__xamarin_class_map [2631].handle = objc_getClass ("SKTextureAtlas");
	__xamarin_class_map [2632].handle = objc_getClass ("SCNAction");
	__xamarin_class_map [2633].handle = objc_getClass ("SCNAnimationEvent");
	__xamarin_class_map [2634].handle = objc_getClass ("SCNLayer");
	__xamarin_class_map [2635].handle = objc_getClass ("SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate");
	__xamarin_class_map [2636].handle = objc_getClass ("SCNPhysicsWorld");
	__xamarin_class_map [2637].handle = objc_getClass ("SCNRenderer");
	__xamarin_class_map [2638].handle = objc_getClass ("SCNView");
	__xamarin_class_map [2639].handle = objc_getClass ("GKTurnBasedExchange");
	__xamarin_class_map [2640].handle = objc_getClass ("GameKit_GKMatch__GKMatchDelegate");
	__xamarin_class_map [2641].handle = objc_getClass ("GKMatch");
	__xamarin_class_map [2642].handle = objc_getClass ("GKMatchmaker");
	__xamarin_class_map [2643].handle = objc_getClass ("GKGameSession");
	__xamarin_class_map [2644].handle = objc_getClass ("GKAchievement");
	__xamarin_class_map [2645].handle = objc_getClass ("GKAchievementDescription");
	__xamarin_class_map [2646].handle = objc_getClass ("GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate");
	__xamarin_class_map [2647].handle = objc_getClass ("GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate");
	__xamarin_class_map [2648].handle = objc_getClass ("GKGameCenterViewController");
	__xamarin_class_map [2649].handle = objc_getClass ("GKAchievementViewController");
	__xamarin_class_map [2650].handle = objc_getClass ("GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate");
	__xamarin_class_map [2651].handle = objc_getClass ("GKChallengeEventHandler");
	__xamarin_class_map [2652].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [2653].handle = objc_getClass ("GKFriendRequestComposeViewController");
	__xamarin_class_map [2654].handle = objc_getClass ("GKLeaderboard");
	__xamarin_class_map [2655].handle = objc_getClass ("GKLeaderboardSet");
	__xamarin_class_map [2656].handle = objc_getClass ("GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [2657].handle = objc_getClass ("GKLeaderboardViewController");
	__xamarin_class_map [2658].handle = objc_getClass ("GKPlayer");
	__xamarin_class_map [2659].handle = objc_getClass ("GKLocalPlayer");
	__xamarin_class_map [2660].handle = objc_getClass ("GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [2661].handle = objc_getClass ("GKMatchmakerViewController");
	__xamarin_class_map [2662].handle = objc_getClass ("GKNotificationBanner");
	__xamarin_class_map [2663].handle = objc_getClass ("GKSavedGame");
	__xamarin_class_map [2664].handle = objc_getClass ("GKScore");
	__xamarin_class_map [2665].handle = objc_getClass ("GKTurnBasedMatch");
	__xamarin_class_map [2666].handle = objc_getClass ("WKWebView");
	__xamarin_class_map [2667].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy");
	__xamarin_class_map [2668].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy2");
	__xamarin_class_map [2669].handle = objc_getClass ("WebKit_WebView__WebFrameLoadDelegate");
	__xamarin_class_map [2670].handle = objc_getClass ("WebKit_WebView__WebDownloadDelegate");
	__xamarin_class_map [2671].handle = objc_getClass ("WebKit_WebView__WebResourceLoadDelegate");
	__xamarin_class_map [2672].handle = objc_getClass ("WebKit_WebView__WebUIDelegate");
	__xamarin_class_map [2673].handle = objc_getClass ("WebKit_WebView__WebPolicyDelegate");
	__xamarin_class_map [2674].handle = objc_getClass ("WebView");
	__xamarin_class_map [2675].handle = objc_getClass ("WebHistoryItem");
	__xamarin_class_map [2676].handle = objc_getClass ("WKContentRuleListStore");
	__xamarin_class_map [2677].handle = objc_getClass ("WKHTTPCookieStore");
	__xamarin_class_map [2678].handle = objc_getClass ("WKWebsiteDataStore");
	__xamarin_class_map [2679].handle = objc_getClass ("AppKit_NSApplication__NSApplicationDelegate");
	__xamarin_class_map [2680].handle = objc_getClass ("NSApplication");
	__xamarin_class_map [2681].handle = objc_getClass ("NSBrowser");
	__xamarin_class_map [2682].handle = objc_getClass ("AppKit_NSMatrix__NSMatrixDelegate");
	__xamarin_class_map [2683].handle = objc_getClass ("AppKit_NSPathCell__NSPathCellDelegate");
	__xamarin_class_map [2684].handle = objc_getClass ("NSPathCell");
	__xamarin_class_map [2685].handle = objc_getClass ("AppKit_NSTableView__NSTableViewDelegate");
	__xamarin_class_map [2686].handle = objc_getClass ("NSTableView");
	__xamarin_class_map [2687].handle = objc_getClass ("AppKit_NSAlert__NSAlertDelegate");
	__xamarin_class_map [2688].handle = objc_getClass ("NSAlert");
	__xamarin_class_map [2689].handle = objc_getClass ("NSColor");
	__xamarin_class_map [2690].handle = objc_getClass ("AppKit_NSTextField__NSTextFieldDelegate");
	__xamarin_class_map [2691].handle = objc_getClass ("AppKit_NSComboBox__NSComboBoxDelegate");
	__xamarin_class_map [2692].handle = objc_getClass ("NSComboBox");
	__xamarin_class_map [2693].handle = objc_getClass ("__NSDocumentDuplicateCallback");
	__xamarin_class_map [2694].handle = objc_getClass ("NSDocument");
	__xamarin_class_map [2695].handle = objc_getClass ("NSEvent");
	__xamarin_class_map [2696].handle = objc_getClass ("NSFont");
	__xamarin_class_map [2697].handle = objc_getClass ("__NSGestureRecognizerToken");
	__xamarin_class_map [2698].handle = objc_getClass ("__NSGestureRecognizerParameterlessToken");
	__xamarin_class_map [2699].handle = objc_getClass ("__NSGestureRecognizerParametrizedToken");
	__xamarin_class_map [2700].handle = objc_getClass ("AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate");
	__xamarin_class_map [2701].handle = objc_getClass ("NSGestureRecognizer");
	__xamarin_class_map [2702].handle = objc_getClass ("__NSClickGestureRecognizer");
	__xamarin_class_map [2703].handle = objc_getClass ("NSClickGestureRecognizer");
	__xamarin_class_map [2704].handle = objc_getClass ("__NSMagnificationGestureRecognizer");
	__xamarin_class_map [2705].handle = objc_getClass ("NSMagnificationGestureRecognizer");
	__xamarin_class_map [2706].handle = objc_getClass ("__NSPanGestureRecognizer");
	__xamarin_class_map [2707].handle = objc_getClass ("NSPanGestureRecognizer");
	__xamarin_class_map [2708].handle = objc_getClass ("__NSPressGestureRecognizer");
	__xamarin_class_map [2709].handle = objc_getClass ("NSPressGestureRecognizer");
	__xamarin_class_map [2710].handle = objc_getClass ("__NSRotationGestureRecognizer");
	__xamarin_class_map [2711].handle = objc_getClass ("NSRotationGestureRecognizer");
	__xamarin_class_map [2712].handle = objc_getClass ("NSGradient");
	__xamarin_class_map [2713].handle = objc_getClass ("AppKit_NSImage__NSImageDelegate");
	__xamarin_class_map [2714].handle = objc_getClass ("NSImage");
	__xamarin_class_map [2715].handle = objc_getClass ("NSMenuItem");
	__xamarin_class_map [2716].handle = objc_getClass ("NSPopUpButton");
	__xamarin_class_map [2717].handle = objc_getClass ("NSPopUpButtonCell");
	__xamarin_class_map [2718].handle = objc_getClass ("NSPredicateEditorRowTemplate");
	__xamarin_class_map [2719].handle = objc_getClass ("NSScreen");
	__xamarin_class_map [2720].handle = objc_getClass ("AppKit_NSSharingService__NSSharingServiceDelegate");
	__xamarin_class_map [2721].handle = objc_getClass ("NSSharingService");
	__xamarin_class_map [2722].handle = objc_getClass ("AppKit_NSSound__NSSoundDelegate");
	__xamarin_class_map [2723].handle = objc_getClass ("NSSound");
	__xamarin_class_map [2724].handle = objc_getClass ("NSSpellChecker");
	__xamarin_class_map [2725].handle = objc_getClass ("AppKit_NSTextStorage__NSTextStorageDelegate");
	__xamarin_class_map [2726].handle = objc_getClass ("NSTextStorage");
	__xamarin_class_map [2727].handle = objc_getClass ("AppKit_NSWindow__NSWindowDelegate");
	__xamarin_class_map [2728].handle = objc_getClass ("NSWorkspace");
	__xamarin_class_map [2729].handle = objc_getClass ("NSAccessibilityElement");
	__xamarin_class_map [2730].handle = objc_getClass ("AppKit_NSAnimation__NSAnimationDelegate");
	__xamarin_class_map [2731].handle = objc_getClass ("NSColorPanel");
	__xamarin_class_map [2732].handle = objc_getClass ("AppKit_NSDatePicker__NSDatePickerCellDelegate");
	__xamarin_class_map [2733].handle = objc_getClass ("NSDatePicker");
	__xamarin_class_map [2734].handle = objc_getClass ("AppKit_NSDatePickerCell__NSDatePickerCellDelegate");
	__xamarin_class_map [2735].handle = objc_getClass ("NSDatePickerCell");
	__xamarin_class_map [2736].handle = objc_getClass ("AppKit_NSDrawer__NSDrawerDelegate");
	__xamarin_class_map [2737].handle = objc_getClass ("NSDrawer");
	__xamarin_class_map [2738].handle = objc_getClass ("NSHelpManager");
	__xamarin_class_map [2739].handle = objc_getClass ("NSMenu");
	__xamarin_class_map [2740].handle = objc_getClass ("NSOutlineView");
	__xamarin_class_map [2741].handle = objc_getClass ("AppKit_NSPageController__NSPageControllerDelegate");
	__xamarin_class_map [2742].handle = objc_getClass ("NSPageController");
	__xamarin_class_map [2743].handle = objc_getClass ("NSPopover");
	__xamarin_class_map [2744].handle = objc_getClass ("AppKit_NSRuleEditor__NSRuleEditorDelegate");
	__xamarin_class_map [2745].handle = objc_getClass ("AppKit_NSSavePanel__NSOpenSavePanelDelegate");
	__xamarin_class_map [2746].handle = objc_getClass ("NSScroller");
	__xamarin_class_map [2747].handle = objc_getClass ("NSScrollView");
	__xamarin_class_map [2748].handle = objc_getClass ("AppKit_NSSearchField__NSSearchFieldDelegate");
	__xamarin_class_map [2749].handle = objc_getClass ("NSSearchField");
	__xamarin_class_map [2750].handle = objc_getClass ("AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate");
	__xamarin_class_map [2751].handle = objc_getClass ("NSSharingServicePicker");
	__xamarin_class_map [2752].handle = objc_getClass ("NSSliderAccessory");
	__xamarin_class_map [2753].handle = objc_getClass ("NSSplitView");
	__xamarin_class_map [2754].handle = objc_getClass ("AppKit_NSTabView__NSTabViewDelegate");
	__xamarin_class_map [2755].handle = objc_getClass ("NSTabView");
	__xamarin_class_map [2756].handle = objc_getClass ("AppKit_NSText__NSTextDelegate");
	__xamarin_class_map [2757].handle = objc_getClass ("NSText");
	__xamarin_class_map [2758].handle = objc_getClass ("NSTextAlternatives");
	__xamarin_class_map [2759].handle = objc_getClass ("NSTextInputContext");
	__xamarin_class_map [2760].handle = objc_getClass ("AppKit_NSTextView__NSTextViewDelegate");
	__xamarin_class_map [2761].handle = objc_getClass ("NSTextView");
	__xamarin_class_map [2762].handle = objc_getClass ("AppKit_NSToolbar__NSToolbarDelegate");
	__xamarin_class_map [2763].handle = objc_getClass ("NSToolbar");
	__xamarin_class_map [2764].handle = objc_getClass ("AppKit_NSTouchBar__NSTouchBarDelegate");
	__xamarin_class_map [2765].handle = objc_getClass ("NSTouchBar");
	__xamarin_class_map [2766].handle = objc_getClass ("MLMultiArray");
	__xamarin_class_map [2767].handle = objc_getClass ("NSManagedObjectContext");
	__xamarin_class_map [2768].handle = objc_getClass ("NSPersistentStoreCoordinator");
	__xamarin_class_map [2769].handle = objc_getClass ("CoreBluetooth_CBCentralManager__CBCentralManagerDelegate");
	__xamarin_class_map [2770].handle = objc_getClass ("CBCentralManager");
	__xamarin_class_map [2771].handle = objc_getClass ("CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate");
	__xamarin_class_map [2772].handle = objc_getClass ("CBPeripheralManager");
	__xamarin_class_map [2773].handle = objc_getClass ("CoreBluetooth_CBPeripheral__CBPeripheralDelegate");
	__xamarin_class_map [2774].handle = objc_getClass ("CBPeripheral");
	__xamarin_class_map [2775].handle = objc_getClass ("AVFoundation_AVCaptureFileOutput_recordingProxy");
	__xamarin_class_map [2776].handle = objc_getClass ("AVCaptureVideoPreviewLayer");
	__xamarin_class_map [2777].handle = objc_getClass ("AVAudioUnitComponentManager");
	__xamarin_class_map [2778].handle = objc_getClass ("AVPlayerItem");
	__xamarin_class_map [2779].handle = objc_getClass ("AVPlayerItemVideoOutput");
	__xamarin_class_map [2780].handle = objc_getClass ("AVAssetExportSession");
	__xamarin_class_map [2781].handle = objc_getClass ("AVAssetWriter");
	__xamarin_class_map [2782].handle = objc_getClass ("AVAudioEngine");
	__xamarin_class_map [2783].handle = objc_getClass ("AVAudioPlayerNode");
	__xamarin_class_map [2784].handle = objc_getClass ("AVAudioUnitComponent");
	__xamarin_class_map [2785].handle = objc_getClass ("AVCaptureDevice");
	__xamarin_class_map [2786].handle = objc_getClass ("AVCapturePhotoOutput");
	__xamarin_class_map [2787].handle = objc_getClass ("AVCapturePhotoSettings");
	__xamarin_class_map [2788].handle = objc_getClass ("AVCaptureSession");
	__xamarin_class_map [2789].handle = objc_getClass ("AVCaptureStillImageOutput");
	__xamarin_class_map [2790].handle = objc_getClass ("AVContentKeySession");
	__xamarin_class_map [2791].handle = objc_getClass ("AVFragmentedMovie");
	__xamarin_class_map [2792].handle = objc_getClass ("AVFragmentedMovieTrack");
	__xamarin_class_map [2793].handle = objc_getClass ("AVMIDIPlayer");
	__xamarin_class_map [2794].handle = objc_getClass ("AVPlayerMediaSelectionCriteria");
	__xamarin_class_map [2795].handle = objc_getClass ("AVRouteDetector");
	__xamarin_class_map [2796].handle = objc_getClass ("AVSampleBufferAudioRenderer");
	__xamarin_class_map [2797].handle = objc_getClass ("AVSampleBufferDisplayLayer");
	__xamarin_class_map [2798].handle = objc_getClass ("AVSampleBufferGenerator");
	__xamarin_class_map [2799].handle = objc_getClass ("AVSampleBufferRenderSynchronizer");
	__xamarin_class_map [2800].handle = objc_getClass ("AVFoundation_AVSpeechSynthesizer__AVSpeechSynthesizerDelegate");
	__xamarin_class_map [2801].handle = objc_getClass ("AVSpeechSynthesizer");
	__xamarin_class_map [2802].handle = objc_getClass ("ASAuthorizationAppleIDCredential");
	__xamarin_class_map [2803].handle = objc_getClass ("ASAuthorizationAppleIDProvider");
	__xamarin_class_map [2804].handle = objc_getClass ("ASAuthorizationProviderExtensionAuthorizationRequest");
	__xamarin_class_map [2805].handle = objc_getClass ("ASAuthorizationSingleSignOnCredential");
	__xamarin_class_map [2806].handle = objc_getClass ("Foundation_NSUrlSessionHandler_WrappedNSInputStream");
	__xamarin_class_map [2807].handle = objc_getClass ("Foundation_NSNetService__NSNetServiceDelegate");
	__xamarin_class_map [2808].handle = objc_getClass ("NSNetService");
	__xamarin_class_map [2809].handle = objc_getClass ("NSUserActivity");
	__xamarin_class_map [2810].handle = objc_getClass ("NSCalendar");
	__xamarin_class_map [2811].handle = objc_getClass ("NSDictionary");
	__xamarin_class_map [2812].handle = objc_getClass ("NSFileManager");
	__xamarin_class_map [2813].handle = objc_getClass ("NSHost");
	__xamarin_class_map [2814].handle = objc_getClass ("NSHTTPCookieStorage");
	__xamarin_class_map [2815].handle = objc_getClass ("NSIndexPath");
	__xamarin_class_map [2816].handle = objc_getClass ("Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate");
	__xamarin_class_map [2817].handle = objc_getClass ("NSKeyedArchiver");
	__xamarin_class_map [2818].handle = objc_getClass ("Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2819].handle = objc_getClass ("NSLocale");
	__xamarin_class_map [2820].handle = objc_getClass ("NSMutableDictionary");
	__xamarin_class_map [2821].handle = objc_getClass ("Foundation_NSStream__NSStreamDelegate");
	__xamarin_class_map [2822].handle = objc_getClass ("NSThread");
	__xamarin_class_map [2823].handle = objc_getClass ("Foundation_NSThread_ActionThread");
	__xamarin_class_map [2824].handle = objc_getClass ("NSUbiquitousKeyValueStore");
	__xamarin_class_map [2825].handle = objc_getClass ("NSUndoManager");
	__xamarin_class_map [2826].handle = objc_getClass ("NSURL");
	__xamarin_class_map [2827].handle = objc_getClass ("NSURLConnection");
	__xamarin_class_map [2828].handle = objc_getClass ("NSUserDefaults");
	__xamarin_class_map [2829].handle = objc_getClass ("NSItemProvider");
	__xamarin_class_map [2830].handle = objc_getClass ("__NSObject_Disposer");
	__xamarin_class_map [2831].handle = objc_getClass ("__XamarinObjectObserver");
	__xamarin_class_map [2832].handle = objc_getClass ("NSProgress");
	__xamarin_class_map [2833].handle = objc_getClass ("Foundation_NSCache__NSCacheDelegate");
	__xamarin_class_map [2834].handle = objc_getClass ("NSCache");
	__xamarin_class_map [2835].handle = objc_getClass ("NSFileHandle");
	__xamarin_class_map [2836].handle = objc_getClass ("NSFileVersion");
	__xamarin_class_map [2837].handle = objc_getClass ("Foundation_NSMetadataQuery__NSMetadataQueryDelegate");
	__xamarin_class_map [2838].handle = objc_getClass ("NSMetadataQuery");
	__xamarin_class_map [2839].handle = objc_getClass ("Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate");
	__xamarin_class_map [2840].handle = objc_getClass ("NSNetServiceBrowser");
	__xamarin_class_map [2841].handle = objc_getClass ("NSProcessInfo");
	__xamarin_class_map [2842].handle = objc_getClass ("NSSecureUnarchiveFromDataTransformer");
	__xamarin_class_map [2843].handle = objc_getClass ("NSTask");
	__xamarin_class_map [2844].handle = objc_getClass ("NSURLCache");
	__xamarin_class_map [2845].handle = objc_getClass ("NSURLCredentialStorage");
	__xamarin_class_map [2846].handle = objc_getClass ("NSURLSession");
	__xamarin_class_map [2847].handle = objc_getClass ("NSURLSessionStreamTask");
	__xamarin_class_map [2848].handle = objc_getClass ("NSURLSessionWebSocketTask");
	__xamarin_class_map [2849].handle = objc_getClass ("Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate");
	__xamarin_class_map [2850].handle = objc_getClass ("NSUserNotificationCenter");
	__xamarin_class_map [2851].handle = objc_getClass ("Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate");
	__xamarin_class_map [2852].handle = [Xamarin_Forms_Platform_MacOS_VisualElementRenderer_1 class];
	__xamarin_class_map [2853].handle = [Xamarin_Forms_Platform_MacOS_ViewRenderer_2 class];
	__xamarin_class_map [2854].handle = [Xamarin_Forms_Platform_MacOS_ViewRenderer class];
	__xamarin_class_map [2855].handle = [Xamarin_Forms_Maps_MacOS_MapRenderer class];
	__xamarin_class_map [2856].handle = [Xamarin_Forms_Platform_macOS_Controls_FormsBoxView class];
	__xamarin_class_map [2857].handle = [Xamarin_Forms_Platform_macOS_Controls_FormsNSSlider class];
	__xamarin_class_map [2858].handle = [Xamarin_Forms_Platform_MacOS_FormsNSDatePicker class];
	__xamarin_class_map [2859].handle = [Xamarin_Forms_Platform_MacOS_FormsApplicationDelegate class];
	__xamarin_class_map [2860].handle = [Xamarin_Forms_Platform_MacOS_PlatformRenderer class];
	__xamarin_class_map [2861].handle = [Xamarin_Forms_Platform_MacOS_FlippedClipView class];
	__xamarin_class_map [2862].handle = [Xamarin_Forms_Platform_MacOS_PageRenderer class];
	__xamarin_class_map [2863].handle = [Xamarin_Forms_Platform_MacOS_DefaultRenderer class];
	__xamarin_class_map [2864].handle = [Xamarin_Forms_Platform_MacOS_BoxViewRenderer class];
	__xamarin_class_map [2865].handle = [Xamarin_Forms_Platform_MacOS_ScrollViewRenderer class];
	__xamarin_class_map [2866].handle = [Xamarin_Forms_Platform_MacOS_ActivityIndicatorRenderer class];
	__xamarin_class_map [2867].handle = [Xamarin_Forms_Platform_MacOS_DatePickerRenderer class];
	__xamarin_class_map [2868].handle = [Xamarin_Forms_Platform_MacOS_FrameRenderer class];
	__xamarin_class_map [2869].handle = [Xamarin_Forms_Platform_MacOS_FormsNSImageView class];
	__xamarin_class_map [2870].handle = [Xamarin_Forms_Platform_MacOS_OpenGLViewRenderer class];
	__xamarin_class_map [2871].handle = [Xamarin_Forms_Platform_MacOS_MacOSOpenGLView class];
	__xamarin_class_map [2872].handle = [Xamarin_Forms_Platform_MacOS_PickerRenderer class];
	__xamarin_class_map [2873].handle = [Xamarin_Forms_Platform_MacOS_ProgressBarRenderer class];
	__xamarin_class_map [2874].handle = [Xamarin_Forms_Platform_MacOS_SearchBarRenderer class];
	__xamarin_class_map [2875].handle = [Xamarin_Forms_Platform_MacOS_SliderRenderer class];
	__xamarin_class_map [2876].handle = [Xamarin_Forms_Platform_MacOS_StepperRenderer class];
	__xamarin_class_map [2877].handle = [Xamarin_Forms_Platform_MacOS_CheckBoxRenderer class];
	__xamarin_class_map [2878].handle = [Xamarin_Forms_Platform_MacOS_SwitchRenderer class];
	__xamarin_class_map [2879].handle = [Xamarin_Forms_Platform_MacOS_TimePickerRenderer class];
	__xamarin_class_map [2880].handle = [Xamarin_Forms_Platform_MacOS_CellNSView class];
	__xamarin_class_map [2881].handle = [Xamarin_Forms_Platform_MacOS_TrackingClickNSView class];
	__xamarin_class_map [2882].handle = [Xamarin_Forms_Platform_MacOS_ViewCellNSView class];
	__xamarin_class_map [2883].handle = [Xamarin_Forms_Platform_MacOS_ListViewDataSource class];
	__xamarin_class_map [2884].handle = [Xamarin_Forms_Platform_MacOS_CustomNSTableHeaderView class];
	__xamarin_class_map [2885].handle = [Xamarin_Forms_Platform_MacOS_FormsPageControllerDelegate class];
	__xamarin_class_map [2886].handle = [Xamarin_Forms_Platform_MacOS_NavigationChildPageWrapper class];
	__xamarin_class_map [2887].handle = [Xamarin_Forms_Platform_MacOS_NativeViewPropertyListener class];
	__xamarin_class_map [2888].handle = [Xamarin_Forms_Platform_MacOS_LayoutRenderer class];
	__xamarin_class_map [2889].handle = [Xamarin_Forms_Platform_MacOS_NSPageContainer class];
	__xamarin_class_map [2890].handle = [Xamarin_Forms_Platform_MacOS_PageControllerDelegate class];
	__xamarin_class_map [2891].handle = [Xamarin_Forms_Platform_MacOS_TableViewRenderer class];
	__xamarin_class_map [2892].handle = [Xamarin_Forms_Platform_MacOS_TableViewDataSource class];
	__xamarin_class_map [2893].handle = [Xamarin_Forms_Platform_MacOS_UnEvenTableViewModelRenderer class];
	__xamarin_class_map [2894].handle = [Xamarin_Forms_Platform_MacOS_VerticallyCenteredTextFieldCell class];
	__xamarin_class_map [2895].handle = [Xamarin_Forms_Platform_MacOS_NativeViewWrapperRenderer class];
	__xamarin_class_map [2896].handle = [Xamarin_Forms_Platform_MacOS_LabelRenderer class];
	__xamarin_class_map [2897].handle = [Xamarin_Forms_Platform_MacOS_ButtonRenderer class];
	__xamarin_class_map [2898].handle = [Xamarin_Forms_Platform_MacOS_EntryRenderer_FormsNSTextField class];
	__xamarin_class_map [2899].handle = [Xamarin_Forms_Platform_MacOS_EntryRenderer class];
	__xamarin_class_map [2900].handle = [Xamarin_Forms_Platform_MacOS_EditorRenderer class];
	__xamarin_class_map [2901].handle = [Xamarin_Forms_Platform_MacOS_ImageRenderer class];
	__xamarin_class_map [2902].handle = [Xamarin_Forms_Platform_MacOS_WebViewRenderer_FormsWebFrameDelegate class];
	__xamarin_class_map [2903].handle = [Xamarin_Forms_Platform_MacOS_WebViewRenderer class];
	__xamarin_class_map [2904].handle = [Xamarin_Forms_Platform_MacOS_ListViewRenderer_FormsNSTableView class];
	__xamarin_class_map [2905].handle = [Xamarin_Forms_Platform_MacOS_ListViewRenderer class];
	__xamarin_class_map [2906].handle = [CarouselPageRenderer class];
	__xamarin_class_map [2907].handle = [Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer_ViewControllerWrapper class];
	__xamarin_class_map [2908].handle = [Xamarin_Forms_Platform_MacOS_MasterDetailPageRenderer class];
	__xamarin_class_map [2909].handle = [Xamarin_Forms_Platform_MacOS_TabbedPageRenderer class];
	__xamarin_class_map [2910].handle = [Xamarin_Forms_Platform_MacOS_NavigationPageRenderer class];
	__xamarin_class_map [2911].handle = [Xamarin_Forms_Platform_MacOS_NativeToolbarTracker_ToolBarItemNSButton class];
	__xamarin_class_map [2912].handle = [Xamarin_Forms_Platform_MacOS_NativeToolbarTracker class];
	__xamarin_class_map [2913].handle = [Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton_FormsNSButtonCell class];
	__xamarin_class_map [2914].handle = [Xamarin_Forms_Platform_MacOS_ButtonRenderer_FormsNSButton class];
	__xamarin_class_map [2915].handle = [AppDelegate class];
	__xamarin_class_map [2916].handle = [AnimatingViewsWindow class];
	__xamarin_class_map [2917].handle = [AnimatingViews_AnimatingViewsWindowController_MessageTypeDataSource class];
	__xamarin_class_map [2918].handle = [AnimatingViewsWindowController class];
	xamarin_add_registration_map (&__xamarin_registration_map, false);
}


} /* extern "C" */
